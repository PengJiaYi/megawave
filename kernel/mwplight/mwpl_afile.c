/*~~~~~~~~~~~~~~ mwplight - The MegaWave2 Light Preprocessor ~~~~~~~~~~~~~~~~~~~

 Generate the A-file (argfile: main of run-time command)

 Author : Jacques Froment
 Date : 2007
 Version : 1.0
 Versions history :
   0.1 (August 2005, JF) initial internal release
   0.2 (August 2006, JF) added generation of include string.h (Linux 2.6.12 & gcc 4.0.2)
   1.0 (April 2007, JF) final revision, ready for external release
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*~~~~~~~~  This file is part of the MegaWave2 light preprocessor ~~~~~~~~~~~~
MegaWave2 is a "soft-publication" for the scientific community. It has
been developed for research purposes and it comes without any warranty.
The last version is available at http://www.cmla.ens-cachan.fr/Cmla/Megawave
CMLA, Ecole Normale Superieure de Cachan, 61 av. du President Wilson,
      94235 Cachan cedex, France. Email: megawave@cmla.ens-cachan.fr 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#include <stdio.h>
#include <stdlib.h> 
#include <string.h>

#include "mwpl_main.h"

/* Prefix for MegaWave2 fixed internal names */
#define	MWPF		"_mw2f_"
/* Prefix for MegaWave2 user's internal names */
#define MWPU          "_mw2u_"

/* Variables */

char optb[BUFSIZ]; /* option list for _mwgetopt() */

/*~~~ Set in <fc> the function name that converts
      any scalar written in a string to its value
      in the type of the variable pointed by <a>.
  ~~~
*/

#ifdef __STDC__
void SetScalarConvFunction(Arg *a, char *fc)
#else
void SetScalarConvFunction(a,fc)
Arg *a;
char *fc;
#endif
{
  switch(a->var->Ctype)
    {
    case CHAR_T :
    case UCHAR_T:
    case SHORT_T:
    case USHORT_T:
    case INT_T:
    case UINT_T:
    case LONG_T:
    case ULONG_T:
      strcpy(fc,"atol");
      break;

    case FLOAT_T :      
    case DOUBLE_T :
      strcpy(fc,"atof");
      break;

    default:
      Error("[SetScalarConvFunction] No scalar conversion method implemented for C_id=\"%s\" of Ctype=%d (Stype=\"%s\")",
	    a->C_id,a->var->Ctype,a->var->Stype);
      break;
    }
}

/*~~~  
  Generate code to print numerical value in <s> assuming type in <a>.
  ~~~
*/

#ifdef __STDC__
void  print_value_scalar_arg(char *s,Arg *a)
#else
void  print_value_scalar_arg(s,a)
char *s;
Arg *a;
#endif

{
 switch(a->var->Ctype)
    {
    case CHAR_T :
      fprintf(fa,"printf(\"%%c\",%s);\n",s);
      break;
    case UCHAR_T:
      fprintf(fa,"printf(\"%%d\",(int) %s);\n",s);
      break;
    case SHORT_T:
      fprintf(fa,"printf(\"%%hd\",%s);\n",s);
      break;
    case USHORT_T:
      fprintf(fa,"printf(\"%%hu\",%s);\n",s);
      break;
    case INT_T:
      fprintf(fa,"printf(\"%%d\",%s);\n",s);
      break;
    case UINT_T:
      fprintf(fa,"printf(\"%%u\",%s);\n",s);
      break;
    case LONG_T:
      fprintf(fa,"printf(\"%%ld\",%s);\n",s);
      break;
    case ULONG_T:
      fprintf(fa,"printf(\"%%lu\",%s);\n",s);
      break;
    case FLOAT_T :      
    case DOUBLE_T :
      fprintf(fa,"printf(\"%%g\",%s);\n",s);
      break;
    default:
      Error("[print_value_scalar_arg] No scalar print value method implemented for C_id=\"%s\" of Ctype=%d (Stype=\"%s\")",
	    a->C_id,a->var->Ctype,a->var->Stype);
      break;
    }
}


/*~~~ write the header ~~~
*/

#ifdef __STDC__
void writeAheader(void)
#else
void writeAheader()
#endif
{
  fprintf(fa,"/* This A-file has been generated by the MegaWave2 Light Preprocessor.\n");
  fprintf(fa,"   It contains the source of the run-time command '%s'.\n",module_name);
  fprintf(fa,"*/\n\n");
}  

/*~~~ write generic declarations ~~~
*/

#ifdef __STDC__
void writegendecl(void)
#else
void writegendecl()
#endif

{
  fprintf(fa,"\n/* ~~~ [writegendecl] Generic declarations ~~~*/\n\n");

  /* include files */
  fprintf(fa, "#include <stdio.h>\n");

  /* stdlib.h for atoi() atol() atof() and string.h for strcpy() on Linux */
  fprintf(fa,"#ifdef __STDC__\n");
  fprintf(fa,"#include <stdlib.h>\n");
  fprintf(fa,"#include <string.h>\n");
  fprintf(fa,"#else\n");
  fprintf(fa, "extern int atoi();\n");
  fprintf(fa, "extern long atol();\n");
  fprintf(fa, "extern double atof();\n");
  fprintf(fa,"#endif\n");

  fprintf(fa, "#include \"mw.h\"\n");
  fprintf(fa, "#include \"mwi.h\"\n\n");
  fprintf(fa, "#define TRUE  1\n");
  fprintf(fa, "#define FALSE 0\n");

  fprintf(fa,"\n");
  fprintf(fa,"#ifdef __STDC__\n");
  fprintf(fa, "int _%s(int argc, char *argv[])\n", module_name);
  fprintf(fa,"#else\n");
  fprintf(fa, "_%s(argc, argv)\n", module_name);
  fprintf(fa, "int argc;\n");
  fprintf(fa, "char *argv[];\n");
  fprintf(fa,"#endif\n");

  fprintf(fa, "\n{\n");
  
  fprintf(fa, "  int %sc; /* for  _mwgetopt()*/\n", MWPF);
  /*fprintf(fa, "  char *%sname;\n", MWPF); NOT SURE IT IS USEFUL */
  fprintf(fa, "  char %stype[mw_ftype_size+1]; /* for _mwload_* functions */\n", MWPF);
  fprintf(fa, "  char %scomment[BUFSIZ]; /* for _mwload_* functions */\n", MWPF);

  if (H->NbVarArg > 0)
    {
      fprintf(fa, "  int %svar_flg;\n", MWPF);
      fprintf(fa, "  int %si;\n", MWPF); /* for argument loop in case of variable arguments */
    }

  /* external variables */
  fprintf(fa, "  extern char type_force[];\n");
  fprintf(fa, "  extern char *_mwoptarg;\n");
  fprintf(fa, "  extern int _mwoptind;\n");

  /* NOT SURE IT IS USEFUL
     print_io_function(fd);
  */

  fprintf(fa,"\n/* ~~~ end of [writegendecl] ~~~*/\n\n");  
}

/*~~~ write definition of a variable using the declaration type
      given in dt (see DT_* constants).
      Set the DeclType field of a->var, so we can remember
      the declaration type.
  ~~~
*/

#ifdef __STDC__
void writedefvar(Arg *a, int dt)
#else
void writedefvar(a,dt)
Arg *a;
int dt;
#endif

{
  switch(dt)
    {
    case DT_Ftype_alone:
      if (!ISARG_IMPLICITPOINTER(a))
	fprintf(fa, "  %s %s=0;\n",a->var->Ftype,a->C_id);	      
      else
	fprintf(fa, "  %s %s=NULL;\n",a->var->Ftype,a->C_id);	      
      break;

    case DT_Ftype_auxvar:
      if (!ISARG_IMPLICITPOINTER(a))
	Error("[writedefvar] Invalid declaration type DT_Ftype_auxvar for C_id=\"%s\" of Ctype=%d (Stype=\"%s\", Ftype=\"%s\") : not a pointer",
	      a->C_id,a->var->Ctype,a->var->Stype,a->var->Ftype);      
      /* introduce a local variable of type Stype with the default value */
      fprintf(fa, "  %s %s%s= %s;\n",a->var->Stype,MWPU,a->C_id,a->Val);	  
      /* set pointer to the address of the local variable having the default value */
      fprintf(fa, "  %s %s= & %s%s;\n",a->var->Ftype,a->C_id,MWPU,a->C_id);	  
      break;

    case DT_Ftype_auxvarnull:
      if (!ISARG_IMPLICITPOINTER(a))
	Error("[writedefvar] Invalid declaration type DT_Ftype_auxvarnull for C_id=\"%s\" of Ctype=%d (Stype=\"%s\", Ftype=\"%s\") : not a pointer",
	      a->C_id,a->var->Ctype,a->var->Stype,a->var->Ftype);      
      /* introduce a local variable with default value 0*/
      fprintf(fa, "  %s %s%s= 0;\n",a->var->Stype,MWPU,a->C_id);	  
      /* set pointer to NULL. This pointer would be set to the address
	 of the local variable only if the option is selected */
      fprintf(fa, "  %s %s= NULL;\n",a->var->Ftype,a->C_id);	  
      break;

    case DT_Ftype_ret:
      fprintf(fa, "  %s %s_ret;\n",a->var->Ftype,a->C_id);
      break;

    case DT_Stype:
      if (ISARG_SCALAR(a))
	fprintf(fa, "  %s %s=0;\n",a->var->Stype,a->C_id);	      
      else
	fprintf(fa, "  %s %s=NULL;\n",a->var->Stype,a->C_id);	      
      break;

    default:
      Error("[writedefvar] Unimplemented declaration type dt=%d for C_id=\"%s\" of Ctype=%d (Stype=\"%s\", Ftype=\"%s\")",
	    dt,a->C_id,a->var->Ctype,a->var->Stype,a->var->Ftype);      
      
    }
  
  a->var->DeclType=dt;
}



/*~~~ write argument declarations ~~~
*/

#ifdef __STDC__
void writeargdecl(void)
#else
void writeargdecl()
#endif

{
  Arg *a;
  char *popt=NULL; /* To fill optb[] */

  fprintf(fa,"\n/* ~~~ [writeargdecl] Argument declarations ~~~*/\n\n");

  /* Propotype of the main function */
  fprintf(fa, "  /* Prototype of the main function */\n");  

  /* BEWARE : at this time, the M-file does not add the ANSI syntax and modules are written
     without using the ANSI declaration of functions. Therefore, we don't generate function's
     prototype with ANSI format.
  */
  WriteFuncPrototype(fa,C->mfunc,0);
  

  /* Variables for options */
  if (H->NbOption > 0)
    {
      fprintf(fa, "  /* Variables for options */\n");
      popt = optb;
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTION(a))
	  {
	    if (ISARG_FLAGOPT(a)&&(!ISARG_POINTERSCALAR(a)))
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of a flag option must be a pointer to a scalar (such as char *)",
		    a->C_id,a->var->Ftype);  
	    if (ISARG_DEFAULT(a)&&(!ISARG_POINTERSCALAR(a))) 
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of an option with default value must be a pointer to a scalar (such as float *)",
		    a->C_id,a->var->Ftype);  
	    if (ISARG_INTERVAL(a)&&(!ISARG_POINTERSCALAR(a))) 
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of an option with interval checking must be a pointer to a scalar (such as float *)",
		    a->C_id,a->var->Ftype);  
	    if (!ISARG_IMPLICITPOINTER(a))
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of an option must be a pointer to a scalar, or a MegaWave2 internal type",
		    a->C_id,a->var->Ftype);  	  
	    
	    
	    if (ISARG_DEFAULT(a))
	      /* option with default value */
	      writedefvar(a,DT_Ftype_auxvar);
	    else
	      if (ISARG_SCALAR(a))
		/* scalar option */
		writedefvar(a,DT_Ftype_auxvarnull);
	      else
		/* when there is no default value, initialize pointer to NULL */
		if (ISARG_POINTERFILE(a))
		  /* case of e.g. Cimage * : define variable as Cimage rather than Cimage * */
		  writedefvar(a,DT_Stype);
		else
		  writedefvar(a,DT_Ftype_alone);
	    
	    /* Fill optb[] */
	    *popt++ = a->Flag;
	    if  (!ISARG_FLAGOPT(a)) *popt++ = ':';
	  }
    }
  if (popt) *popt = '\0';

  /* Variables for needed arguments */
  if (H-> NbNeededArg > 0)
    {
      fprintf(fa, "  /* Variables for needed arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_NEEDED(a))
	  {
	    if (ISARG_INPUT(a))	
	      {
		if (ISARG_EXPLICITPOINTER(a))
		  Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of an input needed argument cannot be an explicit pointer",
			a->C_id,a->var->Ftype);  	  
		writedefvar(a,DT_Stype);
	      }
	    else
	      /* Output argument */
	      {
		if (!ISARG_IMPLICITPOINTER(a) && !ISARG_RETURNFUNC(a))
		  Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of an output needed argument must be a pointer to a scalar, a MegaWave2 internal type, or the value of the return function",
			a->C_id,a->var->Ftype);  	  
		
		if (ISARG_RETURNFUNC(a))
		  /* The output argument is the return function */
		  {
		    if (ISARG_EXPLICITPOINTER(a))
		      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : type of the return main function cannot be an explicit pointer (such as float *)",	
			    a->C_id,a->var->Ftype);  	  			
		    writedefvar(a,DT_Ftype_ret);
		  }
		else
		  {
		    if (ISARG_EXPLICITPOINTER(a))
		      writedefvar(a,DT_Stype);
		    else
		      writedefvar(a,DT_Ftype_alone);
		  }
	      }
	  }	
    }


  /* Variables for variable arguments  */
  if (H-> NbVarArg > 0)
    {
      fprintf(fa, "  /* Variables for variable arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_VARIABLE(a))
	  {
	    if (ISARG_INTERVAL(a)&&(!ISARG_POINTERSCALAR(a))) 
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of variable arguments with interval checking must be a pointer to a scalar (such as float *)",
		    a->C_id,a->var->Ftype);  
	    if (ISARG_INPUT(a))
	      {
		if (!ISARG_IMPLICITPOINTER(a))
		  Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of input variable arguments must be a pointer to a scalar, or a MegaWave2 internal type",
			a->C_id,a->var->Ftype);  	  
	      }
	    else
	      if (!ISARG_FILE(a))
		Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of output variable arguments must be of MegaWave2 internal type",
		      a->C_id,a->var->Ftype);  	  

	    if (ISARG_INPUT(a))
	      writedefvar(a,DT_Ftype_alone);
	    else
	      {
		if (ISARG_EXPLICITPOINTER(a))
		  writedefvar(a,DT_Stype);
		else
		  writedefvar(a,DT_Ftype_alone);
	      }
	    
	  }
    }


  /* Variables for optionals arguments  */
  if (H->NbOptionArg > 0)
    {
      fprintf(fa, "  /* Variables for optional arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTARG(a))
	  {
	    if (ISARG_DEFAULT(a)&&(!ISARG_POINTERSCALAR(a))) 
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of an optional argument with default value must be a pointer to a scalar (such as float *)",
		    a->C_id,a->var->Ftype);  
	    if (ISARG_INTERVAL(a)&&(!ISARG_POINTERSCALAR(a))) 
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of an optional argument with interval checking must be a pointer to a scalar (such as float *)",
		    a->C_id,a->var->Ftype);  
	    if (!ISARG_IMPLICITPOINTER(a))
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of an optional argument must be a pointer to a scalar, or a MegaWave2 internal type",
		    a->C_id,a->var->Ftype);  	  
	    
	    
	    if (ISARG_DEFAULT(a))
	      /* optional arg with default value */
	      writedefvar(a,DT_Ftype_auxvar);
	    else
	      if (ISARG_SCALAR(a))
		/* scalar optional arg */
		writedefvar(a,DT_Ftype_auxvarnull);
	      else
		/* when there is no default value, initialize pointer to NULL */
		writedefvar(a,DT_Ftype_alone);
	  }
    }


  /* Variables for not used arguments  */
  if (H->NbNotUsedArg > 0)
    {
      fprintf(fa, "  /* Variables for not used arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_NOTUSED(a))
	  {
	    if (!ISARG_IMPLICITPOINTER(a))
	      Error("Invalid usage for C_id=\"%s\" of type \"%s\" : variable of a not used argument must be a pointer to a scalar, or a MegaWave2 internal type",
		    a->C_id,a->var->Ftype);  
	    writedefvar(a,DT_Ftype_alone);
	  }
    }


  fprintf(fa,"\n/* ~~~ end of [writeargdecl] ~~~*/\n\n");
}

/*~~~  
  Print in the A-file the interval and the default
  value of the argument's value, if applicable.
  ~~~
*/

#ifdef __STDC__
void  print_interval_and_defval(Arg *a)
#else
void  print_interval_and_defval(a)
Arg *a;
#endif

{
  char t_m[3], t_M[3], fc[256];
  char A,B;

  if (!(ISARG_INTERVAL(a) || ISARG_DEFAULT(a))) return;

  fprintf(fa, " (");
  if (ISARG_INTERVAL(a))
    {
      switch (a->ICtype) 
	{
	case CLOSED :
	  A='['; B=']';
	  break;
	case MAX_EXCLUDED :
	  A='['; B='[';
	  break;
	case MIN_EXCLUDED :
	  A=']'; B=']';
	  break;
	case OPEN :
	  A=']'; B='[';
	  break;
	default :
	  Error("[print_interval_and_defval] Unexpected error for C_id=\"%s\" : illegal ICtype=%d",a->C_id,a->ICtype);
	  break;
	}
      fprintf(fa, "in %c%s,%s%c",A,a->Min,a->Max,B);
      if (ISARG_DEFAULT(a)) fprintf(fa, ", ");
    }
  if (ISARG_DEFAULT(a)) fprintf(fa, "default %s",a->Val);
  fprintf(fa, ")");
}


/*~~~  
  Generate code to check that input numerical value in <s>
  is in the range defined by the interval in <a>.
  ~~~
*/

#ifdef __STDC__
void  print_check_interval_arg(Arg *a, char *s)
#else
void  print_check_interval_arg(a,s)
Arg *a;
char *s;
#endif

{
  char t_m[3], t_M[3], fc[256];
  char A,B;
  
  switch (a->ICtype) 
    {
    case CLOSED :
      strcpy(t_m,"<"); strcpy(t_M,"<");
      A='['; B=']';
      break;
    case MAX_EXCLUDED :
      strcpy(t_m,"<"); strcpy(t_M,"<=");
      A='['; B='[';
      break;
    case MIN_EXCLUDED :
      strcpy(t_m,"<="); strcpy(t_M,"<");
      A=']'; B=']';
      break;
    case OPEN :
      strcpy(t_m,"<="); strcpy(t_M,"<=");
      A=']'; B='[';
      break;
    default :
      Error("[print_check_interval_arg] Unexpected error for C_id=\"%s\" : illegal ICtype=%d",a->C_id,a->ICtype);
      break;
    }
  
  SetScalarConvFunction(a,fc);
  
  fprintf(fa, "        if ((%s(%s) %s (%s) %s) || ((%s) %s %s %s(%s))) {\n",
	  fc,s,t_m, a->var->Stype,a->Min,
	  a->var->Stype,a->Max, t_M, fc, s);
  
  if (a->IOtype==READ)
    {
      fprintf(fa, "          char buffer[BUFSIZ];\n");
      fprintf(fa, "          sprintf(buffer, \"input data %%s converted to type %s is out of %c%s,%s%c\", %s);\n",
	      a->var->Stype,A,a->Min,a->Max,B,s);
      fprintf(fa, "          mwusage(buffer);\n");
    }
  else
    fprintf(fa, "          printf(\"output data %s converted to type %s is out of %c%s,%s%c\");\n",s,a->var->Stype,A,a->Min,a->Max,B);
  fprintf(fa, "        }\n");


}



/*~~~  
  Generate code to check that input files are readable, output
  files are writable and numerical values are in range
  ~~~
*/

#ifdef __STDC__
void  print_check_io_arg(void)
#else
void  print_check_io_arg()
#endif

{
  Arg *a;
  int n;

  fprintf(fa,"\n/* ~~~ [print_check_io_arg] ~~~*/\n\n");

  /* Check Options */
  if (H->NbOption>0)
    {
      fprintf(fa, "  /* Check io options */\n");
      fprintf(fa, "  _mwoptind = 1;\n");
      fprintf(fa, "  while ((%sc=_mwgetopt(argc, argv, \"%s\")) != -1) {\n", MWPF, optb);
      fprintf(fa, "    switch (%sc) {\n", MWPF);
      
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTION(a))
	  {
	    fprintf(fa, "      case '%c' :\n", a->Flag);
	    if (ISARG_FILE(a))
	      {
		if (ISARG_INPUT(a))
		  /* INPUT MW2 option */
		  {
		    fprintf(fa, "        if (!_mwis_readable(_mwoptarg)) {\n");
		    fprintf(fa, "          char buffer[BUFSIZ];\n");
		    fprintf(fa, "          sprintf(buffer, \"cannot find '%%s' in default path\", _mwoptarg);\n");
		    fprintf(fa, "          mwusage(buffer);\n");
		    fprintf(fa, "        }\n");
		  }
		else 
		  /* OUTPUT MW2 option */
		  {
		    fprintf(fa, "        if (!_mwis_writable(_mwoptarg)) {\n");
		    fprintf(fa, "          char buffer[BUFSIZ];\n");
		    fprintf(fa, "          sprintf(buffer, \"cannot write '%%s'\", _mwoptarg);\n");
		    fprintf(fa, "          mwusage(buffer);\n");
		    fprintf(fa, "        }\n");
		  }
	      }
	    else if (ISARG_SCALARNOTFLAG(a))
	      /* scalar option */
	      {
		if  (ISARG_INTERVAL(a)) print_check_interval_arg(a, "_mwoptarg");
	      }
	      else if (!ISARG_FLAGOPT(a))
		Error("[print_check_io_arg] Unexpected error for C_id=\"%s\" : option is not a FILE, SCALAR or FLAGOPT",a->C_id);

	    fprintf(fa, "        break;\n");
	  }
      /* Default : unknown option calls usage function */
      fprintf(fa, "      case '?' :\n");
      fprintf(fa, "        mwusage(NULL);\n");
      fprintf(fa, "        break;\n");
      fprintf(fa, "      default :\n");
      fprintf(fa, "        break;\n");
      fprintf(fa, "    }\n");
      fprintf(fa, "  }\n\n");
    } 

  n=0;
  /* Check needed arguments */
  if (H->NbNeededArg>0)
    {
      fprintf(fa, "  /* Check io needed arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_NEEDED(a))
	  {
	    if (ISARG_FILE(a))
	      {
		if (ISARG_INPUT(a))
		  /* INPUT MW2 needed argument */
		  {
		    fprintf(fa, "  /* input MW2 needed argument H_id=%s */\n",a->H_id);
		    fprintf(fa, "  if (_mwoptind+%d<argc) {\n", n);
		    fprintf(fa, "    if (!_mwis_readable(argv[_mwoptind+%d])) {\n", n);
		    fprintf(fa, "      char buffer[BUFSIZ];\n");
		    fprintf(fa, "      sprintf(buffer, \"cannot find '%%s' in default path\",  argv[_mwoptind+%d]);\n", n);
		    fprintf(fa, "      mwusage(buffer);\n");
		    fprintf(fa, "    }\n");
		    fprintf(fa, "  }\n");
		    fprintf(fa, "  else\n");
		    fprintf(fa, "    mwusage(\"missing '%s'\");\n", a->H_id);
		    n++;
		  }
		else 
		  /* OUTPUT MW2 needed argument */
		  {
		    fprintf(fa, "  /* output MW2 needed argument H_id=%s */\n",a->H_id);
		    fprintf(fa, "  if (_mwoptind+%d<argc) {\n", n);
		    fprintf(fa, "    if (!_mwis_writable(argv[_mwoptind+%d])) {\n", n);
		    fprintf(fa, "      char buffer[BUFSIZ];\n");
		    fprintf(fa, "      sprintf(buffer, \"cannot write '%%s'\", argv[_mwoptind+%d]);\n", n);
		    fprintf(fa, "      mwusage(buffer);\n");
		    fprintf(fa, "    }\n");
		    fprintf(fa, "  }\n");
		    fprintf(fa, "  else\n");
		    fprintf(fa, "    mwusage(\"missing '%s'\");\n", a->H_id);
		    n++; 
		  }
	      }
	    else if (ISARG_SCALAR(a))
	      /* scalar argument */
	      {
		if (ISARG_INPUT(a))
		  /* INPUT scalar argument */
		  {		    
		    if (ISARG_INTERVAL(a)) 
		      {
			char buffer[BUFSIZ];
			fprintf(fa, "  /* input scalar needed argument with interval checking H_id=%s */\n",a->H_id);
			sprintf(buffer, "argv[_mwoptind+%d]", n);
			fprintf(fa, "  if (_mwoptind+%d<argc) {\n", n);
			print_check_interval_arg(a, buffer);
			fprintf(fa, "  }\n");
			fprintf(fa, "  else\n");
			fprintf(fa, "    mwusage(\"missing '%s'\");\n", a->H_id);
		      }
		    else 
		      {
			fprintf(fa, "  /* input scalar needed argument H_id=%s */\n",a->H_id);
			fprintf(fa, "  if (_mwoptind+%d>=argc) \n", n);
			fprintf(fa, "    mwusage(\"missing '%s'\");\n", a->H_id);
		      }
		    n++;
		  }
	      }	    
	  }
    }


  /* Check optional arguments */
  if (H->NbOptionArg>0)
    {
      fprintf(fa, "  /* Check io optional arguments */\n");
      fprintf(fa, "  if (_mwoptind+%d < argc) {\n", n);
     for (a=H->usage;a;a=a->next)
	if (ISARG_OPTARG(a))
	  {
	    if (ISARG_FILE(a))
	      {
		if (ISARG_INPUT(a))
		  /* INPUT MW2 optional argument */
		  {
		    fprintf(fa, "    /* input MW2 optional argument H_id=%s */\n",a->H_id);
		    fprintf(fa, "    if (_mwoptind+%d<argc) {\n", n);
		    fprintf(fa, "      if (!_mwis_readable(argv[_mwoptind+%d])) {\n", n);
		    fprintf(fa, "        char buffer[BUFSIZ];\n");
		    fprintf(fa, "        sprintf(buffer, \"cannot find '%%s' in default path\",  argv[_mwoptind+%d]);\n", n);
		    fprintf(fa, "        mwusage(buffer);\n");
		    fprintf(fa, "      }\n");
		    fprintf(fa, "    }\n");
		    fprintf(fa, "    else\n");
		    fprintf(fa, "      mwusage(\"missing '%s'\");\n", a->H_id);
		    n++;
		  }
		else 
		  /* OUTPUT MW2 optional argument */
		  {
		    fprintf(fa, "    /* output MW2 optional argument H_id=%s */\n",a->H_id);
		    fprintf(fa, "    if (_mwoptind+%d<argc) {\n", n);
		    fprintf(fa, "      if (!_mwis_writable(argv[_mwoptind+%d])) {\n", n);
		    fprintf(fa, "        char buffer[BUFSIZ];\n");
		    fprintf(fa, "        sprintf(buffer, \"cannot write '%%s'\", argv[_mwoptind+%d]);\n", n);
		    fprintf(fa, "        mwusage(buffer);\n");
		    fprintf(fa, "      }\n");
		    fprintf(fa, "    }\n");
		    fprintf(fa, "    else\n");
		    fprintf(fa, "      mwusage(\"missing '%s'\");\n", a->H_id);
		    n++; 
		  }
	      }
	    else if (ISARG_SCALAR(a))
	      /* scalar optional argument */
	      {
		if (ISARG_INPUT(a))
		  /* INPUT scalar argument */
		  {		    
		    if (ISARG_INTERVAL(a)) 
		      {
			char buffer[BUFSIZ];
			fprintf(fa, "    /* input scalar optional argument with interval checking H_id=%s */\n",a->H_id);
			sprintf(buffer, "argv[_mwoptind+%d]", n);
			fprintf(fa, "    if (_mwoptind+%d<argc) {\n", n);
			print_check_interval_arg(a, buffer);
			fprintf(fa, "    }\n");
			fprintf(fa, "    else\n");
			fprintf(fa, "      mwusage(\"missing '%s'\");\n", a->H_id);
		      }
		    else 
		      {
			fprintf(fa, "    /* input scalar optional argument H_id=%s */\n",a->H_id);
			fprintf(fa, "    if (_mwoptind+%d>=argc)\n", n);
			fprintf(fa, "      mwusage(\"missing '%s'\");\n", a->H_id);
		      }
		    n++;
		  }
	      }	    
	  }
     fprintf(fa, "  }\n");
    }


  /* Check variable arguments */
  if (H->NbVarArg>0)
    {
      fprintf(fa, "  /* Check io variable arguments */\n");
      fprintf(fa, "  if (_mwoptind+%d < argc) {\n", n);
      fprintf(fa, "    for (%si = _mwoptind+%d; %si<argc; %si++) {\n", MWPF, n, MWPF, MWPF);
      for (a=H->usage;a;a=a->next)
	if (ISARG_VARIABLE(a))
	  { 
	    if (ISARG_FILE(a))
	      {
		if (ISARG_INPUT(a))
		  /* INPUT MW2 variable argument */
		  {
		    fprintf(fa, "  /* input MW2 variable argument H_id=%s */\n",a->H_id);
		    fprintf(fa, "    if (!_mwis_readable(argv[%si])) {\n", MWPF);
		    fprintf(fa, "      char buffer[BUFSIZ];\n");
		    fprintf(fa, "      sprintf(buffer, \"cannot find '%%s' in default path\",  argv[%si]);\n", MWPF);
		    fprintf(fa, "      mwusage(buffer);\n");
		    fprintf(fa, "   }\n");
		  }
		else 
		  /* OUTPUT MW2 variable argument */
		  {
		    fprintf(fa, "  /* output MW2 variable argument H_id=%s */\n",a->H_id);
		    fprintf(fa, "    if (!_mwis_writable(argv[%si])) {\n", MWPF);
		    fprintf(fa, "      char buffer[BUFSIZ];\n");
		    fprintf(fa, "      sprintf(buffer, \"cannot write '%%s'\", argv[%si]);\n", MWPF);
		    fprintf(fa, "      mwusage(buffer);\n");
		    fprintf(fa, "   }\n");
		  }
	      }
	    else if (ISARG_SCALAR(a))
	      /* scalar variable argument */
	      {
		if (ISARG_INPUT(a))
		  /* INPUT scalar variable argument */
		  {		    
		    if (ISARG_INTERVAL(a)) 
		      {
			char buffer[BUFSIZ];
			fprintf(fa, "  /* input scalar variable argument with interval checking H_id=%s */\n",a->H_id);
			sprintf(buffer, "argv[%si]", MWPF);
			print_check_interval_arg(a, buffer);
		      }
		  }

	      }
	    fprintf(fa, "    }\n");
	    fprintf(fa, "  }\n");
	  }  
    }

  fprintf(fa,"\n/* ~~~ end of [print_check_io_arg] ~~~*/\n\n");
}


/*~~~  
  Generate code to read and set input variables.
  ~~~
*/

#ifdef __STDC__
void  print_read_input(void)
#else
void  print_read_input()
#endif

{
  Arg *a;
  char buffer[BUFSIZ];
  int n;

  fprintf(fa,"\n/* ~~~ [print_read_input] ~~~*/\n\n");

  /* Read input options */
  if (H->NbOption>0)
    {
      fprintf(fa, "  /* Read input options */\n");
      fprintf(fa, "  _mwoptind = 1;\n");
      fprintf(fa, "  while ((%sc=_mwgetopt(argc, argv, \"%s\")) != -1) {\n", MWPF, optb);
      fprintf(fa, "    extern char _mwoptlist[];\n");
      fprintf(fa, "    switch (%sc) {\n", MWPF);
      
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTION(a))
	  {
	    fprintf(fa, "      case '%c' :\n", a->Flag);
	    if (ISARG_FILE(a))
	      {
		strcpy(buffer,a->var->Stype);
		if (lowerstring(buffer)>1)
		  Error("Invalid usage for C_id=\"%s\" : unsupported composite MW2 type \"%s\"",	
			a->C_id,a->var->Stype);  	  					      
		if (ISARG_INPUT(a))
		  /* INPUT MW2 option */
		  fprintf(fa, "        _mwload_%s(_mwoptarg, %stype, %scomment, &%s);\n",buffer, MWPF, MWPF,a->C_id);
		else 
		  /* OUTPUT MW2 option */
		  fprintf(fa, "        %s = mw_new_%s();\n",a->C_id,buffer);		  
	      }
	    else if (ISARG_SCALARNOTFLAG(a))
	      /* scalar option */
	      {
		if (ISARG_INPUT(a))
		  /* INPUT scalar option */
		  {
		    SetScalarConvFunction(a,buffer);
		    fprintf(fa, "        %s%s = %s(_mwoptarg);\n", MWPU, a->C_id, buffer);
		    fprintf(fa, "        %s = &%s%s;\n", a->C_id, MWPU, a->C_id);
		  }
		else 
		  /* OUTPUT scalar option */
		  fprintf(fa, "        %s = &%s%s;\n", a->C_id, MWPU, a->C_id);
	      }
	    else if (ISARG_FLAGOPT(a))
	      /* flag option */
	      {
		fprintf(fa, "        %s%s = TRUE;\n", MWPU, a->C_id);
		fprintf(fa, "        %s = &%s%s;\n", a->C_id, MWPU, a->C_id);
	      }
	    else
	      Error("[print_read_input] Unexpected error for C_id=\"%s\" : option is not a FILE, SCALAR or FLAGOPT",a->C_id);

	    
	    fprintf(fa, "        strcat(_mwoptlist, \"%c\");\n", a->Flag);
	    fprintf(fa, "        break;\n");
	    
	  }
      /* Default : unknown option calls usage function */
      fprintf(fa, "      default :\n");
      fprintf(fa, "        break;\n");
      fprintf(fa, "    }\n");
      fprintf(fa, "  }\n\n");
    }
  
  n=0;
  /* Read needed arguments */
  if (H->NbNeededArg>0)
    {
      fprintf(fa, "  /* Read needed arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_NEEDED(a))
	  {
	    if (!ISARG_RETURNFUNC(a))
	      {
		if (ISARG_FILE(a))
		  {
		    strcpy(buffer,a->var->Stype);
		    if (lowerstring(buffer)>1)
		      Error("Invalid usage for C_id=\"%s\" : unsupported composite MW2 type \"%s\"",	
			    a->C_id,a->var->Stype);  	  					      
		    if (ISARG_INPUT(a))
		      /* INPUT MW2 needed argument */
		      fprintf(fa, "  _mwload_%s(argv[_mwoptind + %d], %stype, %scomment, &%s);\n",buffer,n,MWPF,MWPF,a->C_id);
		    else
		      /* OUTPUT MW2 needed argument */
		      fprintf(fa, "  %s = mw_new_%s();\n",a->C_id,buffer);		  
		    n++;
		  }
		else if (ISARG_SCALAR(a))
		  /* scalar needed argument */
		  {
		    if (ISARG_INPUT(a))
		      /* INPUT scalar argument */
		      {
			SetScalarConvFunction(a,buffer);
			fprintf(fa, "  %s = %s(argv[_mwoptind + %d]);\n",a->C_id,buffer,n);
			n++;
		      }
		    /* OUTPUT scalar argument : nothing to be done */
		  }
		else
		  Error("[print_read_input] Unexpected error for C_id=\"%s\" : needed argument is not a FILE nor a SCALAR",a->C_id);
	      }
	    else n++;
	  }
    }

  /* Read optional arguments */
  if (H->NbOptionArg>0)
    {
      fprintf(fa, "  /* Read optional arguments */\n");
      fprintf(fa, "  if (_mwoptind+%d < argc) {\n", n);
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTARG(a))
	  {	
	    if (ISARG_FILE(a))
	      {
		strcpy(buffer,a->var->Stype);
		if (lowerstring(buffer)>1)
		  Error("Invalid usage for C_id=\"%s\" : unsupported composite MW2 type \"%s\"",	
			a->C_id,a->var->Stype);  	  					      
		if (ISARG_INPUT(a))
		  /* INPUT MW2 optional argument */
		  {
		    fprintf(fa, "    _mwload_%s(argv[_mwoptind + %d], %stype, %scomment, &%s);\n",buffer,n,MWPF,MWPF,a->C_id);
		    n++;
		  }
		else
		  /* OUTPUT MW2 optional argument */
		  fprintf(fa, "    %s = mw_new_%s();\n",a->C_id,buffer);		  
	      }
	    else if (ISARG_SCALAR(a))
	      /* scalar optional argument */
	      {
		if (ISARG_INPUT(a))
		  /* INPUT optional argument */
		  {
		    SetScalarConvFunction(a,buffer);
		    fprintf(fa, "    %s%s = %s(argv[_mwoptind + %d]);\n",MWPU, a->C_id,buffer,n);
		    fprintf(fa, "    %s = &%s%s;\n", a->C_id, MWPU, a->C_id);
		    n++;
		  }
		else
		  /* OUTPUT optional argument */
		  fprintf(fa, "    %s = &%s%s;\n", a->C_id, MWPU, a->C_id);
	      }
	    else
	      Error("[print_read_input] Unexpected error for C_id=\"%s\" : optional argument is not a FILE nor a SCALAR",a->C_id);
	  }
      fprintf(fa, "  }\n");
    }

  /* Read variable arguments */
  if (H->NbVarArg>0)
    {
      fprintf(fa, "  /* Read variable arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_VARIABLE(a))
	  {
	    fprintf(fa, "  if (_mwoptind + %d >= argc) {\n",n);
	    fprintf(fa, "    %svar_flg = TRUE;\n", MWPF);
	    fprintf(fa, "  }\n");
	    fprintf(fa, "  for (%si = _mwoptind + %d; %si < argc || %svar_flg == TRUE; %si++) {\n",
		    MWPF, n, MWPF, MWPF, MWPF);
	    fprintf(fa, "if (_mwoptind + %d < argc) {\n", n);

	    if (ISARG_FILE(a))
	      {
		strcpy(buffer,a->var->Stype);
		if (lowerstring(buffer)>1)
		  Error("Invalid usage for C_id=\"%s\" : unsupported composite MW2 type \"%s\"",	
			a->C_id,a->var->Stype);  	  					      
		if (ISARG_INPUT(a))
		  /* INPUT MW2 variable argument */
		  fprintf(fa, "  _mwload_%s(argv[%si], %stype, %scomment, &%s);\n",buffer,MWPF,MWPF,MWPF,a->C_id);
		else
		  /* OUTPUT MW2 variable argument */
		  fprintf(fa, "  %s = mw_new_%s();\n",a->C_id,buffer);		  
	      }
	    else if (ISARG_SCALAR(a))
	      /* scalar variable argument */
	      {
		if (ISARG_INPUT(a))
		  /* INPUT scalar variable argument */
		  {
		    SetScalarConvFunction(a,buffer);
		    fprintf(fa, "        %s%s = %s(argv[%si]);\n", MWPU, a->C_id, buffer,MWPF);
		    fprintf(fa, "        %s = &%s%s;\n", a->C_id, MWPU, a->C_id);
		  }
		else
		  /* OUTPUT scalar variable argument */
		  fprintf(fa, "        %s = &%s%s;\n", a->C_id, MWPU, a->C_id);
	      }
	    else
	      Error("[print_read_input] Unexpected error for C_id=\"%s\" : variable argument is not a FILE nor a SCALAR",a->C_id);

	    fprintf(fa," }\n");
	    fprintf(fa," else {\n");
	    fprintf(fa, "  %s = NULL; \n",a->C_id);
	    fprintf(fa," }\n");

	  } /* end of if (ISARG_VARIABLE(a)) */
    } /* end of if (H->NbVarArg>0) */
  
  fprintf(fa,"\n/* ~~~ end of [print_read_input] ~~~*/\n\n");
}


/*~~~  
  Generate code to write output variables.
  ~~~
*/

#ifdef __STDC__
void  print_write_output(void)
#else
void  print_write_output()
#endif

{
  Arg *a;
  char buffer[BUFSIZ];
  int n;

  fprintf(fa,"\n/* ~~~ [print_write_output] ~~~*/\n\n");

  /* Write variable arguments */
  if (H->NbVarArg>0)
    {
      fprintf(fa, "  /* Write variable arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_VARIABLE(a))
	  {
	    if (ISARG_FILE(a))
	      {
		strcpy(buffer,a->var->Stype);
		if (lowerstring(buffer)>1)
		  Error("Invalid usage for C_id=\"%s\" : unsupported composite MW2 type \"%s\"",	
			a->C_id,a->var->Stype);  	  					      
		if (ISARG_OUTPUT(a))
		  /* OUTPUT MW2 variable argument */
		  {
		    fprintf(fa, "        if (%s) {\n", a->C_id);
		    fprintf(fa, "          if (_mwsave_%s(argv[%si], %stype, type_force, %scomment, %s) < 0)\n",
			    buffer, MWPF, MWPF, MWPF,a->C_id);
		    fprintf(fa, "            mwerror(FATAL, 1, \"cannot write %%s\\n\", argv[%si]);\n",MWPF);
		    fprintf(fa, "        }\n");
		  }
		/* INPUT MW2 variable argument : nothing to be done */
	      }
	    else if (ISARG_SCALAR(a))
	      /* scalar variable argument */
	      {
		if (ISARG_OUTPUT(a))
		  /* OUTPUT scalar variable argument */
		  {
		    /* OUTPUT with interval checking NOT IMPLEMENTED yet 
		       if (ISARG_INTERVAL(a)) print_check_interval_arg(a, "_mwoptarg");
		    */
		    /* generate print of variable */
		    fprintf(fa,"        printf(\"%s = \");\n",a->H_id);
		    fprintf(fa,"        ");
		    sprintf(buffer,"%s%s",MWPU,a->C_id);
		    print_value_scalar_arg(buffer,a);
		    fprintf(fa,"        printf(\"\\n\");\n");
		  }
	      }
	    fprintf(fa, "    %svar_flg = FALSE;\n", MWPF);
	    fprintf(fa, "  }\n");
	  } /* end of if (ISARG_VARIABLE(a)) */
    }/* end of if (H->NbVarArg>0) */
  
  /* Write output options */
  if (H->NbOption>0)
    {
      fprintf(fa, "  /* Write output options */\n");
      fprintf(fa, "  _mwoptind = 1;\n");
      fprintf(fa, "  while ((%sc=_mwgetopt(argc, argv, \"%s\")) != -1) {\n", MWPF, optb);
      fprintf(fa, "    switch (%sc) {\n", MWPF);
      
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTION(a))
	  {
	    fprintf(fa, "      case '%c' :\n", a->Flag);
	    if (ISARG_FILE(a))
	      {
		strcpy(buffer,a->var->Stype);
		if (lowerstring(buffer)>1)
		  Error("Invalid usage for C_id=\"%s\" : unsupported composite MW2 type \"%s\"",	
			a->C_id,a->var->Stype);  	  					      
		if (ISARG_OUTPUT(a))
		  /* OUTPUT MW2 option */
		  {
		    fprintf(fa, "        if (%s) {\n", a->C_id);
		    fprintf(fa, "          if (_mwsave_%s(_mwoptarg, %stype, type_force, %scomment, %s) < 0)\n",buffer, MWPF, MWPF,a->C_id);
		    fprintf(fa, "            mwerror(FATAL, 1, \"cannot write %%s\\n\", _mwoptarg) ;\n");
		    fprintf(fa, "        }\n");
		  }
	      }
	    else if (ISARG_SCALARNOTFLAG(a))
	      /* scalar option */
	      {
		if (ISARG_OUTPUT(a))
		  /* OUTPUT scalar option */
		  {
		    /* OUTPUT with interval checking NOT IMPLEMENTED yet 
		       if (ISARG_INTERVAL(a)) print_check_interval_arg(a, "_mwoptarg");
		    */
		    /* generate print of variable */
		    fprintf(fa,"        printf(\"%s = \");\n",a->H_id);
		    fprintf(fa,"        ");
		    sprintf(buffer,"%s%s",MWPU,a->C_id);
		    print_value_scalar_arg(buffer,a);
		    fprintf(fa,"        printf(\"\\n\");\n");
		  }
	      }
	    
	    fprintf(fa, "        break;\n");
	    
	  }
      /* Default : unknown option calls usage function */
      fprintf(fa, "      default :\n");
      fprintf(fa, "        break;\n");
      fprintf(fa, "    }\n");
      fprintf(fa, "  }\n\n");
    }

  n=0;
  /* Write needed arguments */
  if (H->NbNeededArg>0)
    {
      fprintf(fa, "  /* Write needed arguments */\n");
      for (a=H->usage;a;a=a->next)
	if (ISARG_NEEDED(a))
	  {
	    if (ISARG_FILE(a))
	      {
		if (ISARG_INPUT(a))
		  n++;
		else
		  {
		    /* OUTPUT MW2 needed argument */
		    strcpy(buffer,a->var->Stype);
		    if (lowerstring(buffer)>1)
		      Error("Invalid usage for C_id=\"%s\" : unsupported composite MW2 type \"%s\"",	
			    a->C_id,a->var->Stype);  	  					      

		    if (ISARG_RETURNFUNC(a))
		      fprintf(fa, "  if (_mwsave_%s(argv[_mwoptind+%d], %stype, type_force, %scomment, %s_ret) < 0)\n",
			      buffer, n, MWPF, MWPF,a->C_id);		      		    else
		      fprintf(fa, "  if (_mwsave_%s(argv[_mwoptind+%d], %stype, type_force, %scomment, %s) < 0)\n",
			      buffer, n, MWPF, MWPF,a->C_id);
		    fprintf(fa, "    mwerror(FATAL, 1, \"cannot write %%s\\n\",  argv[_mwoptind+%d]) ;\n",n);
		    n++;
		  }
	      }
	    else if (ISARG_SCALAR(a))
		  /* scalar needed argument */
		  {
		    if (ISARG_INPUT(a))
		      n++;
		    else
		      /* OUTPUT scalar argument */
		      {
			if (ISARG_RETURNFUNC(a))
			  sprintf(buffer,"%s_ret",a->C_id);
			else
			  sprintf(buffer,"%s",a->C_id);

			/* OUTPUT with interval checking NOT IMPLEMENTED yet 
			   if (ISARG_INTERVAL(a)) print_check_interval_arg(a, "_mwoptarg");
			*/
			/* generate print of variable */
			fprintf(fa,"  printf(\"%s = \");\n",a->H_id);
			fprintf(fa,"  ");
			print_value_scalar_arg(buffer,a);
			fprintf(fa,"  printf(\"\\n\");\n");			    
		      }
		  }
	    else
	      Error("[print_write_input] Unexpected error for C_id=\"%s\" : needed argument is not a FILE nor a SCALAR",a->C_id);
	  }
    }

  /* Write optional arguments */
  if (H->NbOptionArg>0)
    {
      fprintf(fa, "  /* Write optional arguments */\n");
      fprintf(fa, "  if (_mwoptind+%d < argc) {\n", n);
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTARG(a))
	  {	
	    if (ISARG_FILE(a))
	      {
		strcpy(buffer,a->var->Stype);
		if (lowerstring(buffer)>1)
		  Error("Invalid usage for C_id=\"%s\" : unsupported composite MW2 type \"%s\"",	
			a->C_id,a->var->Stype);  	  					      
		if (ISARG_OUTPUT(a))
		  /* OUTPUT MW2 optional argument */
		  {
		    fprintf(fa, "        if (%s) {\n", a->C_id);
		    fprintf(fa, "          if (_mwsave_%s(argv[_mwoptind + %d], %stype, type_force, %scomment, %s) < 0)\n",
			    buffer, n, MWPF, MWPF,a->C_id);
		    fprintf(fa, "            mwerror(FATAL, 1, \"cannot write %%s\\n\", argv[_mwoptind + %d]) ;\n",n);
		    fprintf(fa, "        }\n");
		  }
		n++;
	      }
	    else if (ISARG_SCALAR(a))
	      /* scalar optional argument */
	      {
		if (ISARG_OUTPUT(a))
		  /* OUTPUT scalar optional argument */
		  {
		    /* OUTPUT with interval checking NOT IMPLEMENTED yet 
		       if (ISARG_INTERVAL(a)) print_check_interval_arg(a, "_mwoptarg");
		    */
		    /* generate print of variable */
		    fprintf(fa,"        printf(\"%s = \");\n",a->H_id);
		    fprintf(fa,"        ");
		    sprintf(buffer,"%s%s",MWPU,a->C_id);
		    print_value_scalar_arg(buffer,a);
		    fprintf(fa,"        printf(\"\\n\");\n");
		  }
		else n++;
	      }
	  }
      fprintf(fa, "  }\n");
    }

  fprintf(fa,"\n/* ~~~ end of [print_write_output] ~~~*/\n\n");
}

/*~~~  
  Generate code to read and set input variables.
  ~~~
*/

#ifdef __STDC__
void  print_main_function_call(void)
#else
void  print_main_function_call()
#endif

{
  Arg *a;
  Variable *p;
  char Address;

  fprintf(fa,"\n/* ~~~ [print_main_function_call] ~~~*/\n\n");

  if (H->retmod)
    /* The module uses the return function via the argument pointed by H->retmod */
    fprintf(fa, "  %s_ret =  (%s) %s (", H->retmod->C_id, H->retmod->var->Ftype,H->Name);
  else
    /* The module does not use the return function */
    fprintf(fa, "  %s (", H->Name);

  for (p=C->mfunc->param; p; p=p->next)
    {
      a=p->arg;
      Address=' ';
      if ((a->var->DeclType==DT_Stype)&&(ISARG_EXPLICITPOINTER(a)))
	/* 
	   Using DeclType field, try to automatically manage all cases
	   where one as to set Address='&' : this is when the variable
	   was declared in the A-file using its Stype while, in the
	   module's main function, the variable is an explicit pointer.
	   For the list of cases, see genmain lines 496-504.
	*/
	Address='&';
      if (p!=C->mfunc->param) fprintf(fa,",");
      fprintf(fa, "%c%s",Address,p->Name);
    }
  fprintf(fa,");");  

 fprintf(fa,"\n/* ~~~ end of [print_main_function_call] ~~~*/\n\n");

}



/*~~~ write usage function and fill <usagebuf> global variable ~~~
*/

#define ADDUSAGE1(a) fprintf(fa, a); if ((strlen(usagebuf)+strlen(a))>=STRSIZE) Error("[writeusage] Buffer overflow for usage (increase STRSIZE)"); strcat(usagebuf, a)

#define ADDUSAGE2(a,b) fprintf(fa, a,b);  sprintf(buffer,a,b); if ((strlen(usagebuf)+strlen(buffer))>=STRSIZE) Error("[writeusage] Buffer overflow for usage (increase STRSIZE)"); strcat(usagebuf, buffer)


#ifdef __STDC__
void writeusage(void)
#else
void writeusage()
#endif

{
  char Vers[TREESTRSIZE], Auth[TREESTRSIZE], Func[TREESTRSIZE], Lab[TREESTRSIZE];
  char buffer[STRSIZE];
  Arg *a;

  fprintf(fa,"\n/* ~~~ [writeusage] ~~~*/\n\n");


  fprintf(fa,"#ifdef __STDC__\n");
  fprintf(fa, "int usage_%s(char *msg)\n", H->Name);
  fprintf(fa,"#else\n");
  fprintf(fa, "int usage_%s(msg)\n", H->Name);
  fprintf(fa, "char *msg;\n");
  fprintf(fa,"#endif\n");
  fprintf(fa, "{\n");
  fprintf(fa, "  extern char _mwdefoptbuf[];\n");
  fprintf(fa, "  extern int help_flg;\n");
  strcpy(Auth,getprintfstring(H->Author));
  strcpy(Vers,getprintfstring(H->Version));
  strcpy(Func,getprintfstring(H->Function));
  strcpy(Lab,getprintfstring(H->Labo));

  module_presentation(H->Name, Vers, Auth, Func, Lab);
  fprintf(fa, "  if (msg != NULL)\n");
  fprintf(fa, "    fprintf(stderr, \"error : %%s\\n\\n\", msg) ;\n");
  
  /* Build usage line */
  fprintf(fa, "  fprintf(stderr, \"usage : %%s%%s");
  sprintf(usagebuf, "usage : %s",H->Name);
  
  /* Options */
  if (H->NbOption>0)
    for (a=H->usage;a;a=a->next)
      if (ISARG_OPTION(a))
	{
	  ADDUSAGE2(" [-%c", a->Flag);
	  if (a->H_id[0]!='\0') 
	    {ADDUSAGE2(" %s]", a->H_id);}
	  else 
	    {ADDUSAGE1("]");}
        }
  
  /* Needed arg */
  if (H->NbNeededArg>0)
    for (a=H->usage;a;a=a->next)
      if (ISARG_NEEDED(a))
	{
	  if (!(ISARG_SCALAR(a) && ISARG_OUTPUT(a)))
	    {ADDUSAGE2(" %s", a->H_id);}
	  else
	    /* In case of a scalar output needed argument, something (as .) has to be
	       given in the command line to avoid argument shifting.
	    */
	    {ADDUSAGE1(" .");}
	}
  
  /* Optional argument */
  if (H->NbOptionArg>0)
    {
      /* BEWARE : see if it would be useful to check if the following test
	 is never verified for all optional arg, in order not to write []. 
      */
      fprintf(fa, " [");
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTARG(a))
	  {
	    if (!(ISARG_SCALAR(a) && ISARG_OUTPUT(a)))
	      {ADDUSAGE2(" %s", a->H_id);}
	  }
      ADDUSAGE1(" ]");
    }

  /* Variable arguments */
  if (H->NbVarArg>0)
    for (a=H->usage;a;a=a->next)
      if (ISARG_VARIABLE(a))
	{
	  if (!(ISARG_SCALAR(a) && ISARG_OUTPUT(a)))
	    {ADDUSAGE1(" [...]");}
	}
  
  fprintf(fa, "\\n\\n\", mwname, (help_flg) ? _mwdefoptbuf : \"\");\n");
  strcat(usagebuf, "\\n");

  /* Build lines describing arguments with comments */

  /* Options */
  if (H->NbOption>0)
    for (a=H->usage;a;a=a->next)
      if (ISARG_OPTION(a))
	{
	  fprintf(fa, "  fprintf(stderr, \"");
	  ADDUSAGE2("\\t-%c", a->Flag);
	  if (a->H_id[0]!='\0') {ADDUSAGE2(" %s", a->H_id);}
	  print_interval_and_defval(a);
	  if (ISARG_SCALAR(a) && ISARG_OUTPUT(a))
	    {ADDUSAGE1(" screen output");}
          ADDUSAGE2(" :\\t%s\\n", getprintfstring(a->Cmt));
          fprintf(fa,"\");\n");
	}

  /* Needed arg */
  if (H->NbNeededArg>0)
    for (a=H->usage;a;a=a->next)
      if (ISARG_NEEDED(a))
	{
	  fprintf(fa, "  fprintf(stderr, \"");
	  if (!(ISARG_SCALAR(a) && ISARG_OUTPUT(a)))
	    {
	      ADDUSAGE2("\\t%s",a->H_id);
	      print_interval_and_defval(a);
	      ADDUSAGE2(" :\\t%s\\n", getprintfstring(a->Cmt));
	    }
	  else
	    {ADDUSAGE2("\\t. (screen output) :\\t%s\\n", getprintfstring(a->Cmt));}
    	  fprintf(fa,"\");\n");
	}  

  /* Optional arguments */
  if (H->NbOptionArg>0)
    {
      for (a=H->usage;a;a=a->next)
	if (ISARG_OPTARG(a))
	  {
	    fprintf(fa, "  fprintf(stderr, \"");
	    if (!(ISARG_SCALAR(a) && ISARG_OUTPUT(a)))
	      {
		ADDUSAGE2("\\t%s",a->H_id);
		print_interval_and_defval(a);
                ADDUSAGE2(" :\\t%s\\n", getprintfstring(a->Cmt));
	      }
	    else
	      {ADDUSAGE2("\\t. (screen output) :\\t%s\\n", getprintfstring(a->Cmt));}
       	    fprintf(fa,"\");\n");
	  }
    }  
  
  /* Variable arg */
  if (H->NbVarArg>0)
    for (a=H->usage;a;a=a->next)
      if (ISARG_VARIABLE(a))
	{
	  fprintf(fa, "  fprintf(stderr, \"");
	  if (!(ISARG_SCALAR(a) && ISARG_OUTPUT(a)))
	    {ADDUSAGE2("\\t... :\\t%s\\n",getprintfstring(a->Cmt));}
	  else
	    {ADDUSAGE2("\\tscreen output... :\\t%s\\n", getprintfstring(a->Cmt));}
          fprintf(fa,"\");\n");
	}
  
  
  fprintf(fa, "  mwexit(1);\n");
  fprintf(fa, "}\n");

 fprintf(fa,"\n/* ~~~ end of [writeusage] ~~~*/\n\n");
}


/*~~~ write body of main function ~~~
*/

#ifdef __STDC__
void writebody(void)
#else
void writebody()
#endif

{
  Arg *a;
  
  fprintf(fa,"\n/* ~~~ [writebody] Body of main function ~~~*/\n\n");

  fprintf(fa, "  strcpy(%stype, \"?\");\n", MWPF);
  fprintf(fa, "  %scomment[0] = '\\0';\n\n", MWPF);

  if (H->NbVarArg > 0)
    fprintf(fa, "  %svar_flg = FALSE;\n", MWPF);
  
  /* Call to function which do MegaWave default options actions */
  fprintf(fa, "  MegaWaveDefOpt(\"%s\");\n\n",H->Version);

  /* Generate code to verify that input files are readable, output
     files are writable and numerical values are in range */
  print_check_io_arg();

  /* Generate code to read and set input variables */
  print_read_input();

  /* Generate call to main function */
  print_main_function_call();

  /* Generate code to write output variables */
  print_write_output();

  /* Exit from main function */
  fprintf(fa, "\n  mwexit(0);\n");
  fprintf(fa, "}\n\n");

  fprintf(fa,"\n/* ~~~ end of [writebody] ~~~*/\n\n");
} 


/*~~~ main entry : generate A-file ~~~
*/

#ifdef __STDC__
void genAfile(void)
#else
void genAfile()
#endif
{
  if ((fa = fopen(Afile, "w")) == NULL) 
    Error("Cannot open A-file '%s' for writing",Afile);    

  writeAheader();
  writegendecl();
  writeargdecl();
  writebody();

  writeusage();

  fclose(fa);
}
