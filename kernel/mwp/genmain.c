/*~~~~~~~~~~~  This file is part of the MegaWave2 preprocessor ~~~~~~~~~~~~~~~~
MegaWave2 is a "soft-publication" for the scientific community. It has
been developed for research purposes and it comes without any warranty.
The last version is available at http://www.cmla.ens-cachan.fr/Cmla/Megawave
CMLA, Ecole Normale Superieure de Cachan, 61 av. du President Wilson,
      94235 Cachan cedex, France. Email: megawave@cmla.ens-cachan.fr 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* Generation of C code - main function 
   V 2.04
   Original version : Sylvain Parrino 
   Main modifications :
   21/3/94 by Jacques Froment : statements never reached corrected.
   22/3/94 by JF : Name of allocation functions corrected.
   29/9/98 by JF : Function print_ndecl() (to initialize variables) added.
   20/06/00 by JF : - Function make_printable() replaces noquote() and now used
                      to compute strings Vers[],Fonc[],Labo[].
                    - Added <stdlib.h> in the generated main file.
   06/10/00 & 13/10/00 & 07/06/01 by JF : changes related to screen output.
   11/08/01 by JF : change in the "MegaWave function call" generation (no '&' for 
                    scalar optional output variables). Warning is issued in case
		    of new code generation.
*/

#include <stdio.h>
#include <stdlib.h>

#include "bintree.h"
#include "symbol.h"
#include "token.h"
#include "mwarg.h"
#include "data_io.h"
#include "omwarg.h"
#include "y.tab.h"
#include "io.h"
#define GENMAIN_DEC
#include "genmain.h"


/* Convert string line to lowercase
*/
#ifdef __STDC__
void Lowerline(char *line)
#else
void Lowerline(line) 
char *line;
#endif
{
  for (; *line != '\0'; line++)
    if (isupper(*line))
      *line = tolower(*line);
}


#ifdef __STDC__
void genmain(FILE *fd)
#else
genmain(fd)
FILE *fd;
#endif
{
  Symbol *mws;
  char LowName[BUFSIZ];

#ifdef DEBUG
  PRDBG("genmain()\n");
#endif
  if ((mws = LOOKUP(mwname->val.text)) != NULL) {
    char Vers[BUFSIZ], Auth[BUFSIZ], Fonc[BUFSIZ], Labo[BUFSIZ];
    int l,ind;
    Symbol *s;
    Cell *c;
    Node *mwfunc, *idlist, /**declist,*/ *n;
    extern int errorcnt;

    /* To avoid rename of MegaWave function */
    SET_RENAME(mws, GET_SNAME(mws));

    /* Initialisation of pointers to specific trees of MegaWave function */
    mwfunc = (Node *)GET_SDESC(mws);
    for (n = mwfunc->left->left; n->name != FUNCDECL; n=n->left);
    idlist = n->right;
    /*declist = mwfunc->right->left->right;*/
   
    /* Verify if one of vararglist and optarglist exist exclusively */
    if (GET_NUMBER(vararglist) != 0 && GET_NUMBER(optarglist) != 0)
      error2(NULL, 0, "You can't have variable argument and optional argument\n");

    /* Verify that vararglist contains only zero or one cell */
    if (GET_NUMBER(vararglist) > 1)
      error2(NULL, 0, "too variable argument (...) in usage : only 0 or 1\n");

    /* First generation of C code : interface with UNIX and mwp is function
       which name depend on module. */
    fprintf(fd,"/* This file has been automatically generated by MegaWave2 */\n");
    fprintf(fd, "#include <stdio.h>\n");

    /* Added by JF 20/06/2000 : stdlib is needed by Linux to get
       a correct behavior of the atof() function, at least without 
       a cast to a float !
    */
    fprintf(fd,"#ifdef __STDC__\n");
    fprintf(fd,"#include <stdlib.h>\n");
    fprintf(fd,"#endif\n");

    /* Suppressed by JF 21/09/2000 : useless since mw.h contains all of
       I/O include files.
      print_io_include(fd);
    */

    fprintf(fd, "#include \"mw.h\"\n\n");
    fprintf(fd, "#include \"mwi.h\"\n\n");
    fprintf(fd, "#define TRUE  1\n");
    fprintf(fd, "#define FALSE 0\n\n");
    fprintf(fd, "_%s(argc, argv)\n", mws->name);
    fprintf(fd, "int argc;\n");
    fprintf(fd, "char *argv[];\n");
    fprintf(fd, "{\n");

    /* Added by JF 20/06/2000, in conjunction with stdlib */ 
    fprintf(fd,"#ifndef __STDC__\n");    
    fprintf(fd, "  int atoi();\n");
    fprintf(fd, "  long atol();\n");
    fprintf(fd, "  double atof();\n");
    fprintf(fd,"#endif\n");

    fprintf(fd, "  int %sc;\n", MW_PFX2);
    fprintf(fd, "  char *%sname;\n", MW_PFX2);
    fprintf(fd, "  int %si;\n", MW_PFX2);
    fprintf(fd, "  char %stype[mw_ftype_size+1];\n", MW_PFX2);
    fprintf(fd, "  char %scomment[BUFSIZ];\n", MW_PFX2);
    if (GET_NUMBER(vararglist) != 0)
      fprintf(fd, "  int %svar_flg;\n", MW_PFX2);
    fprintf(fd, "  extern char type_force[];\n");
    fprintf(fd, "  extern char *_mwoptarg;\n");
    fprintf(fd, "  extern int _mwoptind;\n");
    print_io_function(fd);

    /* Generation of C code to declarate all parameters to be passed to
       MegaWave function.
       Parameters are also added in special list called mwarglist : it will be
       used to verify if all parameters are describe in usage statement */
    fprintf(fd, "  /* Declarations */\n");
    /* Variables for optionals arguments */
    fprintf(fd, "/* Variables for optionals arguments */\n");
    popt = optb;
    for (c = GET_FIRST(optionlist); c != NULL; c = GET_NEXT(c)) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(c);
      *popt++ = opt->d.o.o;
      if (opt->texname != NULL)
        *popt++ = ':';
      print_optdecl(fd, opt);
    }
    *popt = '\0';
    /* Variables for needed arguments  */
    fprintf(fd, "/* Variables for needed arguments  */\n");
    for (c = GET_FIRST(neededarglist); c != NULL; c = GET_NEXT(c)) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(c);
      if (opt == mwfuncret) {
        /*char buffer[BUFSIZ];*/
        fprintf(fd, "  "); printnode(fd, mws->type);
        /*sprintf(buffer, "%s_ret", mws->name);
        printaccess(fd, opt->d.a.rw, mws->access, buffer);
        fprintf(fd, ";\n");*/
        fprintf(fd, "%s_ret ;\n", mws->name);
        fprintf(fd, "  extern "); printnode(fd, mws->type);
        printaccess(fd, opt->d.a.rw, mws->access, mws->name);
        fprintf(fd, "() ;\n");
      }
      else 
	{
	  fprintf(fd, "  "); 
	  printnode(fd, opt->type);
	  printaccess(fd, opt->d.a.rw, opt->access, opt->name);
	  print_ndecl(fd,opt);  /* Modified by jf 29/9/98 : see omwarg.c */
	}
    }
    /* Variables for variables arguments  */
    fprintf(fd, "/* Variables for variables arguments  */\n");
    for (c = GET_FIRST(vararglist); c != NULL; c = GET_NEXT(c)) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(c);
      print_optdecl(fd, opt);
    }
    /* Variables for optionals arguments  */
    fprintf(fd, "/* Variables for optionals arguments  */\n");
    for (c = GET_FIRST(optarglist); c != NULL; c = GET_NEXT(c)) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(c);
      print_optdecl(fd, opt);
    }
    /* Variables for not used arguments  */
    fprintf(fd, "/* Variables for not used arguments  */\n");
    for (c = GET_FIRST(notusedarglist); c != NULL; c = GET_NEXT(c)) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(c);
      fprintf(fd, "  "); 
      printnode(fd, opt->type);
      printaccess(fd, opt->d.a.rw, opt->access, opt->name);
      print_ndecl(fd,opt);  /* Modified by jf 29/9/98 : see omwarg.c */
    }
    fprintf(fd, "\n");
    fprintf(fd, "  strcpy(%stype, \"?\") ;\n", MW_PFX2);
    fprintf(fd, "  %scomment[0] = '\\0' ;\n\n", MW_PFX2);
    if (GET_NUMBER(vararglist) != 0)
      fprintf(fd, "  %svar_flg = FALSE ;\n", MW_PFX2);

    /* Call to function which do MegaWave default options actions */
    fprintf(fd, "\n  MegaWaveDefOpt(%s);\n\n",mwversion->val.text);

    /* Generate code for verify that input files are readable, output
       file are writable and numericals values are in range */
    print_verify_io_arg(fd);

    /* Generate loop for examine command options for input */
    if (GET_NUMBER(optionlist) != 0) {
      fprintf(fd, "  /* Options for input */\n");
      fprintf(fd, "  _mwoptind = 1 ;\n");
      fprintf(fd, "  while ((%sc=_mwgetopt(argc, argv, \"%s\")) != -1) {\n", 
                                                     MW_PFX2, optb);
      fprintf(fd, "    extern char _mwoptlist[];\n");
      fprintf(fd, "    switch (%sc) {\n", MW_PFX2);

      for (c = GET_FIRST(optionlist); c != NULL; c = GET_NEXT(c)) {
        Mwarg *opt;
        opt = (Mwarg *)GET_ELT(c);
        fprintf(fd, "      case '%c' :\n", opt->d.o.o);
        switch(opt->d.o.d.t) {
          case FILEARG :
            if (opt->d.o.d.rw == READ) {
              fprintf(fd, "        (void)%s(_mwoptarg, %stype, %scomment, &%s) ;\n",
                          opt->iodesc->function, MW_PFX2, MW_PFX2, opt->name);
            }
            else if (opt->d.o.d.rw == WRITE) {
		strcpy(LowName,opt->type->val.text);
		Lowerline(LowName);
		fprintf(fd, "        %s =  mw_new_%s() ;\n",opt->name,LowName);
	    }
            break;
          case SCALARARG :
            if (opt->d.o.d.rw == READ) {
              fprintf(fd, "        %s%s = %s(_mwoptarg) ;\n", MW_PFX, opt->name, opt->iodesc->function);
              fprintf(fd, "        %s = &%s%s ;\n", opt->name, MW_PFX, opt->name);
            }
            else if (opt->d.o.d.rw == WRITE)
              fprintf(fd, "        %s = &%s%s ;\n", opt->name, MW_PFX, opt->name);
            break;
          case FLAGARG :
#ifdef DEBUG
            PRDBG("genmain : FLAGARG\n");
#endif
            fprintf(fd, "        %s%s = TRUE ;\n", MW_PFX, opt->name);
            fprintf(fd, "        %s = &%s%s ;\n", opt->name, MW_PFX, opt->name);
            break;
          default :
#ifdef DEBUG
            PRDBG("genmain : %d : unknown type of argument\n", opt->d.o.d.t);
#endif
            fatal_error("%d : unknown type of argument\n", opt->d.o.d.t);

            break;
        }
        fprintf(fd, "        strcat(_mwoptlist, \"%c\");\n", opt->d.o.o);
        fprintf(fd, "        break ;\n");
      }
      /* Default : unknown option call usage function */
      fprintf(fd, "      default :\n");
      fprintf(fd, "        break;\n");
      fprintf(fd, "    }\n");
      fprintf(fd, "  }\n\n");
    }

    /* Generate code for read file */
    fprintf(fd, "  /* needed arg for input */\n");
    for (c=GET_FIRST(neededarglist), ind = 0; c!=NULL; c=GET_NEXT(c)) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(c);
      if (opt != mwfuncret) {
        switch(opt->d.a.t) {
          case FILEARG :
            if (opt->d.a.rw == READ) {
#ifdef DEBUG
              PRDBG("genmain : neededarglist, FILEARG, read, %s\n", opt->name);
#endif
              fprintf(fd, "  (void)%s(argv[_mwoptind + %d], %stype, %scomment, &%s) ;\n",
                       opt->iodesc->function, ind, MW_PFX2, MW_PFX2, opt->name);
              ind++;
            }
            else if (opt->d.a.rw == WRITE) {
              if (!IS_PTR(opt->access)) {
                strcpy(LowName,opt->type->val.text);
                Lowerline(LowName);
                fprintf(fd, "        %s =  mw_new_%s() ;\n",opt->name,LowName);
              }
              ind++;
            }
            break;
          case SCALARARG :
            if (opt->d.a.rw == READ) {
#ifdef DEBUG
              PRDBG("genmain : neededarglist, SCALARARG, read, %s\n", opt->name);
#endif
              fprintf(fd, "  %s = %s(argv[_mwoptind + %d]) ;\n", opt->name,
                                                     opt->iodesc->function, ind);
              ind++;
            }
            else if (opt->d.a.rw == WRITE) {
	      fprintf(fd, "/* opt->name=%s ind=%d */\n",opt->name,ind);
            }
            break;
          case FLAGARG :
#ifdef DEBUG
            PRDBG("genmain : FLAGARG\n");
#endif
            error("'%s' : option not allowed in needed argument list\n",
                              opt->name);
            break;
          default :
#ifdef DEBUG
            PRDBG("genmain : %d : unknown type of argument\n", opt->d.a.t);
#endif
            fatal_error("%d : unknown type of argument\n", opt->d.a.t);

            break;
        }
      }
      else
        ind++;
    }

    if (GET_NUMBER(optarglist) != 0) {
      fprintf(fd, "  /* optional arg for input */\n");
      fprintf(fd, "  if (_mwoptind+%d < argc) {\n", ind);
      for (c=GET_FIRST(optarglist),n=0; c!=NULL; c=GET_NEXT(c)) {
        Mwarg *opt;
        opt = (Mwarg *)GET_ELT(c);
#ifdef DEBUG
        PRDBG("genmain : optarglist, read, %s\n", opt->name);
#endif
        switch(opt->d.a.t) {
          case FILEARG :
            if (opt->d.a.rw == READ) {
              fprintf(fd, "    (void)%s(argv[_mwoptind + %d], %stype, %scomment, &%s) ;\n",
                      opt->iodesc->function, ind, MW_PFX2, MW_PFX2, opt->name);
              ind++;
            }
            else if (opt->d.a.rw == WRITE) {
		strcpy(LowName,opt->type->val.text);
		Lowerline(LowName);
		fprintf(fd, "        %s =  mw_new_%s() ;\n",opt->name,LowName);
	    }
            break;
          case SCALARARG :
            if (opt->d.a.rw == READ) {
              fprintf(fd, "    %s%s = %s(argv[_mwoptind + %d]) ;\n", MW_PFX, 
                        opt->name, opt->iodesc->function, ind);
              fprintf(fd, "    %s = &%s%s ;\n", opt->name, MW_PFX, opt->name);
              ind++;
            }
            else if (opt->d.a.rw == WRITE)
              fprintf(fd, "    %s = &%s%s ;\n", opt->name, MW_PFX, opt->name);
            break;
          case FLAGARG :
#ifdef DEBUG
            PRDBG("genmain : FLAGARG\n");
#endif
            error("'%s' : option not allowed in optional argument list\n",
                                opt->name);
            break;
          default :
#ifdef DEBUG
            PRDBG("genmain : %d : unknown type of argument\n", opt->d.a.t);
#endif
            fatal_error("%d : unknown type of argument\n", opt->d.a.t);
            break;
        }
      }
      fprintf(fd, "  }\n");
    }


    fprintf(fd, "  /* variable arg for input */\n");
    if (GET_NUMBER(vararglist) != 0) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(GET_FIRST(vararglist));
#ifdef DEBUG
      PRDBG("genmain : vararglist, read, %s\n", opt->name);
#endif
      fprintf(fd, "  if (_mwoptind + %d >= argc) {\n", ind);
      fprintf(fd, "    %svar_flg = TRUE;\n", MW_PFX2);
      fprintf(fd, "  }\n");
      fprintf(fd, "  for (%si = _mwoptind + %d; %si < argc || %svar_flg == TRUE; %si++) {\n",
                      MW_PFX2, ind, MW_PFX2, MW_PFX2, MW_PFX2);
      fprintf(fd, "if (_mwoptind + %d < argc) {\n", ind);
      switch(opt->d.a.t) {
        case FILEARG :
          if (opt->d.a.rw == READ)
            fprintf(fd, "    (void)%s(argv[%si], %stype, %scomment, &%s) ;\n",
                     opt->iodesc->function, MW_PFX2, MW_PFX2, MW_PFX2, opt->name);
          else if (opt->d.a.rw == WRITE) {
	      strcpy(LowName,opt->type->val.text);
	      Lowerline(LowName);
              fprintf(fd, "        %s =  mw_new_%s() ;\n",opt->name,LowName);
	  }
          break;
        case SCALARARG :
          if (opt->d.a.rw == READ) {
            fprintf(fd, "    %s%s = %s(argv[%si]) ;\n", MW_PFX, opt->name,
                                             opt->iodesc->function, MW_PFX2);
            fprintf(fd, "    %s = &%s%s ;\n", opt->name, MW_PFX, opt->name);
          }
          else if (opt->d.a.rw == WRITE)
            fprintf(fd, "    %s = &%s%s ;\n", opt->name, MW_PFX, opt->name);
          break;
        case FLAGARG :
#ifdef DEBUG
          PRDBG("genmain : FLAGARG\n");
#endif
          error("'%s' : option not allowed in variable argument list\n",
                              opt->name);
          break;
        default :
#ifdef DEBUG
          PRDBG("genmain : %d : unknown type of argument\n", opt->d.a.t);
#endif
          fatal_error("%d : unknown type of argument\n", opt->d.a.t);

          break;
      }
      fprintf(fd," }\n");
      fprintf(fd," else {\n");
      switch(opt->d.a.t) {
      case FILEARG:
      case SCALARARG:
	fprintf(fd, "  %s = NULL; \n",opt->name);
	break;
      case FLAGARG:
#ifdef DEBUG
	PRDBG("genmain : FLAGARG\n");
#endif
	error("'%s' : option not allowed in the variable argument list\n",
	      opt->name);
	break;
      default:
#ifdef DEBUG
	PRDBG("genmain : %d : unknown type of argument\n",opt->d.a.t);
#endif
	fatal_error("%d : unknown type of argument\n",opt->d.a.t);

	break;
      }
      fprintf(fd," }\n");
    }

    /* MegaWave function call */
    fprintf(fd, "  /* MegaWave function call */\n");
    if (idlist != NULL) 
      {
	Symbol *s;
	Mwarg *e;
	if (mwfuncret != NULL)
	  fprintf(fd, "  %s_ret =  %s (", mwfuncret->name, mws->name);
	else
	  fprintf(fd, "  %s (", mws->name);
	n = idlist;
	if (n->name != NAME) 
	  {
	    for (; n->name == ','; n = n->right) 
	      {
		Node *id;
		id = n->left;
		if ((s = LOOKUP(id->val.text)) != NULL) 
		  {
		    if ((e = (Mwarg *)GET_SFATHER(s)) != NULL) 
		      {
			char orgtest,newtest;

			/* Original test */
			if ((e->t==OPTION && ((e->d.o.d.t==FILEARG && e->access==NULL)||e->d.o.d.rw==READ)) ||
			    (e->t!=OPTION && ((e->d.a.t==FILEARG && e->access==NULL) ||	
					      (e->d.a.rw!=WRITE || (e->t==NEEDEDARG && e->d.a.rw==WRITE &&
								    !IS_PTR(e->access))))))
			  orgtest=' ';
			else
			  orgtest='&';
			
			/* New test (modified by JF 11/08/01) : no '&' for scalar optional output variables */
			if ((e->t==OPTION && ((e->d.o.d.t==FILEARG && e->access==NULL)||e->d.o.d.rw==READ
					      ||e->d.o.d.t!=FILEARG))
			    ||
			    ((e->t!=OPTION && ((e->d.a.t==FILEARG && e->access==NULL) ||	
					      (e->d.a.rw!=WRITE || (e->t==NEEDEDARG && e->d.a.rw==WRITE &&
								    !IS_PTR(e->access)))))))
			  newtest=' ';
			else
			  newtest='&';
			
			fprintf(fd, "%c%s, ",newtest,(char *)id->val.text);
			
			  /* Warning if the new test generated a different code */
			if (newtest != orgtest)
			  {
			    printf("\tgenmain warning : new function call (old '%c%s', new '%c%s')\n",
				   orgtest,(char *)id->val.text,newtest,(char *)id->val.text);
			    printf("\targ type ");			    
			    if (e->t==OPTION) 
			      {
				printf("\tOPTION"); 
				if (e->d.o.d.t==FILEARG) printf("\tFILEARG"); else printf("\tNOT FILEARG");
				if (e->access==NULL) printf("\taccess NULL"); else printf("\taccess NOT NULL");
				if (e->d.o.d.rw==READ) printf("\tREAD");
				if (e->d.o.d.rw==WRITE) printf("\tWRITE");			    
			      }
			    else printf("\tNOT OPTION");
			    printf("\n");
			  }
		      }
		    else
		      error("'%s' : not declared in usage statement\n", id->val.text);
		  }
		else
		  error("'%s' : is not declared\n", n->val.text);
	      }
	  }
	if ((s = LOOKUP(n->val.text)) != NULL) 
	  {
	    if ((e = (Mwarg *)GET_SFATHER(s)) != NULL) 
	      {
		if ((e->t==OPTION && 
		     ((e->d.o.d.t==FILEARG&&e->access==NULL) || e->d.o.d.rw==READ)) ||
		    (e->t!=OPTION && ((e->d.a.t==FILEARG && e->access==NULL) ||
				      (e->d.a.rw!=WRITE || (e->t==NEEDEDARG && e->d.a.rw==WRITE &&
							    !IS_PTR(e->access))))))
		  fprintf(fd, "%s) ;\n", (char *)e->name);
		else
		  fprintf(fd, "&%s) ;\n", (char *)e->name);
	      }
	    else
	      error("'%s' : not declared in usage statement\n", n->val.text);
	  }
	else
	  error("'%s' : is not declared\n",n->val.text );
      }
    else 
      {
	if (mwfuncret != NULL) 
	  {
	    fprintf(fd, "  %s_ret =  %s () ;\n", mwfuncret->name, mws->name);
	  }
	else
	  error("MegaWave function must return datas\n");
      }
    
    fprintf(fd, "  /* Variable argument for output */\n");
    if (GET_NUMBER(vararglist) != 0) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(GET_FIRST(vararglist));
#ifdef DEBUG
      PRDBG("genmain : vararglist, write, %s\n", opt->name);
#endif
      switch(opt->d.a.t) {
        case FILEARG :
          if (opt->d.a.rw == WRITE) {
            fprintf(fd, "  if (%s != NULL) {\n", opt->name);
            fprintf(fd, "    if (%s(argv[%si], %stype, type_force, %scomment, %s) < 0)\n",
                    opt->iodesc->function, MW_PFX2, MW_PFX2, MW_PFX2, opt->name);
            fprintf(fd, "      mwerror(FATAL, 1, \"cannot write %%s\\n\", argv[%si]) ;\n", MW_PFX2);
            fprintf(fd, "  }\n");
          }
          break;
        case SCALARARG :
          if (opt->d.a.rw == WRITE) {
            if (opt->d.a.v.p.i != NULL) {
#ifdef DEBUG
              PRDBG("genmain : intervalle pour %s\n", opt->name);
#endif
              print_is_range(fd, opt->d.a.rw, &(opt->d.a.v.p), opt->iodesc, 
                                         opt->name);
            }
            fprintf(fd, "  printf(\"%s = %%s\\n\", %s(%s)) ;\n", opt->texname,
                                                opt->iodesc->function, opt->name);
          }
          break;
        case FLAGARG :
#ifdef DEBUG
          PRDBG("genmain : FLAGARG\n");
#endif
          error("'%s' : option not allowed in variable argument list\n",
                              opt->name);
          break;
        default :
#ifdef DEBUG
          PRDBG("genmain : %d : unknown type of argument\n", opt->d.a.t);
#endif
          fatal_error("%d : unknown type of argument\n", opt->d.a.t);

          break;
      }
      fprintf(fd, "    %svar_flg = FALSE;\n", MW_PFX2);
      fprintf(fd, "  }\n");
    }

    /* Generate code for write file */

    /* Generate loop for examine command options for output */
    if (GET_NUMBER(optionlist) != 0) {
      fprintf(fd, "  /* Option for output */\n");
      fprintf(fd, "  _mwoptind = 1 ;\n");
      fprintf(fd, "  while ((%sc=_mwgetopt(argc, argv, \"%s\")) != -1) {\n",
                     MW_PFX2, optb);
      fprintf(fd, "    switch (%sc) {\n", MW_PFX2);

      for (c = GET_FIRST(optionlist); c != NULL; c = GET_NEXT(c)) {
        Mwarg *opt;
        opt = (Mwarg *)GET_ELT(c);
        fprintf(fd, "      case '%c' :\n", opt->d.o.o);
        switch(opt->d.o.d.t) {
          case FILEARG :
            if (opt->d.o.d.rw == WRITE) {
              fprintf(fd, "        if (%s != NULL) {\n", opt->name);
              fprintf(fd, "          if (%s(_mwoptarg, %stype, type_force, %scomment, %s) < 0)\n",
                          opt->iodesc->function, MW_PFX2, MW_PFX2, opt->name);
              fprintf(fd, "            mwerror(FATAL, 1, \"cannot write %%s\\n\", _mwoptarg) ;\n");
              fprintf(fd, "        }\n");
            }
            break;
          case SCALARARG :
            if (opt->d.o.d.rw == WRITE) {
              if (opt->d.o.d.v.p.i != NULL) {
#ifdef DEBUG
                PRDBG("genmain : intervalle pour %s\n", opt->name);
#endif
                print_is_range(fd, opt->d.o.d.rw, &(opt->d.o.d.v.p), opt->iodesc, 
                                                              opt->name);
              }
              fprintf(fd, "        printf(\"%s = %%s\\n\", %s(%s%s)) ;\n",
                 opt->texname, opt->iodesc->function, MW_PFX, opt->name);
            }
            break;
          case FLAGARG :
#ifdef DEBUG
            PRDBG("genmain : FLAGARG\n");
#endif
            break;
          default :
#ifdef DEBUG
            PRDBG("genmain : %d : unknown type of argument\n", opt->d.o.d.t);
#endif
            fatal_error("%d : unknown type of argument\n", opt->d.o.d.t);

            break;
        }
        fprintf(fd, "        break ;\n");
      }

      /* Default : unknown option call usage function */
      fprintf(fd, "      default :\n");
      fprintf(fd, "        break;\n");
      fprintf(fd, "    }\n");
      fprintf(fd, "  }\n\n");
    }


    fprintf(fd, "  /* Needed argument for output */\n");
    for (c=GET_FIRST(neededarglist), ind=0; c!=NULL; c=GET_NEXT(c)) {
      Mwarg *opt;
      opt = (Mwarg *)GET_ELT(c);
      switch(opt->d.a.t) {
        case FILEARG :
          if (opt->d.a.rw == READ) {
            ind++;
          }
          else if (opt->d.a.rw == WRITE) {
#ifdef DEBUG
            PRDBG("genmain : neededarglist, FILEARG, write, %s\n", opt->name);
#endif
            if (opt == mwfuncret)
              fprintf(fd, "  if (%s(argv[_mwoptind+%d], %stype, type_force, %scomment, %s_ret) < 0)\n",
                     opt->iodesc->function, ind, MW_PFX2, MW_PFX2, opt->name);
            else
              fprintf(fd, "  if (%s(argv[_mwoptind+%d], %stype, type_force, %scomment, %s) < 0)\n",
                     opt->iodesc->function, ind, MW_PFX2, MW_PFX2, opt->name);
            fprintf(fd, "    mwerror(FATAL, 1, \"cannot write %%s\\n\", argv[_mwoptind+%d]) ;\n", ind);
            ind++;
          }
          break;
        case SCALARARG :
          if (opt->d.a.rw == READ) {
            ind++;
          }
          else if (opt->d.a.rw == WRITE) {
#ifdef DEBUG
            PRDBG("genmain : neededarglist, SCALARARG, write, %s\n", opt->name);
#endif
            if (opt != mwfuncret) {
              if (opt->d.a.v.p.i != NULL) {
#ifdef DEBUG
                PRDBG("genmain : intervalle pour %s\n", opt->name);
#endif
                print_is_range(fd, opt->d.a.rw, &(opt->d.a.v.p), opt->iodesc,
                                                                      opt->name);
              }
              else
                fprintf(fd, "  printf(\"%s = %%s\\n\", %s(%s)) ;\n", 
                opt->texname, opt->iodesc->function, opt->name);
            }
            else {
              char buffer[BUFSIZ];
              sprintf(buffer, "%s_ret", opt->name);
              if (opt->d.a.v.p.i != NULL) {
#ifdef DEBUG
                PRDBG("genmain : intervalle pour %s\n", opt->name);
#endif
                print_is_range(fd, opt->d.a.rw, &(opt->d.a.v.p),
                              opt->iodesc, buffer);
              }
              else
                fprintf(fd, "  printf(\"%s = %%s\\n\", %s(%s)) ;\n",
                      opt->texname,  opt->iodesc->function, buffer);
            }
          }
          break;
        case FLAGARG :
#ifdef DEBUG
          PRDBG("genmain : FLAGARG\n");
#endif
          error("'%s' : option not allowed in needed argument list\n",
                              opt->name);
          break;
        default :
#ifdef DEBUG
          PRDBG("genmain : %d : unknown type of argument\n", opt->d.a.t);
#endif
          fatal_error("%d : unknown type of argument\n", opt->d.a.t);
          break;
      }
    }

    if (GET_NUMBER(optarglist) != 0) {
      fprintf(fd, "  /* optional argument for output */\n");
      fprintf(fd, "  if (_mwoptind+%d < argc) {\n", ind);
      for (c=GET_FIRST(optarglist),n=0; c!=NULL; c=GET_NEXT(c)) {
        Mwarg *opt;
        opt = (Mwarg *)GET_ELT(c);
#ifdef DEBUG
        PRDBG("genmain : optarglist, write, %s\n", opt->name);
#endif
        switch(opt->d.a.t) {
          case FILEARG :
            if (opt->d.a.rw == READ) {
              fprintf(fd, "    ;\n");
              ind++;
            }
            else if (opt->d.a.rw == WRITE) {
              fprintf(fd, "    if (%s != NULL) {\n", opt->name);
              fprintf(fd, "      if (%s(argv[_mwoptind + %d], %stype, type_force, %scomment, %s) < 0)\n",
            opt->iodesc->function, ind, MW_PFX2, MW_PFX2, opt->name);
              fprintf(fd,
      "        mwerror(FATAL, 1, \"cannot write %%s\\n\", argv[_mwoptind + %d]) ;\n", ind);
              fprintf(fd, "    }\n");
              ind++;
            }
            break;
          case SCALARARG :
            if (opt->d.a.rw == READ) {
              fprintf(fd, "    ;\n");
              ind++;
            }
            if (opt->d.a.rw == WRITE) {
              if (opt->d.a.v.p.i != NULL) {
#ifdef DEBUG
                PRDBG("genmain : intervalle pour %s\n", opt->name);
#endif
                print_is_range(fd, opt->d.a.rw, &(opt->d.a.v.p), opt->iodesc, 
                                                                            opt->name);
              }
              fprintf(fd, "    printf(\"%s = %%s\\n\", %s(%s%s)) ;\n", 
                    opt->texname, opt->iodesc->function, MW_PFX, opt->name);
            }
            break;
          case FLAGARG :
#ifdef DEBUG
            PRDBG("genmain : FLAGARG\n");
#endif
            error("'%s' : option not allowed in optional argument list\n",
                                opt->name);
            break;
          default :
#ifdef DEBUG
            PRDBG("genmain : %d : unknown type of argument\n", opt->d.a.t);
#endif
            fatal_error("%d : unknown type of argument\n", opt->d.a.t);
            break;
        }
      }
      fprintf(fd, "  }\n");
    }


    /* Exit from main function */
    fprintf(fd, "\n  mwexit(0);\n");
    fprintf(fd, "}\n\n");

    /* Generate code for usage function */
    fprintf(fd, "int usage_%s(msg)\n", mwname->val.text);
    fprintf(fd, "char *msg;\n");
    fprintf(fd, "{\n");
    fprintf(fd, "  extern char _mwdefoptbuf[];\n");
    fprintf(fd, "  extern int help_flg;\n");
    strcpy(Vers,make_printable(mwversion->val.text));
    strcpy(Fonc,make_printable(mwfunction->val.text));
    if (mwlabo != NULL) 
      strcpy(Labo,make_printable(mwlabo->val.text));
    else
      Labo[0] = '\0';
    for (n = mwauthor, Auth[0] = '\0'; n->name == '#'; n = n->right) {
      strncat(Auth, n->left->val.text+1, strlen(n->left->val.text)-2);
      strcat(Auth, ", ");
    }
    strncat(Auth, n->val.text+1, strlen(n->val.text)-2);
    _mw_presentation(fd, mwname->val.text, Vers, Auth, Fonc, Labo);
    fprintf(fd, "  if (msg != NULL)\n");
    fprintf(fd, "    fprintf(stderr, \"error : %%s\\n\\n\", msg) ;\n");

    /* Build usage line */

    fprintf(fd, "  fprintf(stderr, \"usage : %%s%%s");
    sprintf(usagebuf, "usage : %s", mwname->val.text);

    /* Options */
    for (c = GET_FIRST(optionlist); c != NULL; c = GET_NEXT(c)) {
      Mwarg *opt;
      char buffer[BUFSIZ];
      opt = (Mwarg *)GET_ELT(c);

      /* if (!(opt->d.o.d.t == SCALARARG && opt->d.o.d.rw == WRITE)))
      { Removed JF 13/10/2000
      */
      fprintf(fd, " [-%c", opt->d.o.o);
      sprintf(buffer, " [-%c", opt->d.o.o);
      strcat(usagebuf, buffer);
      if (opt->texname != NULL) 
	{
	  fprintf(fd, " %s]", opt->texname);
	  sprintf(buffer, " %s]", opt->texname);
	  strcat(usagebuf, buffer);
	}
      else 
	{
	  fprintf(fd, "]");
	  strcat(usagebuf, "]");
	}
      /*}*/
    }

    /* Needed arg */
    for (c = GET_FIRST(neededarglist); c != NULL; c = GET_NEXT(c)) {
      Mwarg *opt;
      char buffer[BUFSIZ];
      opt = (Mwarg *)GET_ELT(c);
      if (!(opt->d.a.t == SCALARARG && opt->d.a.rw == WRITE)) 
	{
	  fprintf(fd, " %s", opt->texname);
	  sprintf(buffer, " %s", opt->texname);
	  strcat(usagebuf, buffer);
	}
      /* -- Added JF 07/06/01 --
	In case of a needed argument, something (as .) has to be
	given in the command line to avoid argument shifting.
       */
      else
	{
	  fprintf(fd, " .");
	  sprintf(buffer, " .");
	  strcat(usagebuf, buffer);
	}
      /* ----------------------- */
    }

    /* Opt arg */
    if (GET_NUMBER(optarglist) != 0) {
      fprintf(fd, " [");
      strcat(usagebuf, " [");
      for (c = GET_FIRST(optarglist); c != NULL; c = GET_NEXT(c)) {
        Mwarg *opt;
        char buffer[BUFSIZ];
        opt = (Mwarg *)GET_ELT(c);
        if (!(opt->d.a.t == SCALARARG && opt->d.a.rw == WRITE)) {
          fprintf(fd, " %s", opt->texname);
          sprintf(buffer, " %s", opt->texname);
          strcat(usagebuf, buffer);
        }
      }
      fprintf(fd, " ]");
      strcat(usagebuf, " ]");
    }

    /* Var arg */
    if (GET_NUMBER(vararglist) != 0) {
      Mwarg *opt;
      char buffer[BUFSIZ];
      c = GET_FIRST(vararglist);
      opt = (Mwarg *)GET_ELT(c);
      if (!(opt->d.a.t == SCALARARG && opt->d.a.rw == WRITE)) {
        fprintf(fd, " [%s]", opt->texname);
        sprintf(buffer, " [%s]", opt->texname);
        strcat(usagebuf, buffer);
      }
    }
    fprintf(fd, "\\n\\n\", mwname, (help_flg) ? _mwdefoptbuf : \"\");\n");
    strcat(usagebuf, "\\n");

    /* Build lines describing the names */

    /* Options */
    for (c = GET_FIRST(optionlist); c != NULL; c = GET_NEXT(c)) 
      {
	Mwarg *opt;
	char buffer[BUFSIZ];
	opt = (Mwarg *)GET_ELT(c);

	/* Modif JF 06/10/2000 
	if (!(opt->d.o.d.t == SCALARARG && opt->d.o.d.rw == WRITE)) 
	  {
	    fprintf(fd, "  fprintf(stderr, \"\\t-%c", opt->d.o.o);
	    sprintf(buffer, "\\t-%c", opt->d.o.o);
	    strcat(usagebuf, buffer);
	    if (opt->texname != NULL) 
	      {
	      fprintf(fd, " %s", opt->texname);
	      sprintf(buffer, " %s", opt->texname);
	      strcat(usagebuf, buffer);
	      }
	    fprintf(fd, " :\\t%s\\n\");\n", make_printable(opt->desc));
	    sprintf(buffer, " :\\t%s\\n", make_printable(opt->desc));
	    strcat(usagebuf, buffer);
	  }
	*/
	fprintf(fd, "  fprintf(stderr, \"\\t-%c", opt->d.o.o);
	sprintf(buffer, "\\t-%c", opt->d.o.o);
	strcat(usagebuf, buffer);
	if (opt->texname != NULL) 
	  {
	    fprintf(fd, " %s", opt->texname);
	    sprintf(buffer, " %s", opt->texname);
	    strcat(usagebuf, buffer);
	  }
	if (opt->d.o.d.t == SCALARARG && opt->d.o.d.rw == WRITE)
	  {
	    fprintf(fd, " screen output");
	    sprintf(buffer," screen output");
	    strcat(usagebuf, buffer);
	  }
	fprintf(fd, " :\\t%s\\n\");\n", make_printable(opt->desc));
	sprintf(buffer, " :\\t%s\\n", make_printable(opt->desc));
	strcat(usagebuf, buffer);
      }

  
    /* Needed arg */
    for (c = GET_FIRST(neededarglist); c != NULL; c = GET_NEXT(c)) {
      Mwarg *opt;
      char buffer[BUFSIZ];
      opt = (Mwarg *)GET_ELT(c);
      if (!(opt->d.a.t == SCALARARG && opt->d.a.rw == WRITE)) 
	{
	  fprintf(fd, "  fprintf(stderr, \"\\t%s :\\t%s\\n\");\n", opt->texname,
                  make_printable(opt->desc));
	  sprintf(buffer, "\\t%s :\\t%s\\n", opt->texname, make_printable(opt->desc));
	  strcat(usagebuf, buffer);
	}
      else
	{
	  fprintf(fd, "  fprintf(stderr, \"\\t. (screen output) :\\t%s\\n\");\n", 
                  make_printable(opt->desc));
	  sprintf(buffer, "\\t. (screen output) :\\t%s\\n", make_printable(opt->desc));
	  strcat(usagebuf, buffer);
	}
    }

    /* Opt arg */
    if (GET_NUMBER(optarglist) != 0) {
      for (c = GET_FIRST(optarglist); c != NULL; c = GET_NEXT(c)) {
        Mwarg *opt;
        char buffer[BUFSIZ];
        opt = (Mwarg *)GET_ELT(c);
        if (!(opt->d.a.t == SCALARARG && opt->d.a.rw == WRITE)) 
	  {
	    fprintf(fd, "  fprintf(stderr, \"\\t%s :\\t%s\\n\");\n", opt->texname,
		    make_printable(opt->desc));
	    sprintf(buffer, "\\t%s :\\t%s\\n", opt->texname, make_printable(opt->desc));
	    strcat(usagebuf, buffer);
	  }
	else
	  {
	  fprintf(fd, "  fprintf(stderr, \"\\tscreen output :\\t%s\\n\");\n", 
                  make_printable(opt->desc));
	  sprintf(buffer, "\\tscreen output :\\t%s\\n", make_printable(opt->desc));
	  strcat(usagebuf, buffer);
	  }
      }
    }

    /* Var arg */
    if (GET_NUMBER(vararglist) != 0) {
      Mwarg *opt;
      char buffer[BUFSIZ];
      c = GET_FIRST(vararglist);
      opt = (Mwarg *)GET_ELT(c);
      if (!(opt->d.a.t == SCALARARG && opt->d.a.rw == WRITE)) 
	{
	  fprintf(fd, "  fprintf(stderr, \"\\t%s :\\t%s\\n\");\n", opt->texname,
		  make_printable(opt->desc));
	  sprintf(buffer, "\\t%s :\\t%s\\n", opt->texname, make_printable(opt->desc));
	  strcat(usagebuf, buffer);
	}
      else
	{
	  fprintf(fd, "  fprintf(stderr, \"\\tscreen output... :\\t%s\\n\");\n", 
                  make_printable(opt->desc));
	  sprintf(buffer, "\\tscreen output... :\\t%s\\n", make_printable(opt->desc));
	  strcat(usagebuf, buffer);
	}
    }
    usagebuf[strlen(usagebuf)] = '\0';
    fprintf(fd, "  mwexit(1);\n");
    fprintf(fd, "}\n");

#ifdef DEBUG
    PRDBG("genmain : end\n");
#endif
  }
  else
    fatal_error("MegaWave function \"%s\" does not exist\n", mwname->val.text);
}
