<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>megawave system manual
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
body	{
	color: #000000; 
	background-color: #ffffff; 
	font-family: Arial, Helvetica, sans-serif; 
	font-size: 13px;
	width: 60em; 
	margin: auto;
	text-align: justify;
	}

h1	{ 
	font-size:1.4em; 
	border: #CCCCFF solid; 
	border-width: 1px 0; 
	padding: .5em 2em; 
	margin: 2em 0 0 0;
	}
h2 	{ 
	font-size:1.2em; 
	padding: 0 1em;
	}
h3 	{ 
	font-size: 1em; 
	padding: 0 1em;
	}

a 	{
	color:#1E4869; 
	text-decoration: none;
	}
a:hover { 
	background:#EEEEEE;
	}

p 	{ 
	padding: 0 1em;
	}
abbr 	{ 
	border: 0; 
	}
table 	{
	text-align: left; 
	width: 100%; 
	}

ul, ol 	{ 
	padding: 0 1em 0 2em;
	}

pre 	{
        padding: 1em 1em 0 1em;
        margin: 0 0 0 1em;
        background: #EEEEEE;
        border-left: #AAAAAA 3px solid; 
	}

hr 	{
	color: #EEEEEE;
	border: 0;
	height: 1px;
  	width: 80%; 
	}

img 	{
	border: 0; 
	}

.navigation {
	font-size: 150%;
	font-weight: bold;
	float: left; 
	}

// original hevea style //

.li-itemize {
	margin: 1ex 0ex; 
	}
.li-enumerate{
	margin: 1ex 0ex;
	}
.toc	{
	list-style: none; 
	}
.thefootnotes {
	text-align: left;
	margin: 0ex; 
	}
.dt-thefootnotes {
	margin: 0em;
	}
.dd-thefootnotes {
	margin: 0em 0em 0em 2em; 
	}
.footnoterule {
	margin: 1em auto 1em 0px;
	width: 50%; 
	}
.caption {
	padding-left: 2ex; 
	padding-right: 2ex; 
	margin-left: auto; 
	margin-right: auto; 
	}
.center	{
	text-align: center;
	margin-left: auto;
	margin-right:auto; 
	}
div table {
	margin-left: inherit;
    	margin-right: inherit; 
	}
pre	{
	text-align: left;
	margin-left: 0ex;
	margin-right: auto; 
	}
blockquote {
	margin-left: 4ex;
	margin-right: 4ex;
	text-align: left; 
	}
td p	{
	margin: 0px; 
	}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -fix -O -o system_manual.html system_manual.tex -->
<!--CUT DEF chapter 1 --><DIV CLASS="center">
megawave software suite documentation (version 3.01)<BR>
<BR>
<BR>
<BR>

<FONT SIZE=4><B>volume two</B></FONT><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<FONT SIZE=6><SPAN STYLE="font-variant:small-caps">megawave system manual</SPAN></FONT><BR>
<BR>
<BR>
<BR>

<FONT SIZE=4><EM>edited by Jacques Froment</EM></FONT><BR>
</DIV><DIV CLASS="center"><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>


copyright &#XA9;  CMLA, Ecole Normale Sup&#XE9;rieure de Cachan<BR>
61 avenue du Pr&#XE9;sident Wilson, 94235 Cachan cedex, France<BR>
all rights reserved<BR>
http://megawave.cmla.ens-cachan.fr/
</DIV><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter&#XA0;1&#XA0;&#XA0;Introduction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1&#XA0;&#XA0;What you will find in this guide</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc3">1.2&#XA0;&#XA0;The MegaWave2 memory (internal) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.3&#XA0;&#XA0;File (external) types or file formats</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc5">1.3.1&#XA0;&#XA0;Generalities</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">1.3.2&#XA0;&#XA0;Search path convention</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">Chapter&#XA0;2&#XA0;&#XA0;Images</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc8">2.1&#XA0;&#XA0;Char Images</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc9">2.1.1&#XA0;&#XA0;The structure Cimage</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">2.1.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">2.1.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">2.2&#XA0;&#XA0;Color Char Images</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc13">2.2.1&#XA0;&#XA0;The structure Ccimage</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">2.2.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">2.2.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">2.3&#XA0;&#XA0;Float Images</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc17">2.3.1&#XA0;&#XA0;The structure Fimage</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">2.3.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">2.3.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">2.4&#XA0;&#XA0;Color Float Images</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc21">2.4.1&#XA0;&#XA0;The structure Cfimage</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">2.4.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">2.4.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">Chapter&#XA0;3&#XA0;&#XA0;Movies</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc25">3.1&#XA0;&#XA0;Char movies</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc26">3.1.1&#XA0;&#XA0;The structure Cmovie</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">3.1.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">3.1.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">3.2&#XA0;&#XA0;Color Char movies</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc30">3.2.1&#XA0;&#XA0;The structure Ccmovie</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">3.2.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">3.2.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">3.3&#XA0;&#XA0;Float movies</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc34">3.3.1&#XA0;&#XA0;The structure Fmovie</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">3.3.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">3.3.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">3.4&#XA0;&#XA0;Color Float movies</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc38">3.4.1&#XA0;&#XA0;The structure Cfmovie</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">3.4.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">3.4.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">Chapter&#XA0;4&#XA0;&#XA0;Signals</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc42">4.1&#XA0;&#XA0;Float signals</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc43">4.1.1&#XA0;&#XA0;The structure Fsignal</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">4.1.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">4.1.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">Chapter&#XA0;5&#XA0;&#XA0;Wavelets</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc47">5.1&#XA0;&#XA0;One-dimensional wavelet</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc48">5.1.1&#XA0;&#XA0;The structure Wtrans1d</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">5.1.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">5.1.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">5.2&#XA0;&#XA0;Two-dimensional wavelet</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc52">5.2.1&#XA0;&#XA0;The structure Wtrans2d</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">5.2.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">5.2.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">5.3&#XA0;&#XA0;Two-dimensional wavelet packets</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc56">5.3.1&#XA0;&#XA0;The structure Wpack2d</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">5.3.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">5.3.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">Chapter&#XA0;6&#XA0;&#XA0;Geometrical structures : Point, Curves, Polygons and Lists</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc60">6.1&#XA0;&#XA0;Point of a planar curve</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc61">6.1.1&#XA0;&#XA0;The structure Point_curve</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">6.1.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">6.1.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">6.2&#XA0;&#XA0;Planar curve</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc65">6.2.1&#XA0;&#XA0;The structure Curve</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">6.2.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">6.2.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">6.3&#XA0;&#XA0;Set of planar curves</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc69">6.3.1&#XA0;&#XA0;The structure Curves</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">6.3.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">6.3.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">6.4&#XA0;&#XA0;Polygon, a variant of curve</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc73">6.4.1&#XA0;&#XA0;The structure Polygon</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc74">6.4.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">6.4.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">6.5&#XA0;&#XA0;Set of polygons</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc77">6.5.1&#XA0;&#XA0;The structure Polygons</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">6.5.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">6.5.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">6.6&#XA0;&#XA0;Points, Curves and Polygons with real coordinates</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">6.7&#XA0;&#XA0;Lists of <I>n</I>-tuple reals</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc82">6.7.1&#XA0;&#XA0;The structure Flist</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">6.7.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">6.7.3&#XA0;&#XA0;Functions Summary</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">6.7.4&#XA0;&#XA0;The structure Flists</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">6.7.5&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">6.7.6&#XA0;&#XA0;Functions Summary</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc88">6.7.7&#XA0;&#XA0;The structures Dlist and Dlists</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">6.7.8&#XA0;&#XA0;Related file (external) types</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">Chapter&#XA0;7&#XA0;&#XA0;Level sets and morphological structures</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc91">7.1&#XA0;&#XA0;Shape</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc92">7.1.1&#XA0;&#XA0;The structure Shape</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc93">7.1.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">7.1.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">7.2&#XA0;&#XA0;Shapes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc96">7.2.1&#XA0;&#XA0;The structure Shapes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">7.2.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">7.2.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">7.3&#XA0;&#XA0;Point with a type field</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc100">7.3.1&#XA0;&#XA0;The structure Point_type</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">7.3.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">7.3.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">7.4&#XA0;&#XA0;Horizontal segment</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc104">7.4.1&#XA0;&#XA0;The structure Hsegment</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">7.4.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">7.4.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">7.5&#XA0;&#XA0;Morpho set</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc108">7.5.1&#XA0;&#XA0;The structure Morpho_set</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc109">7.5.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">7.5.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">7.6&#XA0;&#XA0;Chain of morpho sets</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc112">7.6.1&#XA0;&#XA0;The structure Morpho_sets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">7.6.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">7.6.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">7.7&#XA0;&#XA0;Morpho line</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc116">7.7.1&#XA0;&#XA0;The structure Morpho_line</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">7.7.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">7.7.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">7.8&#XA0;&#XA0;Morpho line in the continuous plane</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc120">7.8.1&#XA0;&#XA0;The structure Fmorpho_line</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc121">7.8.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">7.8.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">7.9&#XA0;&#XA0;Morphological image</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc124">7.9.1&#XA0;&#XA0;The structure Mimage</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">7.9.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">7.9.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc127">Chapter&#XA0;8&#XA0;&#XA0;Unstructured material or raw data</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc128">8.1&#XA0;&#XA0;The structure Rawdata</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">8.2&#XA0;&#XA0;Related file (external) types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">8.3&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc131">Chapter&#XA0;9&#XA0;&#XA0;Miscellaneous Features</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc132">9.1&#XA0;&#XA0;Global System Variables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc133">9.2&#XA0;&#XA0;Conversion between memory types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc134">9.3&#XA0;&#XA0;Miscellaneous System Functions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc135">Chapter&#XA0;10&#XA0;&#XA0;Wdevice Library and window facilities</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc136">10.1&#XA0;&#XA0;Functions Summary</A>
</LI></UL>
</LI></UL><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter&#XA0;1</A>&#XA0;&#XA0;Introduction</H1><!--SEC END --><P>
<A NAME="intro"></A>
</P><!--TOC section What you will find in this guide-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>&#XA0;&#XA0;What you will find in this guide</H2><!--SEC END --><P><A NAME="intro_guide"></A></P><P>When you implement an algorithm in MegaWave2, you write a code in C language 
in what we call a module (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Your algorithm processes some objects
which represent your data. So you need to know how to create an object<A NAME="@default0"></A> of
the type you want, how to access to it, how to remove it, etc.</P><P>This present guide will detail all the available MegaWave2 objects and most
related functions<A NAME="@default1"></A> which are part of the System Library 
(Sections&#XA0;<A HREF="#images">2</A> to&#XA0;<A HREF="#rawdata">8</A>).
In addition, you will find the description of other functions which may
be called by the user in the module - such as error handling functions -
(Section&#XA0;<A HREF="#miscellaneous">9</A>).
There is also a description of the Wdevice Library, a toolbox for the
window interface (Section&#XA0;<A HREF="#wdevice">10</A>).</P><P>This guide is a reference manual : it would be boring to read it from the
beginning to the end. If you are new with MegaWave2, you should entirely read this
introduction were basic principles are explained, and all introductions of 
the next main sections, to get an idea about the various objects you may use.
Afterward, when you will be searching for a particular structure or function, consult 
the contents page&#XA0;<A HREF="#contents">??</A> or the index page&#XA0;<A HREF="#index">??</A>.</P><!--TOC section The MegaWave2 memory (internal) types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">1.2</A>&#XA0;&#XA0;The MegaWave2 memory (internal) types</H2><!--SEC END --><P><A NAME="intro_memory-types"></A></P><P><A NAME="@default2"></A>
<A NAME="@default3"></A>
<A NAME="@default4"></A></P><P><A NAME="@default5"></A></P><P>MegaWave2 objects such as images, movies, signals, curves, &#X2026;, are 
represented in the module code as <EM>pointers to a structure</EM>.
The type of the structure defines the object you want to process, as
<CODE>struct fimage</CODE> for an image of Floating points values (the pointer of
this structure is of type <CODE>Fimage</CODE>).</P><P>Each structure has particular fields, as <CODE>gray</CODE> for a <CODE>Fimage</CODE> which
represents the gray levels plane. They are described in the section presenting
the structure (Section&#XA0;<A HREF="#images_float-images_structure">2.3.1</A> page&#XA0;<A HREF="#images_float-images_structure">??</A> for <CODE>Fimage</CODE>).</P><P>Some fields are common to most structures, they are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>cmt</CODE> : string of maximum size <CODE>mw_cmtsize</CODE> where to put the comment associated to the object. 
For input objects and at the beginning of the
module statement, this field contains the comment field of the corresponding file object (if the file type provides a comment field). 
For output objects and at the end of the module statement, this field contains the name of the module plus the comments of the input objects, if any.
This default output value can be overwritten by setting a value to <CODE>cmt</CODE>.
</LI><LI CLASS="li-itemize"><CODE>name</CODE> : string of maximum size <CODE>mw_namesize</CODE> where to put the name of this object. For input objects, this field contains the file name of the corresponding file object. 
The default output value is &#X201C;?&#X201D;. 
It can be overwritten.
</LI></UL><P>You can of course access to any field in order to read its content. But be carefull
when you want to overwrite the content of a field: some fields have to be
updated by the system library only (e.g. the dimension fields <CODE>nrow</CODE> and
<CODE>ncol</CODE> of image objects).</P><P>Some structures may contain undocumented fields: they are used internally by 
the system library and users should not access to them, especially for writing.</P><P>Some conversions between memory types are available as functions of the System Library,
see Section&#XA0;<A HREF="#conv_memory_types">9.2</A> of this guide for a list of the most current conversion 
functions.</P><!--TOC section File (external) types or file formats-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">1.3</A>&#XA0;&#XA0;File (external) types or file formats</H2><!--SEC END --><P><A NAME="intro_file-types"></A></P><!--TOC subsection Generalities-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">1.3.1</A>&#XA0;&#XA0;Generalities</H3><!--SEC END --><P><A NAME="@default6"></A>
<A NAME="@default7"></A>
<A NAME="@default8"></A></P><P>When a module&#X2019;s command finishes, the output objects (of memory types) have to be saved on disk for future use.
For example, they can be the input of another module&#X2019;s command.
Data may be saved on disk also (or read from disk) when the module is run
into an interpreter such as XMegaWave2, although in this case modules communicate with memory type structures.</P><P>This shows that external type objects are needed; they are files written in a predefined format.
MegaWave2 can use some well-known formats available in the public domain, especially to carry the different image memory types.
When no satisfying standard is available to match a given memory type, a specific format is used.
Notice that, whereas there is only one memory type associated to an object, an object of a given memory type may be represented on disk with various file types.</P><P>Conversions between some formats are available: you may load an object written
in a file type which is different from the regular one used for the memory type of your object. Depending on the case, you may however lose precision in your data
(in that case, a warning message is send).
For output ojects, MegaWave2 chooses a default file type to write the data.
You can modify this choice using the system option <CODE>-ftype</CODE> (see volume one: &#X201C;MegaWave2 user manual&#X201D;).</P><P>A short description of the file types is given in the next sections about the different memory types.</P><!--TOC subsection Search path convention-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">1.3.2</A>&#XA0;&#XA0;Search path convention</H3><!--SEC END --><P><A NAME="@default9"></A>
When a module is called in the command line mode, MegaWave2 searches the file names of the input objects in different directories, following the order:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
the current directory of the shell, i.e. &#X201C;<CODE>.</CODE>&#X201D;;
</LI><LI CLASS="li-enumerate">the module&#X2019;s group directory of <CODE>$MY_MEGAWAVE2/data</CODE>;
</LI><LI CLASS="li-enumerate"><CODE>$MY_MEGAWAVE2/data</CODE> and its subdirectories;
</LI><LI CLASS="li-enumerate">the module&#X2019;s group directory of <CODE>$MEGAWAVE2/data</CODE>;
</LI><LI CLASS="li-enumerate"><CODE>$MEGAWAVE2/data</CODE> and its subdirectories.
</LI></OL><P>
Notice that this search path convention has changed from MegaWave2 versions 1.x to versions 2.x and
from versions 2.x to versions 3.x.</P><P>The output objects are always written in the current directory of the shell.
<EM>Beware :
if you give the same name as the one of an existing file, the content of the previous file will be overwritten 
(there is no confirmation message).</EM></P><!--TOC chapter Images-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc7">Chapter&#XA0;2</A>&#XA0;&#XA0;Images</H1><!--SEC END --><P>
<A NAME="images"></A>
</P><P>All image<A NAME="@default10"></A> structures share the following important fields:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>nrow,ncol</CODE> : define the size of the image, by the number of
rows and the number of columns (not to be overwritten by user).
Notice that the range over the <I>x</I> axis is 0 &#X2026; <CODE>ncol</CODE> &#X2212;1 and that
the range over the <I>y</I> axis is 0 &#X2026; <CODE>nrow</CODE> &#X2212;1.
</LI><LI CLASS="li-itemize"><CODE>previous, next</CODE> : pointers to the previous and the next image. These fields are used only when the image is part of a movie.
</LI></UL><P>Each image structure has also one or several fields to record the pixel values.
When the image is monochrome, there is only one field called <CODE>gray</CODE>.
Color images use three fields called <CODE>red</CODE>, <CODE>green</CODE> and <CODE>blue</CODE>.
The C type of these array fields depends to the image object: they can be pointers to <CODE>unsigned char</CODE> values or pointers to <CODE>floating points</CODE> values.</P><P>You can put values in those arrays, at the expressed condition that you respect
the C type of the field and that you do not exceed the maximum value of the 
index, given by ncol &#XD7; nrow &#X2212; 1.
For example, <CODE>image-&gt;gray[y*image-&gt;ncol+x]</CODE> is the gray level of the pixel of coordinates (<I>x</I>,<I>y</I>) that is, the column #<I>x</I> and the row #<I>y</I>.
Ranges are 0 &#X2026; <I>nrow</I> &#X2212;1 for <I>y</I> and 0 &#X2026; <I>ncol</I> &#X2212;1 for <I>x</I>.</P><P>You can shorten this expression in your modules using C macro, for example:
</P><PRE CLASS="verbatim">#define _(a,i,j) ((a)-&gt;gray[(j)*(a)-&gt;ncol+(i)] )
</PRE><P>
allows you to access to the pixel (<I>x</I>,<I>y</I>) by writing <CODE>_(image,x,y)</CODE>.</P><P>Tip to speed your modules: images are built from left to right and up to down.
If you can write your algorithm to access to the pixel following this natural order,
you can speed it considerably using the following scheme. In this example, one 
copies each pixel of the cimage M into the fimage B only if the pixel of M is not
equal to zero:
</P><PRE CLASS="verbatim">  Cimage M;    /* Input of the module */
  Fimage *B;   /* Output of the module */

  register float *ptrB;
  register unsigned char *ptrM;
  register int i;

  for (i=0, ptrB = (*B)-&gt;gray, ptrM = M-&gt;gray;
               i&lt; M-&gt;ncol*M-&gt;nrow;
               i++, ptrB++, ptrM++)
            if (*ptrM) *ptrB = (float) *ptrM;
</PRE><P>
If you scan the pixels in a random order, you may rather define a bi-dimensional
tab <CODE>A</CODE> so that <CODE>A[l][c]</CODE> points to the pixel&#X2019;s value <CODE>(c,l)</CODE>.
See the functions <CODE>mw_newtab_cimage()</CODE>, <CODE>mw_newtab_fimage()</CODE>, &#X2026;</P><!--TOC section Char Images-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">2.1</A>&#XA0;&#XA0;Char Images</H2><!--SEC END --><P><A NAME="images_char-images"></A></P><P>Use preferably the <EM>Char Images</EM> memory type each time you can write an algorithm which directly computes the gray level as an integer between 0 (black) and 255 (white) : such discrete scheme will be more accurate, faster and will require far less memory than a continuous scheme (i.e. with floating points computations).</P><!--TOC subsection The structure Cimage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc9">2.1.1</A>&#XA0;&#XA0;The structure Cimage</H3><!--SEC END --><P>
<A NAME="images_char-images_structure"></A></P><P>
<A NAME="@default11"></A></P><P>Beginners should only focus on the first three fields of this structure. 
You should also consider the fields <CODE>previous</CODE> and <CODE>next</CODE> if your
image is part of a movie.
Some fields are not used this time, such <CODE>firstcol</CODE> &#X2026;<CODE>lastrow</CODE>,
but future modules may access to them.</P><PRE CLASS="verbatim">typedef struct cimage {
  int nrow;        /* Number of rows (dy) */
  int ncol;        /* Number of columns (dx) */
  unsigned char *gray;     /* The Gray level plane (may be NULL) */

  float scale;     /* Scale of the picture (should be 1 for original pict.) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the picture : */
  int firstcol;    /* index of the first col not affected by left side effect*/
  int lastcol;     /* index of the last col not affected by right side effect*/
  int firstrow;    /* index of the first row not aff. by upper side effect */  
  int lastrow;     /* index of the last row not aff. by lower side effect */  

  /* For use in Movies only */
  struct cimage *previous; /* Pointer to the previous image (may be NULL) */
  struct cimage *next; /* Pointer to the next image (may be NULL) */

} *Cimage;
</PRE><P>Do not change by yourself the content of <CODE>nrow</CODE> and <CODE>ncol</CODE>: the size
of the image has to be modified using functions of the library only (see section&#XA0;<A HREF="#images_char-images_function">2.1.3</A> page&#XA0;<A HREF="#images_char-images_function">??</A>).</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">2.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="images_char-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"IMG"</CODE><A NAME="@default12"></A> Original format defined by the defunct software PCVision (from ImageAction), and widely used by MegaWave1.
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
</LI><LI CLASS="li-enumerate"><CODE>"TIFF"</CODE><A NAME="@default13"></A> Tag Image Format with one 8-bits plane (unsigned char gray levels).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by Sam Leffler and Silicon Graphics, Inc.
To use this format, you need the TIFF library (libtiff). See the Volume One, section 
&#X201C;Installation&#X201D;. Output objects are created without compression.
</LI><LI CLASS="li-enumerate"><CODE>"PGMA"</CODE><A NAME="@default14"></A> PGM (portable graymap file format) in Ascii version.
</LI><LI CLASS="li-enumerate"><CODE>"PGMR"</CODE><A NAME="@default15"></A> PGM (portable graymap file format) in Rawbits version.
</LI><LI CLASS="li-enumerate"><CODE>"PM_C"</CODE><A NAME="@default16"></A> PM format with one 8-bits plane (unsigned char gray levels).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the University of Pennsylvania, USA.
</LI><LI CLASS="li-enumerate"><CODE>"GIF"</CODE><A NAME="@default17"></A> GIF87 (Graphics Interchange Format) 8-bits per pixel, non interlaced.
This format has been developed by CompuServe Incorporated.
</LI><LI CLASS="li-enumerate"><CODE>"BMP"</CODE><A NAME="@default18"></A> Microsoft BMP 8-bits per pixel.
Output objects are created using Windows BMP format. Compression methods are not implemented.
</LI><LI CLASS="li-enumerate"><CODE>"JFIF"</CODE><A NAME="@default19"></A> JPEG/JFIF format with one 8-bits plane (unsigned char gray levels).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the Independent JPEG Group&#X2019;s software.
To use this format, you need the JPEG library (libjpeg). See the Volume One, section 
&#X201C;Installation&#X201D;. 
The compression ratio is defined by the quality factor, which is an integer between 1 (worse) and 100 (best).
Default quality factor is 100. To change this value, add it as an option to the JFIF type.
For example, JFIF:50 means JFIF file type with quality factor 50.
Whatever the quality factor, output objects are created with loosely compression.
</LI><LI CLASS="li-enumerate"><CODE>"PS"</CODE><A NAME="@default20"></A> PostScript (level 1) format, <EM>for output objects only</EM>.
This format has been developed by Adobe Systems Incorporated.
</LI><LI CLASS="li-enumerate"><CODE>"EPSF"</CODE><A NAME="@default21"></A> Encapsulated PostScript (level 1) format, <EM>for output objects only</EM>.
Same as PS format but more suitable when used with some softwares that recognize encapsulated comments, such as L<sup>A</sup>T<sub>E</sub>X.
</LI><LI CLASS="li-enumerate"><CODE>"INR"</CODE><A NAME="@default22"></A> Original format defined by the software Inrimage (from INRIA). This is a very old version, implemented for
backward-compatibility with MegaWave1, and it should not be used anymore.
</LI><LI CLASS="li-enumerate"><CODE>"MTI"</CODE><A NAME="@default23"></A> Original format defined by the software MultImage (from 2AI), and used by MegaWave1. Quite exotic now.
</LI><LI CLASS="li-enumerate"><CODE>"BIN"</CODE><A NAME="@default24"></A> This is the &#X201C;universal&#X201D; image format for 8-bits gray levels images.
It records one byte per pixel, without header.
Since it does not contain any header, the image file must be a square (i.e. the number of columns and the number of lines must be the same).
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">2.1.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="images_char-images_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Cimage</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_cimage</FONT></B> - Allocate the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cimage mw_alloc_cimage(image,nrow,ncol)</P><P>Cimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the gray plane of a <TT>Cimage </TT>structure previously
created using <CODE>mw_new_cimage</CODE>. The size of the image is given by 
<CODE>nrow</CODE> (number of rows or maximum range of <I>y</I> plus one) and <CODE>ncol</CODE>
(number of columns or maximum range of <I>x</I> plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.</P><P>Do not use this function if <CODE>image</CODE> has already an allocated plane: use
the function <CODE>mw_change_cimage</CODE> instead.</P><P>The function <CODE>mw_alloc_cimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cimage()) == NULL) ||
      (mw_alloc_cimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to white */
image-&gt;gray[256] = 255;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_cimage</FONT></B> - Change the size of the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cimage mw_change_cimage(image, nrow, ncol)</P><P>Cimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the gray plane of a <TT>Cimage </TT>structure, even if no previously memory allocation was done.
The new size of the image is given by <CODE>nrow</CODE> (number of rows or maximum 
range of <I>y</I> plus one) and <CODE>ncol</CODE> (number of columns or maximum range of 
<I>x</I> plus one). </P><P>It can also create the structure if the input <CODE>image = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_cimage</CODE> and
<CODE>mw_alloc_cimage</CODE>. It is the recommended function to set image 
dimension of input/output modules. Since the function can set the 
address of <CODE>image</CODE>, the variable must be set to the return value of 
the function (See example below).</P><P>The function <CODE>mw_change_cimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage u; 

/* Usage when &lt;u&gt; IS NOT an output of the module (and has not been
   previously allocated): the function returns a new structure's address
*/
u = mw_change_cimage(NULL, 256, 256);

/* Usage when &lt;u&gt; IS an output of the module (or has been previously
   allocated): DO NOT change the structure's address
*/
u = mw_change_cimage(u, 256, 256);

if (u == NULL) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_cimage</FONT></B> - Clear the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_cimage(image, v)</P><P>Cimage image;</P><P>unsigned char v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the cimage <CODE>image</CODE> with the gray value given by <I>v</I>:
all pixels will have the gray level <I>v</I>. </P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Output of module */

image = mw_change_cimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to white */
mw_clear_cimage(image,255);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_cimage</FONT></B> - Copy the pixel values of an image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_cimage(in, out)</P><P>Cimage in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the gray plane of the image <CODE>in</CODE> into 
the gray plane of the image <CODE>out</CODE>.
The size of the two gray planes must be the same.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cimage G; /* Needed Input */
Cimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_cimage(F, G-&gt;nrow, G-&gt;ncol)) == NULL)
 mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_cimage(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_cimage</FONT></B> - Deallocate the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_cimage(image)</P><P>Cimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the gray plane of a <TT>Cimage </TT>structure previously
allocated using <CODE>mw_alloc_cimage</CODE> or <CODE>mw_change_cimage</CODE>, and the
structure itself. </P><P>You should set <CODE>image = NULL</CODE> after this call since the address pointed
by <CODE>image</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cimage()) == NULL) ||
      (mw_alloc_cimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_cimage(image);
image = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_draw_cimage</FONT></B> - Draw a line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_draw_cimage(image, a0, b0, a1, b1, c)</P><P>Cimage image;</P><P>int a0,b0,a1,b1;
unsigned char c;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function draws in <CODE>image</CODE> a connected line of gray level <I>c</I> between the pixel (<I>a</I>0,<I>b</I>0) and the pixel (<I>a</I>1,<I>b</I>1).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Output of module */

image = mw_change_cimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to white */
mw_clear_cimage(image,255);
/* Draw a black diagonal line */
mw_draw_cimage(image,0,0,99,99,0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_getdot_cimage</FONT></B> - Return the gray level value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char mw_getdot_cimage(image, x, y)</P><P>Cimage image;</P><P>int x,y;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the gray level value (a number between 0 - black - and 255 - white -) of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>).</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value. See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to read pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
 printf("image(%d,%d) = %d\n",x,y,mw_getdot_cimage(image,x,y));
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_isitbinary_cimage</FONT></B> - Check if the image is binary</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char mw_isitbinary_cimage(image)</P><P>Cimage image;</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns 0 if <CODE>image</CODE> is not a binary image, a value &gt; 0
if it is one. In that case, the returned value corresponds to the maxima 
value that is, to the only one value &#X2260; 0.
Image with two gray levels only but with the minimal value &gt; 0 is not 
considered by this function as binary.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Needed Input of module */
unsigned char white;

if ((white=mw_isitbinary_cimage(image)) &gt; 0)
 printf("Binary image with white set to %d\n",(int) white);
else  
 printf("Not a binary image\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_newtab_gray_cimage</FONT></B> - Create a bi-dimensional tab for the pixels of a Cimage</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char ** mw_newtab_gray_cimage(image)</P><P>Cimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; gray level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the gray plane of the given image.</P><P>This function must be called after the gray plane has been allocated,
using for example one of the functions <CODE>mw_new_cimage</CODE>, 
<CODE>mw_alloc_cimage</CODE> or <CODE>mw_change_cimage</CODE>. 
After that, if the gray plane allocation is changed
(by e.g. <CODE>mw_change_cimage</CODE> or <CODE>mw_delete_cimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Needed Input of module (gray plane already allocated and filled) */
int x,y;      /* Needed Input of module */
unsigned char **tab;

tab =  mw_newtab_gray_cimage(image);
if (tab==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put white color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) tab[y][x] = 255;
else mwerror(ERROR,1,"Out of bounds !\n");

free(tab);

</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cimage mw_new_cimage();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Cimage </TT>structure with an empty gray plane.
No pixels can be addressed at this time.
The gray plane may be allocated using the function <CODE>mw_alloc_cimage</CODE> or
<CODE>mw_change_cimage</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_cimage</CODE>.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output movie.</P><P>The function <CODE>mw_new_cimage</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cimage()) == NULL) ||
      (mw_alloc_cimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_plot_cimage</FONT></B> - Set the gray level value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_plot_cimage(image, x, y, v)</P><P>Cimage image;</P><P>int x,y;</P><P>unsigned char v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function set the gray level value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>) to be <CODE>v</CODE> (a number between 0 - black - and 255 - white -).</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to write pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put white color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
        mw_plot_cimage(image,x,y,255);
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><!--TOC section Color Char Images-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc12">2.2</A>&#XA0;&#XA0;Color Char Images</H2><!--SEC END --><P><A NAME="images_color-char-images"></A></P><P>Use the <EM>Color Char Images</EM> memory type each time you want to process 
color images. As in the Char Images case, the use of this format instead of the
corresponding floating point format (<CODE>Cfimage</CODE>) is strongly recommended.</P><!--TOC subsection The structure Ccimage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">2.2.1</A>&#XA0;&#XA0;The structure Ccimage</H3><!--SEC END --><P>
<A NAME="images_color-char-images_structure"></A></P><P>
<A NAME="@default25"></A></P><P>Beginners should focus on the first five fields only of this structure. 
You should also consider the fields <CODE>previous</CODE> and <CODE>next</CODE> if your
image is part of a movie.
Some fields are not used at this time, such <CODE>firstcol</CODE> &#X2026;<CODE>lastrow</CODE>, but future modules may access to them.</P><PRE CLASS="verbatim">typedef struct ccimage {
  int nrow;        /* Number of rows (dy) */
  int ncol;        /* Number of columns (dx) */

  unsigned char *red;     /* The red level plane (may be NULL) */
  unsigned char *green;   /* The green level plane (may be NULL) */
  unsigned char *blue;    /* The blue level plane (may be NULL) */

  float scale;     /* Scale of the picture (should be 1 for original pict.) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the picture : */
  int firstcol;    /* index of the first col not affected by left side effect*/
  int lastcol;     /* index of the last col not affected by right side effect*/
  int firstrow;    /* index of the first row not aff. by upper side effect */  
  int lastrow;     /* index of the last row not aff. by lower side effect */  

  /* For use in Movies only */
  struct ccimage *previous; /* Pointer to the previous image (may be NULL) */
  struct ccimage *next; /* Pointer to the next image (may be NULL) */

} *Ccimage;

</PRE><P>Do not change by yourself the content of <CODE>nrow</CODE> and <CODE>ncol</CODE>: the size
of the image has to be modified using functions of the library only (see section&#XA0;<A HREF="#images_color-char-images_function">2.2.3</A> page&#XA0;<A HREF="#images_color-char-images_function">??</A>).</P><P>You can put <CODE>unsigned char</CODE> values in the arrays <CODE>red</CODE>, <CODE>green</CODE>,
<CODE>blue</CODE> at the expressed condition that you do not exceed the maximum value of the index,
given by ncol &#XD7; nrow &#X2212; 1.</P><P>Actually, everything works as for the <TT>Cimage </TT>structure (see section&#XA0;<A HREF="#images_char-images_structure">2.1.1</A> page&#XA0;<A HREF="#images_char-images_structure">??</A>) but you
have to deal with three planes instead of only one.
That is the proportion between each RGB component that will give you the
color. Notice that you can get more than 16 millions of different colors
(2<SUP>3 &#XD7; 8</SUP> exactly), so you need appropriate device to see or print
such image with fidelity.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">2.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="images_color-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"TIFFC"</CODE><A NAME="@default26"></A> Tag Image Format with three 8-bits color planes (24 bits color).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object. 
It has been developed by Sam Leffler and Silicon Graphics, Inc.
To use this format, you need the TIFF library (libtiff). See the Volume One, section 
&#X201C;Installation&#X201D;.
Output objects are created without compression.
</LI><LI CLASS="li-enumerate"><CODE>"PMC_C"</CODE><A NAME="@default27"></A> 
PM format with three 8-bits planes (24 bits color).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the University of Pennsylvania, USA.
</LI><LI CLASS="li-enumerate"><CODE>"BMPC"</CODE><A NAME="@default28"></A> Microsoft BMP 24-bits per pixel.
Output objects are created using Windows BMP format. Compression methods are not implemented.
</LI><LI CLASS="li-enumerate"><CODE>"PPM"</CODE><A NAME="@default29"></A> Portable pixmap format (24 bits color).
Only the "raw" PPM format is supported, the "plain" (ascii) one
being definitely too wasteful of space to record color images.
</LI><LI CLASS="li-enumerate"><CODE>"JFIFC"</CODE><A NAME="@default30"></A><A NAME="@default31"></A>
JPEG/JFIF format with three 8-bits planes (24 bits color).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the Independent JPEG Group&#X2019;s software.
To use this format, you need the JPEG library (libjpeg). See the Volume One, section 
&#X201C;Installation&#X201D;. 
The compression ratio is defined by the quality factor, which is an integer between 1 (worse) and 100 (best).
Default quality factor is 100. To change this value, add it as an option to the JFIFC type.
For example, JFIFC:50 means JFIFC file type with quality factor 50.
Whatever the quality factor, output objects are created with loosely compression.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">2.2.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="images_color-char-images_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Ccimage</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_ccimage</FONT></B> - Allocate the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccimage mw_alloc_ccimage(image,nrow,ncol)</P><P>Ccimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the RGB planes of a <TT>Ccimage </TT>structure previously
created using <CODE>mw_new_ccimage</CODE>. The size of the image is given by 
<CODE>nrow</CODE> (number of rows or maximum range of <I>y</I> plus one) and <CODE>ncol</CODE>
(number of columns or maximum range of <I>x</I> plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.</P><P>Do not use this function if <CODE>image</CODE> has already an allocated plane: use
the function <CODE>mw_change_ccimage</CODE> instead.</P><P>The function <CODE>mw_alloc_ccimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the RGB planes. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_ccimage()) == NULL) ||
      (mw_alloc_ccimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to white */
image_&gt;red[256] = image-&gt;green[256] = image-&gt;blue[256] = 255;
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccimage mw_change_ccimage(image, nrow, ncol)</P><P>Ccimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the RGB planes of a <TT>Ccimage </TT>structure, even if no previously memory allocation was done.
The new size of the image is given by <CODE>nrow</CODE> (number of rows or maximum 
range of <I>y</I> plus one) and <CODE>ncol</CODE> (number of columns or maximum range of 
<I>x</I> plus one). </P><P>It can also create the structure if the input <CODE>image = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_ccimage</CODE> and
<CODE>mw_alloc_ccimage</CODE>. It is the recommended function to set image 
dimension of input/output modules. 
Since the function can set the address of <CODE>image</CODE>, the variable must be set to the return value of the function (See example below).</P><P>The function <CODE>mw_change_ccimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the RGB planes. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cimage Output; /* Output of module */

Output = mw_change_ccimage(Output, 256, 256);
if (Output == NULL) mwerror(FATAL,1,"Not enough memory.\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_ccimage</FONT></B> - Clear the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_ccimage(image, r,g,b)</P><P>Ccimage image;</P><P>unsigned char r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the ccimage <CODE>image</CODE> with the color given by 
the triplet <CODE>r,g,b</CODE>: all pixels will have this RGB value.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Output of module */

image = mw_change_ccimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to blue */
mw_clear_ccimage(image,0,0,255);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_ccimage</FONT></B> - Copy the pixel values of color image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_ccimage(in, out)</P><P>Ccimage in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the RGB planes of the image <CODE>in</CODE> into 
the RGB planes of the image <CODE>out</CODE>.
The size of the two RGB planes must be the same.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Ccimage G; /* Needed Input */
Ccimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_ccimage(F, G-&gt;nrow, G-&gt;ncol)) == NULL)
     mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_ccimage(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_ccimage</FONT></B> - Deallocate the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_ccimage(image)</P><P>Ccimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the RGB planes of a <TT>Ccimage </TT>structure previously
allocated using <CODE>mw_alloc_ccimage</CODE> or <CODE>mw_change_ccimage</CODE>, and the
structure itself. </P><P>You should set <CODE>image = NULL</CODE> after this call since the address pointed
by <CODE>image</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_ccimage()) == NULL) ||
      (mw_alloc_ccimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_ccimage(image);
image = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_draw_ccimage</FONT></B> - Draw a line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_draw_ccimage(image, a0, b0, a1, b1, r, g, b)</P><P>Ccimage image;</P><P>int a0,b0,a1,b1;</P><P>unsigned char r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function draws in <CODE>image</CODE> a connected line between the pixel (<I>a</I>0,<I>b</I>0) and the pixel (<I>a</I>1,<I>b</I>1). The color of the line is defined by the triplet <CODE>r,g,b</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Output of module */

image = mw_change_ccimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to white */
mw_clear_ccimage(image,255,255,255);
/* Draw a red diagonal line */
mw_draw_ccimage(image,0,0,99,99,255,0,0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_getdot_ccimage</FONT></B> - Return the RGB value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_getdot_ccimage(image, x, y, r, g, b)</P><P>Ccimage image;</P><P>int x,y;</P><P>unsigned char *r,*g,*b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the RGB value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>).
The RGB value consists of the triplet <CODE>*r,*g,*b</CODE>: <CODE>*r</CODE> (a number between 0 and 255) gives you the proportion of red, <CODE>*g</CODE> the proportion of green and <CODE>*b</CODE> the proportion of blue.</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to read pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module */
int x,y;       /* Needed Inputs of module */
unsigned char r,g,b;  /* Internal use */

if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
  { 
    mw_getdot_ccimage(image,x,y,&amp;r,&amp;g,&amp;b);
    printf("image(%d,%d) = %d,%d,%d\n",x,y,(int)r,(int)g,(int)b);
  }
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_newtab_blue_ccimage</FONT></B> - Create a bi-dimensional tab for the blue pixels of a Ccimage</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char ** mw_newtab_blue_ccimage(image)</P><P>Ccimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; blue level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the blue plane of the given image.</P><P>This function must be called after the blue plane has been allocated,
using for example one of the functions <CODE>mw_new_ccimage</CODE>, 
<CODE>mw_alloc_ccimage</CODE> or <CODE>mw_change_ccimage</CODE>. 
After that, if the blue plane allocation is changed
(by e.g. <CODE>mw_change_ccimage</CODE> or <CODE>mw_delete_ccimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the blue value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Red and green pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_red_ccimage</CODE> and <CODE>mw_newtab_green_ccimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
unsigned char **red,**green,**blue;

red =  mw_newtab_red_ccimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_ccimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_ccimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put gray color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 127;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char ** mw_newtab_green_ccimage(image)</P><P>Ccimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; green level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the green plane of the given image.</P><P>This function must be called after the green plane has been allocated,
using for example one of the functions <CODE>mw_new_ccimage</CODE>, 
<CODE>mw_alloc_ccimage</CODE> or <CODE>mw_change_ccimage</CODE>. 
After that, if the green plane allocation is changed
(by e.g. <CODE>mw_change_ccimage</CODE> or <CODE>mw_delete_ccimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the green value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Red and blue pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_red_ccimage</CODE> and <CODE>mw_newtab_blue_ccimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
unsigned char **red,**green,**blue;

red =  mw_newtab_red_ccimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_ccimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_ccimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put gray color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 127;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char ** mw_newtab_red_ccimage(image)</P><P>Ccimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; red level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the red plane of the given image.</P><P>This function must be called after the red plane has been allocated,
using for example one of the functions <CODE>mw_new_ccimage</CODE>, 
<CODE>mw_alloc_ccimage</CODE> or <CODE>mw_change_ccimage</CODE>. 
After that, if the red plane allocation is changed
(by e.g. <CODE>mw_change_ccimage</CODE> or <CODE>mw_delete_ccimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the red value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Green and blue pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_green_ccimage</CODE> and <CODE>mw_newtab_blue_ccimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
unsigned char **red,**green,**blue;

red =  mw_newtab_red_ccimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_ccimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_ccimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put gray color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 127;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccimage mw_new_ccimage();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Ccimage </TT>structure with empty RGB planes.
No pixels can be addressed at this time.
The RGB planes may be allocated using the function <CODE>mw_alloc_ccimage</CODE> or
<CODE>mw_change_ccimage</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_ccimage</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_ccimage</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_ccimage()) == NULL) ||
      (mw_alloc_ccimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_plot_ccimage(image, x, y, r, g, b)</P><P>Ccimage image;</P><P>int x,y;</P><P>unsigned char r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function set the RGB value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>) to be the triplet <CODE>r,g,b</CODE>:
<CODE>r</CODE> (a number between 0 and 255) gives you the proportion of red, <CODE>g</CODE> the proportion of green and <CODE>b</CODE> the proportion of blue.</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to write pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put green color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
        mw_plot_ccimage(image,x,y,0,255,0);
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><!--TOC section Float Images-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc16">2.3</A>&#XA0;&#XA0;Float Images</H2><!--SEC END --><P><A NAME="images_float-images"></A>

<A NAME="@default32"></A></P><P>You may want to use this format when your algorithm process image computations
using floating point arithmetic (continuous scheme). 
You may also use this format to represent any kind of two-dimensional real data (such as matrix).</P><P>Notice that you may lose precision when you use such format as the input
of another module which requires integer representation (<TT>Cimage </TT>type), e.g.
printing or displaying devices.
In the other side, a module which accepts <TT>Fimage </TT>type as the input will also
work without degradation if you put a <TT>Cimage </TT>type instead.
It is so better to use, if possible, <TT>Cimage </TT>type for output variables and <TT>Fimage </TT>type for input.</P><!--TOC subsection The structure Fimage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">2.3.1</A>&#XA0;&#XA0;The structure Fimage</H3><!--SEC END --><P>
<A NAME="images_float-images_structure"></A></P><P>This memory type is exactly the same as <TT>Cimage </TT>(See section&#XA0;<A HREF="#images_char-images_structure">2.1.1</A> page&#XA0;<A HREF="#images_char-images_structure">??</A>): the only difference is about the <CODE>gray</CODE> field which is a pointer to floating points values.</P><P>Consequently, there is no formal correspondance between a gray level value
and a visual gray level (e.g. 255.0 may not represent &#X201C;white&#X201D;).</P><PRE CLASS="verbatim">typedef struct fimage {
  int nrow;        /* Number of rows (dy) */
  int ncol;        /* Number of columns (dx) */
  float *gray;     /* The Gray level plane (may be NULL) */

  float scale;     /* Scale of the picture (should be 1 for original pict.) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the picture : */
  int firstcol;    /* index of the first col not affected by left side effect*/
  int lastcol;     /* index of the last col not affected by right side effect*/
  int firstrow;    /* index of the first row not aff. by upper side effect */  
  int lastrow;     /* index of the last row not aff. by lower side effect */  

} *Fimage;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">2.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="images_float-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"RIM"</CODE><A NAME="@default33"></A> 
Original format defined by MegaWave1. 
It is close to the IMG format, but it uses a 32-bits plane in order to record floating point values.
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
</LI><LI CLASS="li-enumerate"><CODE>"PM_F"</CODE><A NAME="@default34"></A> 
PM format with one 32-bits plane (floating point gray levels).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc19">2.3.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="images_float-images_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Fimage</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_fimage</FONT></B> - Allocate the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fimage mw_alloc_fimage(image,nrow,ncol)</P><P>Fimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the gray plane of a <TT>Fimage </TT>structure previously
created using <CODE>mw_new_fimage</CODE>. The size of the image is given by 
<CODE>nrow</CODE> (number of rows or maximum range of <I>y</I> plus one) and <CODE>ncol</CODE>
(number of columns or maximum range of <I>x</I> plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.</P><P>Do not use this function if <CODE>image</CODE> has already an allocated plane: use
the function <CODE>mw_change_fimage</CODE> instead.</P><P>The function <CODE>mw_alloc_fimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to the value -1.0 */
image-&gt;gray[256] = -1.0;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_fimage</FONT></B> - Change the size of the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fimage mw_change_fimage(image, nrow, ncol)</P><P>Fimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the gray plane of a <TT>Fimage </TT>structure, even if no previously memory allocation was done.
The new size of the image is given by <CODE>nrow</CODE> (number of rows or maximum 
range of <I>y</I> plus one) and <CODE>ncol</CODE> (number of columns or maximum range of 
<I>x</I> plus one). </P><P>It can also create the structure if the input <CODE>image = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_fimage</CODE> and
<CODE>mw_alloc_fimage</CODE>. It is the recommended function to set image 
dimension of input/output modules. Since the function can set the 
address of <CODE>image</CODE>, the variable must be set to the return value of 
the function (See example below).</P><P>The function <CODE>mw_change_fimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage u; 

/* Usage when &lt;u&gt; IS NOT an output of the module (and has not been
   previously allocated): the function returns a new structure's address
*/
u = mw_change_fimage(NULL, 256, 256);

/* Usage when &lt;u&gt; IS an output of the module (or has been previously
   allocated): DO NOT change the structure's address
*/
u = mw_change_fimage(u, 256, 256);

if (u == NULL) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_fimage</FONT></B> - Clear the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_fimage(image, v)</P><P>Fimage image;</P><P>float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the fimage <CODE>image</CODE> with the gray value given by <I>v</I>:
all pixels will have the gray level <I>v</I>. </P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Output of module */

image = mw_change_fimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to 0.0 */
mw_clear_fimage(image,0.0);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_fimage</FONT></B> - Copy the pixel values of an image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_fimage(in, out)</P><P>Fimage in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the gray plane of the image <CODE>in</CODE> into 
the gray plane of the image <CODE>out</CODE>.
The size of the two gray planes must be the same.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Fimage G; /* Needed Input */
Fimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_fimage(F, G-&gt;nrow, G-&gt;ncol)) == NULL)
 mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_fimage(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_fimage</FONT></B> - Deallocate the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_fimage(image)</P><P>Fimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the gray plane of a <TT>Fimage </TT>structure previously
allocated using <CODE>mw_alloc_fimage</CODE> or <CODE>mw_change_fimage</CODE>, and the
structure itself. </P><P>You should set <CODE>image = NULL</CODE> after this call since the address pointed
by <CODE>image</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_fimage(image);
image = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_draw_fimage</FONT></B> - Draw a line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_draw_fimage(image, a0, b0, a1, b1, c)</P><P>Fimage image;</P><P>int a0,b0,a1,b1;
float c;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function draws in <CODE>image</CODE> a connected line of gray level <I>c</I> between the pixel (<I>a</I>0,<I>b</I>0) and the pixel (<I>a</I>1,<I>b</I>1).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Output of module */

image = mw_change_fimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Clear all pixels */
mw_clear_fimage(image,0.0);
/* Draw a diagonal line of gray level 1.0 */
mw_draw_fimage(image,0,0,99,99,1.0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_getdot_fimage</FONT></B> - Return the gray level value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
float mw_getdot_fimage(image, x, y)</P><P>Fimage image;</P><P>int x,y;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the gray level value (any floating point number) of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>).</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value. See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to read pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
 printf("image(%d,%d) = %f\n",x,y,mw_getdot_fimage(image,x,y));
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_newtab_gray_fimage</FONT></B> - Create a bi-dimensional tab for the pixels of a Fimage</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
float ** mw_newtab_gray_fimage(image)</P><P>Fimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; gray level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the gray plane of the given image.</P><P>This function must be called after the gray plane has been allocated,
using for example one of the functions <CODE>mw_new_fimage</CODE>, 
<CODE>mw_alloc_fimage</CODE> or <CODE>mw_change_fimage</CODE>. 
After that, if the gray plane allocation is changed
(by e.g. <CODE>mw_change_fimage</CODE> or <CODE>mw_delete_fimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using<CODE>tab[y][x]</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Needed Input of module (gray plane already allocated and filled) */
int x,y;      /* Needed Input of module */
float **tab;

tab =  mw_newtab_gray_fimage(image);
if (tab==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put 0 in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) tab[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(tab);

</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fimage mw_new_fimage();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Fimage </TT>structure with an empty gray plane.
No pixels can be addressed at this time.
The gray plane may be allocated using the function <CODE>mw_alloc_fimage</CODE> or
<CODE>mw_change_fimage</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_fimage</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_fimage</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_plot_fimage</FONT></B> - Set the gray level value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_plot_fimage(image, x, y, v)</P><P>Fimage image;</P><P>int x,y;</P><P>float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function set the gray level value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>) to be <CODE>v</CODE> (any floating point number).</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to write pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put 0.0 in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
        mw_plot_fimage(image,x,y,0.0);
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><!--TOC section Color Float Images-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc20">2.4</A>&#XA0;&#XA0;Color Float Images</H2><!--SEC END --><P><A NAME="images_color-float-images"></A></P><P>You may want to use this format when you need to process color images with
floating point precision (continuous scheme). 
Please notice that this format wastes a lot of memory and computational
time. </P><!--TOC subsection The structure Cfimage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc21">2.4.1</A>&#XA0;&#XA0;The structure Cfimage</H3><!--SEC END --><P>
<A NAME="images_color-float-images_structure"></A></P><P>
<A NAME="@default35"></A></P><P>This memory type is not exactly the same as <TT>Ccimage </TT>(See section&#XA0;<A HREF="#images_color-char-images_structure">2.2.1</A> page&#XA0;<A HREF="#images_color-char-images_structure">??</A>): the difference is not
only about the RGB fields which are pointers to floating points values and not to unsigned
char, but also about the <EM>color model</EM>. A color model<A NAME="@default36"></A> is a specification of a 
3D-coordinate system and a subspace within that system where each color is represented by
a single point. 
Whatever the color model, a cfimage is alway made by three planes called <CODE>red</CODE>, 
<CODE>green</CODE> and <CODE>blue</CODE>. The significance of those planes is given by the value
of the <CODE>model</CODE> field. The first plane <CODE>red</CODE> matches the first letter of
the model&#X2019;s name (e.g. R for RGB model, H for HSI model), the second plane <CODE>green</CODE> 
matches the second letter of the model&#X2019;s name (e.g. G for RGB model, S for HSI model),
and the third plane <CODE>blue</CODE> matches the third letter (e.g. B for RGB model, I for HSI 
model).</P><P>The implemented color models are 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>MODEL_RGB</TT> <A NAME="@default37"></A>Cartesian coordinate system Red, Green, Blue. 
</LI><LI CLASS="li-itemize"><TT>MODEL_YUV</TT> <A NAME="@default38"></A> YUV coordinate system (CCIR 601-1).
</LI><LI CLASS="li-itemize"><TT>MODEL_HSI</TT> <A NAME="@default39"></A> HSI coordinate system (H is Hue, S is Saturation and I is Intensity
or luminance). 
</LI><LI CLASS="li-itemize"><TT>MODEL_HSV</TT> <A NAME="@default40"></A> HSV coordinate system (H is Hue, S is Saturation and V is Value).
</LI></UL><P>Be aware that a MegaWave2 module which takes a cfimage in input performs a statement
likely to work for one color model only. One should checks the value of the <CODE>model</CODE> 
field before any statement.</P><PRE CLASS="verbatim">typedef struct cfimage {
  int nrow;        /* Number of rows (dy) */
  int ncol;        /* Number of columns (dx) */
  int model;       /* Model of the colorimetric system */

  float *red;      /* The Red plane if model=MODEL_RGB (may be NULL) or Y/H   */
  float *green;    /* The Green plane if model=MODEL_RGB (may be NULL) or U/S */
  float *blue;     /* The Blue plane if model=MODEL_RGB (may be NULL) or V/I  */

  float scale;     /* Scale of the picture (should be 1 for original pict.) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the picture : */
  int firstcol;    /* index of the first col not affected by left side effect*/
  int lastcol;     /* index of the last col not affected by right side effect*/
  int firstrow;    /* index of the first row not aff. by upper side effect */  
  int lastrow;     /* index of the last row not aff. by lower side effect */  

} *Cfimage;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">2.4.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="images_color-float-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<A NAME="@default41"></A> 
PM format with three 8-bits planes, each plane being of float values.
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the University of Pennsylvania, USA.
An extension has been performed to record the <CODE>model</CODE> value.
In the case of RGB model, the format is exactly the same as the original.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">2.4.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="images_color-float-images_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Cfimage</CODE> type. The list is in alphabetical order.
Conversion between memory models are not implemented as functions of
the system library, but as modules (see volume three: &#X201C;MegaWave2 user modules library&#X201D;). </P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_cfimage</FONT></B> - Allocate the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfimage mw_alloc_cfimage(image,nrow,ncol)</P><P>Cfimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the RGB planes of a <TT>Cfimage </TT>structure previously
created using <CODE>mw_new_cfimage</CODE>. The size of the image is given by 
<CODE>nrow</CODE> (number of rows or maximum range of <I>y</I> plus one) and <CODE>ncol</CODE>
(number of columns or maximum range of <I>x</I> plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.</P><P>Do not use this function if <CODE>image</CODE> has already an allocated plane: use
the function <CODE>mw_change_cfimage</CODE> instead.</P><P>The function <CODE>mw_alloc_cfimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the RGB planes. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cfimage()) == NULL) ||
      (mw_alloc_cfimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to (0.0,0.0,0.0) */
image_&gt;red[256] = image-&gt;green[256] = image-&gt;blue[256] = 0.0;
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfimage mw_change_cfimage(image, nrow, ncol)</P><P>Cfimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the RGB planes of a <TT>Cfimage </TT>structure, even if no previously memory allocation was done.
The new size of the image is given by <CODE>nrow</CODE> (number of rows or maximum 
range of <I>y</I> plus one) and <CODE>ncol</CODE> (number of columns or maximum range of 
<I>x</I> plus one). </P><P>It can also create the structure if the input <CODE>image = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_cfimage</CODE> and
<CODE>mw_alloc_cfimage</CODE>. It is the recommended function to set image 
dimension of input/output modules. 
Since the function can set the address of <CODE>image</CODE>, the variable must be set to the return value of the function (See example below).</P><P>The function <CODE>mw_change_cfimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the RGB planes. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cimage Output; /* Output of module */

Output = mw_change_cfimage(Output, 256, 256);
if (Output == NULL) mwerror(FATAL,1,"Not enough memory.\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_cfimage</FONT></B> - Clear the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_cfimage(image, r,g,b)</P><P>Cfimage image;</P><P>float r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the cfimage <CODE>image</CODE> with the color given by 
the triplet <CODE>r,g,b</CODE>: all pixels will have this RGB value.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Output of module */

image = mw_change_cfimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to (0.0,0.0,1.0) */
mw_clear_cfimage(image,0.0,0.0,1.0);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_cfimage</FONT></B> - Copy the pixel values of color image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_cfimage(in, out)</P><P>Cfimage in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the RGB planes of the image <CODE>in</CODE> into 
the RGB planes of the image <CODE>out</CODE>.
The size of the two RGB planes must be the same.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cfimage G; /* Needed Input */
Cfimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_cfimage(F, G-&gt;nrow, G-&gt;ncol)) == NULL)
 mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_cfimage(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_cfimage</FONT></B> - Deallocate the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_cfimage(image)</P><P>Cfimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the RGB planes of a <TT>Cfimage </TT>structure previously
allocated using <CODE>mw_alloc_cfimage</CODE> or <CODE>mw_change_cfimage</CODE>, and the
structure itself. </P><P>You should set <CODE>image = NULL</CODE> after this call since the address pointed
by <CODE>image</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cfimage()) == NULL) ||
      (mw_alloc_cfimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_cfimage(image);
image = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_draw_cfimage</FONT></B> - Draw a line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_draw_cfimage(image, a0, b0, a1, b1, r, g, b)</P><P>Cfimage image;</P><P>int a0,b0,a1,b1;</P><P>float r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function draws in <CODE>image</CODE> a connected line between the pixel (<I>a</I>0,<I>b</I>0) and the pixel (<I>a</I>1,<I>b</I>1). The color of the line is defined by the triplet <CODE>r,g,b</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Output of module */

image = mw_change_cfimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to (0.0,0.0,0.0) */
mw_clear_cfimage(image,0.0,0.0,0.0);
/* Draw a diagonal line with color (1.0,0.0,0.0) */
mw_draw_cfimage(image,0,0,99,99,1.0,0.0,0.0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_getdot_cfimage</FONT></B> - Return the RGB value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_getdot_cfimage(image, x, y, r, g, b)</P><P>Cfimage image;</P><P>int x,y;</P><P>float *r,*g,*b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the RGB value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>).
The RGB value consists of the triplet <CODE>*r,*g,*b</CODE>: <CODE>*r</CODE> (any floating point number) gives you the proportion of red, <CODE>*g</CODE> the proportion of green and <CODE>*b</CODE> the proportion of blue.</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to read pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module */
int x,y;       /* Needed Inputs of module */
float r,g,b;   /* Internal use */

if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
  { 
    mw_getdot_cfimage(image,x,y,&amp;r,&amp;g,&amp;b);
    printf("image(%d,%d) = %d,%d,%d\n",x,y,r,g,b);
  }
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_newtab_blue_cfimage</FONT></B> - Create a bi-dimensional tab for the blue pixels of a Cfimage</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
float ** mw_newtab_blue_cfimage(image)</P><P>Cfimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; blue level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the blue plane of the given image.</P><P>This function must be called after the blue plane has been allocated,
using for example one of the functions <CODE>mw_new_cfimage</CODE>, 
<CODE>mw_alloc_cfimage</CODE> or <CODE>mw_change_cfimage</CODE>. 
After that, if the blue plane allocation is changed
(by e.g. <CODE>mw_change_cfimage</CODE> or <CODE>mw_delete_cfimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the blue value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Red and green pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_red_cfimage</CODE> and <CODE>mw_newtab_green_cfimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
float **red,**green,**blue;

red =  mw_newtab_red_cfimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_cfimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_cfimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put black color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
float ** mw_newtab_green_cfimage(image)</P><P>Cfimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; green level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the green plane of the given image.</P><P>This function must be called after the green plane has been allocated,
using for example one of the functions <CODE>mw_new_cfimage</CODE>, 
<CODE>mw_alloc_cfimage</CODE> or <CODE>mw_change_cfimage</CODE>. 
After that, if the green plane allocation is changed
(by e.g. <CODE>mw_change_cfimage</CODE> or <CODE>mw_delete_cfimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the green value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Red and blue pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_red_cfimage</CODE> and <CODE>mw_newtab_blue_cfimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
float **red,**green,**blue;

red =  mw_newtab_red_cfimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_cfimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_cfimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put black color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
float ** mw_newtab_red_cfimage(image)</P><P>Cfimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; red level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the red plane of the given image.</P><P>This function must be called after the red plane has been allocated,
using for example one of the functions <CODE>mw_new_cfimage</CODE>, 
<CODE>mw_alloc_cfimage</CODE> or <CODE>mw_change_cfimage</CODE>. 
After that, if the red plane allocation is changed
(by e.g. <CODE>mw_change_cfimage</CODE> or <CODE>mw_delete_cfimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the red value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Green and blue pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_green_cfimage</CODE> and <CODE>mw_newtab_blue_cfimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
float **red,**green,**blue;

red =  mw_newtab_red_cfimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_cfimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_cfimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put black color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfimage mw_new_cfimage();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Cfimage </TT>structure with empty RGB planes.
No pixels can be addressed at this time.
The RGB planes may be allocated using the function <CODE>mw_alloc_cfimage</CODE> or
<CODE>mw_change_cfimage</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_cfimage</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_cfimage</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cfimage()) == NULL) ||
      (mw_alloc_cfimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_plot_cfimage</FONT></B> - Set the RGB value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_plot_cfimage(image, x, y, r, g, b)</P><P>Cfimage image;</P><P>int x,y;</P><P>float r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function set the RGB value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>) to be the triplet <CODE>r,g,b</CODE>:
<CODE>r</CODE> (a floating point number) gives you the proportion of red, <CODE>g</CODE> the proportion of green and <CODE>b</CODE> the proportion of blue.</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to write pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put color (0.0,0.0,0.0) in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
        mw_plot_cfimage(image,x,y,0.0,0.0,0.0);
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><!--TOC chapter Movies-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc24">Chapter&#XA0;3</A>&#XA0;&#XA0;Movies</H1><!--SEC END --><P>
<A NAME="movies"></A>
</P><P>A movie<A NAME="@default42"></A> is a succession of images. In MegaWave2, it is implemented as a
chain of images: you may notice that all types of images have the 
fields <CODE>previous</CODE> and <CODE>next</CODE>(see section&#XA0;<A HREF="#images">2</A>). 
Normally set to <TT>NULL</TT>, these fields point to the previous image and
to the next image respectively, when the image is part of a movie.
The first image of the movie has a <TT>NULL</TT><CODE>previous</CODE> field and the
last image of the movie has a <TT>NULL</TT><CODE>next</CODE> field.</P><P>A movie structure is basically a pointer to the first image.
For each image structure corresponds a movie structure.</P><!--TOC section Char movies-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc25">3.1</A>&#XA0;&#XA0;Char movies</H2><!--SEC END --><P><A NAME="movies_char-movies"></A>

<A NAME="@default43"></A></P><P>The <EM>Char Movie</EM> memory type corresponds to movies where each images
are of the <TT>Cimage </TT>memory type. 
The use of this memory type is strongly recommended, since other movies types
waste a lot of memory and computational time.</P><!--TOC subsection The structure Cmovie-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">3.1.1</A>&#XA0;&#XA0;The structure Cmovie</H3><!--SEC END --><P>
<A NAME="movies_char-movies_structure"></A></P><P>Beginners should only focus on the field <CODE>first</CODE> of this structure:
if <CODE>movie</CODE> is of <TT>Cmovie </TT>type, then <CODE>movie-&gt;first</CODE> is of <TT>Cimage </TT>type and it is the first image of the movie; <CODE>movie-&gt;first-&gt;next</CODE> is
the second image, etc.</P><PRE CLASS="verbatim">typedef struct cmovie {
  float scale;     /* Scale (time-domain) of the movie (should be 1) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  Cimage first;    /* Pointer to the first image */
} *Cmovie;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">3.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="movies_char-file_type"></A></P><P>The way MegaWave2 records movies is the following:
each image is recorded in a separate file, using one of the external types available for the corresponding type Cimage (see section&#XA0;<A HREF="#images_char-file_type">2.1.2</A> for more information).
Let suppose that the external name of the movie object is <CODE>movie</CODE>.
Then, MegaWave2 creates a MegaWave2 Data Ascii file named <CODE>movie</CODE> with a <CODE>def Cmovie</CODE> area.
In this area is listed the name of the image files, following the order given by the sequence of images.
By changing the order of two file names, you change the order of the images in the sequence (i.e. the name of
the file is not meaningful by itself, for example the image file name <CODE>movie_002</CODE> may not be the second
image of the sequence).
There is no limitation for the number of images, up to the available memory.</P><P>Note: there is an old format, which is still recognized for backward compatibility. 
Is this old format, the file name <CODE>movie</CODE> is empty and the name of each image file is meaningful
(e.g. <CODE>movie_002</CODE> is always the second image of the sequence).
In that case, no more than 999 images per movie can be recorded.</P><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">3.1.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="movies_char-movies_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Cmovie</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_cmovie</FONT></B> - Define the movie structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cmovie mw_change_cmovie(movie)</P><P>Cmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a movie structure if the input <CODE>movie = NULL</CODE>.
It is provided despite the <CODE>mw_new_cmovie</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_cmovie</CODE> returns <TT>NULL</TT> if not enough memory is available to define the structure. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cmovie movie=NULL; /* Internal use: no Input neither Output of module */

movie = mw_change_cmovie(movie);
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_cmovie</CODE> function).
</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_cmovie</FONT></B> - Deallocate all the movie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_cmovie(movie)</P><P>Cmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory used by a <TT>Cmovie </TT>structure:
it deallocates the gray plane of all images, the image structures and
the movie structure itself.</P><P>You should set <CODE>movie = NULL</CODE> after this call since the address pointed
by <CODE>movie</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the <CODE>mw_new_cmovie</CODE> function: when a memory allocation
fails for <CODE>mw_change_cimage</CODE>, all the previously memory allocations are
freed by the call to <CODE>mw_delete_cmovie(movie)</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_cmovie</FONT></B> - Create a new Cmovie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cmovie mw_new_cmovie();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Cmovie </TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Create a movie with 10 images of size (100,100) */

Cmovie movie;  /* Internal use: no Input neither Output of module */
Cimage image,image_prev; /* Internal use */

movie = mw_new_cmovie();
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
for (l=1;l&lt;=10;l++)
 {
   if ((image = mw_change_cimage(NULL,100,100)) == NULL)
    {
      mw_delete_cmovie(movie);
      mwerror(FATAL,1,"Not enough memory.");
    }
    if (l == 1) movie-&gt;first = image;
    else
      {
        image_prev-&gt;next = image;
        image-&gt;previous = image_prev;
       }
     image_prev = image;
 }
</PRE><!--TOC section Color Char movies-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">3.2</A>&#XA0;&#XA0;Color Char movies</H2><!--SEC END --><P><A NAME="movies_color-char-movies"></A>

<A NAME="@default44"></A></P><P>The <EM>Color Char Movie</EM> memory type corresponds to movies where each images
are of the <TT>Ccimage </TT>memory type. 
Use this memory type each time you have to process color movies.
As in the Char Movies case, the use of this format instead of the corresponding floating point format (<CODE>Cfmovie</CODE>) is strongly recommended.</P><!--TOC subsection The structure Ccmovie-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">3.2.1</A>&#XA0;&#XA0;The structure Ccmovie</H3><!--SEC END --><P>
<A NAME="movies_color-char-movies_structure"></A></P><P>Beginners should focus on the field <CODE>first</CODE> only of this structure:
if <CODE>movie</CODE> is of <TT>Ccmovie </TT>type, then <CODE>movie-&gt;first</CODE> is of <TT>Ccimage </TT>type and it is the first image of the movie; <CODE>movie-&gt;first-&gt;next</CODE> is
the second image, etc.</P><PRE CLASS="verbatim">typedef struct ccmovie {
  float scale;     /* Scale (time-domain) of the movie (should be 1) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  Ccimage first;    /* Pointer to the first image */
} *Ccmovie;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">3.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="movies_color-char-file_type"></A></P><P>The way MegaWave2 records movies is the following:
each image is recorded in a separate file, using one of the external types available for the corresponding type Ccimage (see section&#XA0;<A HREF="#images_color-file_type">2.2.2</A> for more information).
Let suppose that the external name of the movie object is <CODE>movie</CODE>.
Then, MegaWave2 creates a MegaWave2 Data Ascii file named <CODE>movie</CODE> with a <CODE>def CCmovie</CODE> area.
In this area is listed the name of the image files, following the order given by the sequence of images.
By changing the order of two file names, you change the order of the images in the sequence (i.e. the name of
the file is not meaningful by itself, for example the image file name <CODE>movie_002</CODE> may not be the second
image of the sequence).
There is no limitation for the number of images, up to the available memory.</P><P>Note: there is an old format, which is still recognized for backward compatibility. 
Is this old format, the file name <CODE>movie</CODE> is empty and the name of each image file is meaningful
(e.g. <CODE>movie_002</CODE> is always the second image of the sequence).
In that case, no more than 999 images per movie can be recorded.</P><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc32">3.2.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="movies_color-char-movies_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Ccmovie</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_ccmovie</FONT></B> - Define the movie structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccmovie mw_change_ccmovie(movie)</P><P>Ccmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a movie structure if the input <CODE>movie = NULL</CODE>.
It is provided despite the <CODE>mw_new_ccmovie</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_ccmovie</CODE> returns <TT>NULL</TT> if not enough memory is available to define the structure. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Ccmovie movie=NULL; /* Internal use: no Input neither Output of module */

movie = mw_change_ccmovie(movie);
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_ccmovie</CODE> function).
</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_ccmovie</FONT></B> - Deallocate all the movie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_ccmovie(movie)</P><P>Ccmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory used by a <TT>Ccmovie </TT>structure:
it deallocates the color planes of all images, the image structures and
the movie structure itself.</P><P>You should set <CODE>movie = NULL</CODE> after this call since the address pointed
by <CODE>movie</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the <CODE>mw_new_ccmovie</CODE> function: when a memory allocation
fails for <CODE>mw_change_ccimage</CODE>, all the previously memory allocations are
freed by the call to <CODE>mw_delete_ccmovie(movie)</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_ccmovie</FONT></B> - Create a new Ccmovie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccmovie mw_new_ccmovie();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Ccmovie </TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Create a movie with 10 images of size (100,100) */

Ccmovie movie;  /* Internal use: no Input neither Output of module */
Ccimage image,image_prev; /* Internal use */

movie = mw_new_ccmovie();
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
for (l=1;l&lt;=10;l++)
 {
   if ((image = mw_change_ccimage(NULL,100,100)) == NULL)
    {
      mw_delete_ccmovie(movie);
      mwerror(FATAL,1,"Not enough memory.");
    }
    if (l == 1) movie-&gt;first = image;
    else
      {
        image_prev-&gt;next = image;
        image-&gt;previous = image_prev;
       }
     image_prev = image;
 }
</PRE><!--TOC section Float movies-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc33">3.3</A>&#XA0;&#XA0;Float movies</H2><!--SEC END --><P><A NAME="movies_float-movies"></A>

<A NAME="@default45"></A></P><P>The <EM>Float Movie</EM> memory type corresponds to movies where each images
are of the <TT>Fimage </TT>memory type. 
The use of this memory type is discouraged, since it wastes a lot of memory and computational time.
Use it when you must process data using floating point arithmetic, and when 
you cannot lose precision by converting the output to integer values.</P><!--TOC subsection The structure Fmovie-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">3.3.1</A>&#XA0;&#XA0;The structure Fmovie</H3><!--SEC END --><P>
<A NAME="movies_float-movies_structure"></A></P><P>Beginners should focus on the field <CODE>first</CODE> only of this structure:
if <CODE>movie</CODE> is of <TT>Fmovie </TT>type, then <CODE>movie-&gt;first</CODE> is of <TT>Fimage </TT>type and it is the first image of the movie; <CODE>movie-&gt;first-&gt;next</CODE> is
the second image, etc.</P><PRE CLASS="verbatim">typedef struct fmovie {
  float scale;     /* Scale (time-domain) of the movie (should be 1) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  Fimage first;    /* Pointer to the first image */
} *Fmovie;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc35">3.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="movies_float-file_type"></A></P><P>The way MegaWave2 records movies is the following:
each image is recorded in a separate file, using one of the external types available for the corresponding type Fimage (see section&#XA0;<A HREF="#images_float-file_type">2.3.2</A> for more information).
Let suppose that the external name of the movie object is <CODE>movie</CODE>.
Then, MegaWave2 creates a MegaWave2 Data Ascii file named <CODE>movie</CODE> with a <CODE>def Fmovie</CODE> area.
In this area is listed the name of the image files, following the order given by the sequence of images.
By changing the order of two file names, you change the order of the images in the sequence (i.e. the name of
the file is not meaningful by itself, for example the image file name <CODE>movie_002</CODE> may not be the second
image of the sequence).
There is no limitation for the number of images, up to the available memory.</P><P>Note: there is an old format, which is still recognized for backward compatibility. 
Is this old format, the file name <CODE>movie</CODE> is empty and the name of each image file is meaningful
(e.g. <CODE>movie_002</CODE> is always the second image of the sequence).
In that case, no more than 999 images per movie can be recorded.</P><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">3.3.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="movies_float-movies_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Fmovie</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_fmovie</FONT></B> - Define the movie structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fmovie mw_change_fmovie(movie)</P><P>Fmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a movie structure if the input <CODE>movie = NULL</CODE>.
It is provided despite the <CODE>mw_new_fmovie</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_fmovie</CODE> returns <TT>NULL</TT> if not enough memory is available to define the structure. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Fmovie movie=NULL; /* Internal use: no Input neither Output of module */

movie = mw_change_fmovie(movie);
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_fmovie</CODE> function).
</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_fmovie</FONT></B> - Deallocate all the movie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_fmovie(movie)</P><P>Fmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory used by a <TT>Fmovie </TT>structure:
it deallocates the gray plane of all images, the image structures and
the movie structure itself.</P><P>You should set <CODE>movie = NULL</CODE> after this call since the address pointed
by <CODE>movie</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the <CODE>mw_new_fmovie</CODE> function: when a memory allocation
fails for <CODE>mw_change_fimage</CODE>, all the previously memory allocations are
freed by the call to <CODE>mw_delete_fmovie(movie)</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_fmovie</FONT></B> - Create a new Fmovie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fmovie mw_new_fmovie();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Fmovie </TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Create a movie with 10 images of size (100,100) */

Fmovie movie;  /* Internal use: no Input neither Output of module */
Fimage image,image_prev; /* Internal use */

movie = mw_new_fmovie();
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
for (l=1;l&lt;=10;l++)
 {
   if ((image = mw_change_fimage(NULL,100,100)) == NULL)
    {
      mw_delete_fmovie(movie);
      mwerror(FATAL,1,"Not enough memory.");
    }
    if (l == 1) movie-&gt;first = image;
    else
      {
        image_prev-&gt;next = image;
        image-&gt;previous = image_prev;
       }
     image_prev = image;
 }
</PRE><!--TOC section Color Float movies-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">3.4</A>&#XA0;&#XA0;Color Float movies</H2><!--SEC END --><P><A NAME="movies_color-float-movies"></A>

<A NAME="@default46"></A></P><P>The <EM>Color Float Movie</EM> memory type corresponds to movies where each images are of the <TT>Cfimage </TT>memory type. 
The use of this memory type is discouraged, since it wastes a lot of memory and computational time.
Use it when you must process data using floating point arithmetic, and when 
you cannot lose precision by converting the output to integer values.</P><!--TOC subsection The structure Cfmovie-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">3.4.1</A>&#XA0;&#XA0;The structure Cfmovie</H3><!--SEC END --><P>
<A NAME="movies_color-float-movies_structure"></A></P><P>Beginners should focus on the field <CODE>first</CODE> only of this structure:
if <CODE>movie</CODE> is of <TT>Cfmovie </TT>type, then <CODE>movie-&gt;first</CODE> is of <TT>Cfimage </TT>type and it is the first image of the movie; <CODE>movie-&gt;first-&gt;next</CODE> is
the second image, etc.</P><PRE CLASS="verbatim">typedef struct cfmovie {
  float scale;     /* Scale (time-domain) of the movie (should be 1) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  Cfimage first;    /* Pointer to the first image */
} *Cfmovie;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">3.4.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="movies_color-float-file_type"></A></P><P>The way MegaWave2 records movies is the following:
each image is recorded in a separate file, using one of the external types available for the corresponding type Cfimage (see section&#XA0;<A HREF="#images_color-float-file_type">2.4.2</A> for more information).
Let suppose that the external name of the movie object is <CODE>movie</CODE>.
Then, MegaWave2 creates a MegaWave2 Data Ascii file named <CODE>movie</CODE> with a <CODE>def Cfmovie</CODE> area.
In this area is listed the name of the image files, following the order given by the sequence of images.
By changing the order of two file names, you change the order of the images in the sequence (i.e. the name of
the file is not meaningful by itself, for example the image file name <CODE>movie_002</CODE> may not be the second
image of the sequence).
There is no limitation for the number of images, up to the available memory.</P><P>Note: there is an old format, which is still recognized for backward compatibility. 
Is this old format, the file name <CODE>movie</CODE> is empty and the name of each image file is meaningful
(e.g. <CODE>movie_002</CODE> is always the second image of the sequence).
In that case, no more than 999 images per movie can be recorded.</P><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">3.4.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="movies_color-float-movies_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Cfmovie</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_cfmovie</FONT></B> - Define the movie structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfmovie mw_change_cfmovie(movie)</P><P>Cfmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a movie structure if the input <CODE>movie = NULL</CODE>.
It is provided despite the <CODE>mw_new_cfmovie</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_cfmovie</CODE> returns <TT>NULL</TT> if not enough memory is available to define the structure. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cfmovie movie=NULL; /* Internal use: no Input neither Output of module */

movie = mw_change_cfmovie(movie);
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_cfmovie</CODE> function).
</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_cfmovie</FONT></B> - Deallocate all the movie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_cfmovie(movie)</P><P>Cfmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory used by a <TT>Cfmovie </TT>structure:
it deallocates the color planes of all images, the image structures and
the movie structure itself.</P><P>You should set <CODE>movie = NULL</CODE> after this call since the address pointed
by <CODE>movie</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the <CODE>mw_new_cfmovie</CODE> function: when a memory allocation
fails for <CODE>mw_change_cfimage</CODE>, all the previously memory allocations are
freed by the call to <CODE>mw_delete_cfmovie(movie)</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_cfmovie</FONT></B> - Create a new Cfmovie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfmovie mw_new_cfmovie();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Cfmovie </TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Create a movie with 10 images of size (100,100) */

Cfmovie movie;  /* Internal use: no Input neither Output of module */
Cfimage image,image_prev; /* Internal use */

movie = mw_new_cfmovie();
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
for (l=1;l&lt;=10;l++)
 {
   if ((image = mw_change_cfimage(NULL,100,100)) == NULL)
    {
      mw_delete_cfmovie(movie);
      mwerror(FATAL,1,"Not enough memory.");
    }
    if (l == 1) movie-&gt;first = image;
    else
      {
        image_prev-&gt;next = image;
        image-&gt;previous = image_prev;
       }
     image_prev = image;
 }
</PRE><!--TOC chapter Signals-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc41">Chapter&#XA0;4</A>&#XA0;&#XA0;Signals</H1><!--SEC END --><P>
<A NAME="signals"></A>
</P><P>We call signal<A NAME="@default47"></A> a one-dimensional sequence of scalars. 
Signals may be used to represent various kind of physical data (such
as sound) , as well as mathematical data (e.g. impulse response of filters, 
vectors, &#X2026;).</P><P>Notice that at this time, only signals of floating points values are
implemented.</P><!--TOC section Float signals-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc42">4.1</A>&#XA0;&#XA0;Float signals</H2><!--SEC END --><P><A NAME="signals_float-signals"></A>

<A NAME="@default48"></A></P><P>The <EM>Float Signals</EM> memory type is used to represent one-dimensional 
sequences of floating points values.</P><!--TOC subsection The structure Fsignal-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">4.1.1</A>&#XA0;&#XA0;The structure Fsignal</H3><!--SEC END --><P>
<A NAME="signals_float-signals_structure"></A></P><P>Beginners should only focus on the first two fields of this structure:
</P><PRE CLASS="verbatim">typedef struct fsignal {
  int size;        /* Number of samples */
  float *values;   /* The samples */

  float scale;     /* Scale of the signal */
  float shift;     /* shifting of the signal with respect to zero */
  float gain;      /* Gain of the signal given by the digitalization process */
  float sgrate;    /* Sampling rate given by the digitalization process */
  int bpsample;    /* Number of bits per sample for audio drivers */

  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the signal : */
  int firstp;     /* index of the first point not aff. by left side effect */
  int lastp;      /* index of the last point not aff. by right side effect */
  float param;    /* distance between two succesive uncorrelated points */

} *Fsignal;
</PRE><P>The field <CODE>size</CODE> gives the number of samples loaded in the signal.
Do not change by yourself the content of this field: the size of the signal
has to be modified using functions of the library only 
(see section&#XA0;<A HREF="#signals_float-signals_function">4.1.3</A> page&#XA0;<A HREF="#signals_float-signals_function">??</A>).</P><P>The field <CODE>values</CODE> is an array which gives the value of each sample:
if <CODE>signal</CODE> is a variable of <TT>Fsignal</TT> type, <CODE>signal-&gt;values[0]</CODE>
is the first sample of the signal, <CODE>signal-&gt;values[1]</CODE> the second,
and so one up to the last sample <CODE>signal-&gt;values[signal-&gt;size-1]</CODE>.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc44">4.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="signals_float-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_FSIGNAL"</CODE><A NAME="@default49"></A> 
MegaWave2 Data Ascii format with a <CODE>def fsignal</CODE> area.
This area includes the value of the different fields of the object, as
<CODE>comments, scale, shift, ...</CODE> and at the end the samples of the signal.
Since this format uses Ascii encoding, you may read or modify the file just by
editing it using a text editor.
It can also be plotted using the standard tool <TT>gnuplot</TT>.</LI><LI CLASS="li-enumerate"><CODE>"WAVE_PCM"</CODE><A NAME="@default50"></A> 
Microsoft&#X2019;s RIFF WAVE sound file format with PCM encoding.
Use this format to perform sound<A NAME="@default51"></A> and 
speech<A NAME="@default52"></A> processing with MegaWave2.
Stereo inputs are converted to mono when loaded into a <TT>Fsignal</TT>.
Since this format performs bit-encoding, on any output <TT>Fsignal</TT> variables
you should set the field <CODE>bpsample</CODE> to the number of bits you want the
data to be saved. Default value is 8 &#XD7; <CODE>sizeof(float)</CODE> (on most
architectures 32), because this matches the size of the samples in the
<TT>Fsignal</TT> structure. 
However, this value leads to strange results on some audio drivers. 
If you plan to send the
signal on a audio driver<A NAME="@default53"></A>, 
recommended numbers of bits are 16 (signed word) 
or 8 (signed char). Take care to format your data to fit the corresponding 
range before playing the file ([&#X2212;32768,+32767] for signed word and 
[&#X2212;128,+127] for signed char) or you will not get the expected sound.
Another important field to get the right result is <CODE>sgrate</CODE>, where you
have to set the sample rate in Hz that is, the number of samples per second.</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc45">4.1.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="signals_float-signals_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Fsignal</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_fsignal</FONT></B> - Allocate the array of values</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fsignal mw_alloc_fsignal(signal,n)</P><P>Fsignal signal;</P><P>int n;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the array <CODE>values</CODE> of a <TT>Fsignal</TT> structure previously created using <CODE>mw_new_fsignal</CODE>. The size of the signal is given by 
<CODE>n</CODE>, it corresponds to the number of samples.</P><P>Values can be addressed after this call, if the allocation successed. There is
no default values.</P><P>Do not use this function if <CODE>signal</CODE> has already an allocated array: use
the function <CODE>mw_change_fsignal</CODE> instead.</P><P>The function <CODE>mw_alloc_fsignal</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the array. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fsignal signal=NULL; /* Internal use: no Input neither Output of module */
int i;

/* Create a signal with 1000 samples */
if  ( ((signal = mw_new_fsignal()) == NULL) ||
      (mw_alloc_fsignal(signal,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set the sample #i to the value i */
for (i=0;i&lt;signal-&gt;size;i++) signal-&gt;values[i] = i;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_fsignal</FONT></B> - Change the size of the array of values</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fsignal mw_change_fsignal(signal, n)</P><P>Fsignal signal;</P><P>int n;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the array <CODE>values</CODE> of a <TT>Fsignal</TT> structure, even if no previously memory allocation was done.
The new size of the signal is given by <CODE>n</CODE>, it corresponds to the number of samples.</P><P>The function <CODE>mw_change_fsignal</CODE> can also create the structure if the input <CODE>signal = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_fsignal</CODE> and
<CODE>mw_alloc_fsignal</CODE>. It is the recommended function to set signal 
size of input/output modules. Since the function can set the 
address of <CODE>signal</CODE>, the variable must be set to the return value of 
the function (See example below).</P><P>The function <CODE>mw_change_fsignal</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the array. 
Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fsignal u; 

/* Usage when &lt;u&gt; IS NOT an output of the module (and has not been
   previously allocated): the function returns a new structure's address
*/
u = mw_change_fsignal(NULL, 1000);

/* Usage when &lt;u&gt; IS an output of the module (or has been previously
   allocated): DO NOT change the structure's address
*/
u = mw_change_fsignal(u, 1000);

if (u == NULL) mwerror(FATAL,1,"Not enough memory.\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_fsignal</FONT></B> - Clear all values</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_fsignal(signal, v)</P><P>Fsignal signal;</P><P>float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the fsignal <CODE>signal</CODE> with the value given by <I>v</I>:
all samples will have the value <I>v</I>. </P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fsignal signal; /* Output of module */

signal = mw_change_fsignal(signal, 1000);
if (signal == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all samples to 0.0 */
mw_clear_fsignal(signal,0.0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_fsignal_header</FONT></B> - Copy the header of a signal into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_fsignal_header(in, out)</P><P>Fsignal in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the header of the signal <CODE>in</CODE> into the header of the signal <CODE>out</CODE>, but the size-related fields. The size of the two signals may be different
(this includes the case where size of <CODE>out</CODE> is null).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Fsignal G; /* Needed Input */
Fsignal F; /* Optional Output */

  if (F) 
    {
    printf("F option is active: copy header of G into F\n");
    mw_copy_fsignal_header(G, F);
     }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_fsignal</FONT></B> - Copy a signal into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_fsignal(in, out)</P><P>Fsignal in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the header and the content of the array <CODE>values</CODE> of the signal <CODE>in</CODE> into the corresponding fields of the signal <CODE>out</CODE>.
The size of the two signals must be the same (this implies the <CODE>out</CODE> signal to
be allocated).</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Fsignal G; /* Needed Input */
Fsignal F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_fsignal(F, G-&gt;size)) == NULL)
        mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_fsignal(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_fsignal_values</FONT></B> - Copy the values of a signal into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_fsignal_values(in, out)</P><P>Fsignal in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the array <CODE>values</CODE> of the signal <CODE>in</CODE> into the array <CODE>values</CODE> of the signal <CODE>out</CODE>.
The size of the two signals must be the same (this implies the <CODE>out</CODE> signal to
be allocated).</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Fsignal G; /* Needed Input */
Fsignal F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_fsignal(F, G-&gt;size)) == NULL)
        mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_fsignal_values(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_fsignal</FONT></B> - Deallocate the signal</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_fsignal(signal)</P><P>Fsignal signal;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the array <CODE>values</CODE> of a <TT>Fsignal</TT> structure previously allocated using <CODE>mw_alloc_fsignal</CODE> or <CODE>mw_change_fsignal</CODE>, and the structure itself. </P><P>You should set <CODE>signal = NULL</CODE> after this call since the address pointed
by <CODE>signal</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fsignal signal=NULL; /* Internal use: no Input neither Output of module */

if  ( ((signal = mw_new_fsignal()) == NULL) ||
      (mw_alloc_fsignal(signal,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_fsignal(signal);
signal = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_fsignal</FONT></B> - Create a new Fsignal</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fsignal mw_new_fsignal();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Fsignal</TT> structure with an empty array <CODE>values</CODE>.
No samples can be addressed at this time.
The array <CODE>values</CODE> should be allocated using the function <CODE>mw_alloc_fsignal</CODE> or <CODE>mw_change_fsignal</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_fsignal</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_fsignal</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fsignal signal=NULL; /* Internal use: no Input neither Output of module */

if  ( ((signal = mw_new_fsignal()) == NULL) ||
      (mw_alloc_fsignal(signal,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><!--TOC chapter Wavelets-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc46">Chapter&#XA0;5</A>&#XA0;&#XA0;Wavelets</H1><!--SEC END --><P>
<A NAME="wavelets"></A>
</P><P>The wavelet<A NAME="@default54"></A> memory types are used to represent the result of a wavelet 
transform applied to some data. 
The data can be a signal, in this case the operation is called a one-dimensional wavelet tranform, or it can be an image. 
In that case, the operation is called a two-dimensional wavelet transform.
Operations on data of higher dimension are not supported at this time.</P><P>A wavelet transform<A NAME="@default55"></A> is a time-scale operator: it adds therefore one dimension 
to the data (the scale).
The meaning of the wavelet coefficients recorded into a wavelet-type variable depends to the choice of the discretization.
The finest one is known as the <EM>continuous wavelet transform</EM><A NAME="@default56"></A>: several
voices per octave can be computed for the scale. 
The <EM>orthogonal (or biorthogonal) wavelet transform</EM><A NAME="@default57"></A>
<A NAME="@default58"></A> allows to decompose
the data into an orthogonal (or biorthogonal) basis: a wavelet coefficient
corresponds to a scalar product. In this case, only one voice per octave
is computed and a decimation is achieved on the time (or space) domain.
The <EM>dyadic wavelet transform</EM><A NAME="@default59"></A> computes also only one voice per octave, but
without decimation along the time axis. It corresponds to a decomposition into wavelets
which generate a <EM>frame</EM><A NAME="@default60"></A>. It is often used to obtain a translation-invariant representation, 
from which the <EM>wavelet maxima representation</EM><A NAME="@default61"></A> can be deduced.</P><P>A natural extension to wavelet decomposition is the wavelet packet<A NAME="@default62"></A> representation,
that offers a better localization in the frequency space.
Wavelet packets are popular for at least two reasons: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
they provide a sparse representation of many texture;
</LI><LI CLASS="li-itemize">they are generally well localized in the Fourier domain. 
</LI></UL><!--TOC section One-dimensional wavelet-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc47">5.1</A>&#XA0;&#XA0;One-dimensional wavelet</H2><!--SEC END --><P><A NAME="wavelets_wtrans1d"></A></P><P>The <EM>One-dimensional wavelet</EM><A NAME="@default63"></A> memory type is used to represent the result
of a wavelet transform applied to a signal.</P><!--TOC subsection The structure Wtrans1d-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">5.1.1</A>&#XA0;&#XA0;The structure Wtrans1d</H3><!--SEC END --><P>
<A NAME="wavelets_wtrans1d_structure"></A></P><P>
<A NAME="@default64"></A></P><P>The C structure is the following:
</P><PRE CLASS="verbatim">typedef struct wtrans1d {
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the wtrans1d */

  int type;  /* Type of the wtrans1d performed */
  int edges; /* Type of the edges statments */
  char filter_name[mw_namesize][mw_max_nfilter_1d];   /* Filters used */
  int size; /* Size of the original signal */

  int nlevel;   /* Number of levels (octave) for this decomposition */
  int nvoice;   /* Number of voices per octave for this decomposition */
  int complex;  /* 1 if the wavelet is complex that is, if P[][] is used */
  int nfilter;  /* Number of filters used to compute the decomposition */

  Fsignal A[mw_max_nlevel+1][mw_max_nvoice]; /* Average or low-pass signals */
  Fsignal AP[mw_max_nlevel+1][mw_max_nvoice];/* Phase of the average */
  Fsignal D[mw_max_nlevel+1][mw_max_nvoice]; /* Detail or wavelet coefficients*/
  Fsignal DP[mw_max_nlevel+1][mw_max_nvoice];/* Phase of the Detail */

} *Wtrans1d;
</PRE><P>The first two fields of this structure is well known by the reader.
The field <CODE>type</CODE> records the type of the wavelet transform used.
Its value can be:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mw_orthogonal</CODE> : orthogonal wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_biorthogonal</CODE> : biorthogonal wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_dyadic</CODE> : dyadic wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_continuous</CODE> : continuous wavelet transform.
</LI></UL><P>The field <CODE>edges</CODE> gives the type of the edges statment used to compute
the transformation. Indeed, since it is implemented as a bank of convolution
products, errors occur near the borders if no special statment is performed.
This field can have the following values:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mw_edges_zeropad</CODE> : the signal is zero-padded (no special statment);
</LI><LI CLASS="li-itemize"><CODE>mw_edges_periodic</CODE> : the signal is made periodic;
</LI><LI CLASS="li-itemize"><CODE>mw_edges_mirror</CODE> : the signal is padded by mirror effect (avoid first-order discontinuities);
</LI><LI CLASS="li-itemize"><CODE>mw_edges_wadapted</CODE> : special border functions are added to the wavelets (wavelets on the interval).
</LI></UL><P>The field <CODE>filter_name</CODE> is an array of strings, where the names of the filters used for the decomposition are put. 
The number of filters is put into the field <CODE>nfilter</CODE>.
This number and the meaning of each filter depend to the wavelet type.</P><P>The field <CODE>size</CODE> contains the size of the original signal, which is put
into <CODE>average[0][0]</CODE> (see below).
The field <CODE>nlevel</CODE> is the number of levels used in this decomposition; it corresponds to the number of octaves; <CODE>nvoice</CODE> is the number of voices per octave.
The field <CODE>complex</CODE> is set to 1 when the wavelet used has complex values, 0 elsewhere.</P><P>The result of the wavelet decomposition is put into two two-dimensional arrays of signals called <CODE>A</CODE> and <CODE>D</CODE>:
<CODE>A[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT> and for
<I>v</I>=0 &#X2026; nvoice&#X2212;1 is the low-pass signal at the octave <I>l</I> and at the voice <I>v</I>, that is the signal at the scale 2<SUP>(<I>l</I>+<I>v</I>/<TT>nvoice</TT>)</SUP>.
The signal <CODE>A[0][0]</CODE> is the original signal, <CODE>A[0][1]</CODE> is the
smoothed signal at the scale 2<SUP>1/<TT>nvoice</TT></SUP>, etc.
<CODE>D[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT> and for
<I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 is the band-pass (or detail) signal at the octave <I>l</I> and at the voice <I>v</I>, that is the wavelet coefficients signal at the scale 2<SUP>(<I>l</I>+<I>v</I>/<TT>nvoice</TT>)</SUP>.
The signal <CODE>D[0][0]</CODE> is unused.</P><P>When the wavelet is complex, the fields <CODE>A</CODE> and <CODE>D</CODE> represent the
modulus values only; the phase values is put in the fields <CODE>AP</CODE> and
<CODE>DP</CODE>.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc49">5.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="wavelets_wtrans1d-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_WTRANS1D"</CODE><A NAME="@default65"></A> MegaWave2 Data Ascii format with a <CODE>def Wtrans1d</CODE> area.
This area includes the value of the different fields of the object, as
<CODE>comments, type, edges, ...</CODE>. 
The values of the wavelet coefficients are not recorded in this file, but in 
a set of <CODE>Fimage</CODE> objects.
Let be <CODE>wavelet</CODE> the name of the object. 
The names of these image files are, for <CODE>&lt;j&gt;</CODE> the level number (octave)
and <CODE>&lt;v&gt;</CODE> the voice number,
<UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>wavelet_&lt;j&gt;_A.wtrans1d</CODE> Average field of the object (voice 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;.&lt;v&gt;_A.wtrans1d</CODE> Average field of the object (voice &gt; 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;_AP.wtrans1d</CODE> Phase of the Average field of the object (voice 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;.&lt;v&gt;_AP.wtrans1d</CODE> Phase of the Average field of the object (voice &gt; 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;_D.wtrans1d</CODE> Detail field of the object (voice 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;.&lt;v&gt;_D.wtrans1d</CODE> Detail field of the object (voice &gt; 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;_DP.wtrans1d</CODE> Phase of the Detail field of the object (voice 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;.&lt;v&gt;_DP.wtrans1d</CODE> Phase of the Detail field of the object (voice &gt; 0).
</LI></UL>
Notice that, regarding to the type of the wavelet transform, only a subset of those files may be generated.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc50">5.1.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="wavelets_wtrans1d_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Wtrans1d</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_biortho_wtrans1d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_biortho_wtrans1d(wtrans,level,size)</P><P>Wtrans1d wtrans;</P><P>int level; </P><P>int size; </P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the arrays <CODE>A</CODE> and <CODE>D</CODE> of a <TT>Wtrans1d </TT>structure previously created using <CODE>mw_new_wtrans1d</CODE>, in order to receive
an biorthonormal wavelet representation (one voice per octave, decimation along the time axis).
Each signal <CODE>A[l][v]</CODE> and <CODE>D[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT>, <I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 ((<I>l</I>,<I>v</I>) &#X2260; (0,0)) is created and
allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original signal is given by <CODE>size</CODE>.</P><P>The arrays <CODE>A</CODE> and <CODE>D</CODE> can be addressed after this call, if the allocation successed. There is no default values for the signals.
The <CODE>type</CODE> field of the <TT>Wtrans1d </TT>structure is set to <CODE>mw_biorthogonal</CODE>.</P><P>The function <CODE>mw_alloc_biortho_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the signals. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans1d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d Output; /* optional Output of the module */
Fsignal Signal;  /* needed Input of the module: original signal */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_biortho_wtrans1d(Output, 8, Signal-&gt;size)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;A[0][0] = Signal;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_continuous_wtrans1d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_continuous_wtrans1d(wtrans,level,voice,size,complex)</P><P>Wtrans1d wtrans;</P><P>int level; </P><P>int voice;</P><P>int size; </P><P>int complex;</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the arrays <CODE>D</CODE> of a <TT>Wtrans1d </TT>structure previously created using <CODE>mw_new_wtrans1d</CODE>, in order to receive
an continuous wavelet representation (several voices per octave, no decimation along the time axis, wavelet with complex or real values).
The arrays <CODE>DP</CODE> are allocated if <CODE>complex</CODE> is set to 1.
Each signal <CODE>D[l][v]</CODE> (and <CODE>DP[l][v]</CODE> in the complex case) for <I>l</I>=0 &#X2026; <TT>nlevel</TT>, <I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 ((<I>l</I>,<I>v</I>) &#X2260; (0,0)) is created and
allocated to the right size.
Previously allocations are deleted, if any.
Notice that, at this time, there is no function to allocate a continuous wavelet transform recording the low-pass signals (<CODE>A</CODE> and <CODE>AP</CODE>).</P><P>The number of levels for the decomposition is given by <CODE>level</CODE>, the number of voice per octave is given by <CODE>voice</CODE> and the size of the original signal is given by <CODE>size</CODE>.</P><P>The arrays <CODE>D</CODE> and <CODE>DP</CODE> can be addressed after this call, if the allocation successed. There is no default values for the signals.
The <CODE>type</CODE> field of the <TT>Wtrans1d </TT>structure is set to <CODE>mw_continuous</CODE>.</P><P>The function <CODE>mw_alloc_continuous_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the signals. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans1d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d Output; /* optional Output of the module */
Fsignal Signal;  /* needed Input of the module: original signal */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition
                        and 10 voices per octave, complex wavelet.
   */
  if(mw_alloc_continuous_wtrans1d(Output, 8, 10, Signal-&gt;size,1)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_dyadic_wtrans1d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_dyadic_wtrans1d(wtrans,level,size)</P><P>Wtrans1d wtrans;</P><P>int level; </P><P>int size; </P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the arrays <CODE>A</CODE> and <CODE>D</CODE> of a <TT>Wtrans1d </TT>structure previously created using <CODE>mw_new_wtrans1d</CODE>, in order to receive
an dyadic wavelet representation (one voice per octave, no decimation along the time axis).
Each signal <CODE>A[l][v]</CODE> and <CODE>D[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT>, <I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 ((<I>l</I>,<I>v</I>) &#X2260; (0,0)) is created and
allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original signal is given by <CODE>size</CODE>.</P><P>The arrays <CODE>A</CODE> and <CODE>D</CODE> can be addressed after this call, if the allocation successed. There is no default values for the signals.
The <CODE>type</CODE> field of the <TT>Wtrans1d </TT>structure is set to <CODE>mw_dyadic</CODE>.</P><P>The function <CODE>mw_alloc_dyadic_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the signals. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans1d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d Output; /* optional Output of the module */
Fsignal Signal;  /* needed Input of the module: original signal */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_dyadic_wtrans1d(Output, 8, Signal-&gt;size)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;A[0][0] = Signal;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_ortho_wtrans1d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_ortho_wtrans1d(wtrans,level,size)</P><P>Wtrans1d wtrans;</P><P>int level; </P><P>int size; </P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the arrays <CODE>A</CODE> and <CODE>D</CODE> of a <TT>Wtrans1d </TT>structure previously created using <CODE>mw_new_wtrans1d</CODE>, in order to receive
an orthonormal wavelet representation (one voice per octave, decimation along the time axis).
Each signal <CODE>A[l][v]</CODE> and <CODE>D[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT>, <I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 ((<I>l</I>,<I>v</I>) &#X2260; (0,0)) is created and
allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original signal is given by <CODE>size</CODE>.</P><P>The arrays <CODE>A</CODE> and <CODE>D</CODE> can be addressed after this call, if the allocation successed. There is no default values for the signals.
The <CODE>type</CODE> field of the <TT>Wtrans1d </TT>structure is set to <CODE>mw_orthogonal</CODE>.</P><P>The function <CODE>mw_alloc_ortho_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the signals. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans1d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d Output; /* optional Output of the module */
Fsignal Signal;  /* needed Input of the module: original signal */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_ortho_wtrans1d(Output, 8, Signal-&gt;size)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;A[0][0] = Signal;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_wtrans1d</FONT></B> - Deallocate the wavelet transform space</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_wtrans1d(wtrans)</P><P>Wtrans1d wtrans;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the memory used by the wavelet transform space <CODE>wtrans</CODE> that is, all the memory used by the arrays of signals <CODE>A</CODE>, <CODE>AP</CODE>, <CODE>D</CODE>, <CODE>DP</CODE> (if any), and the structure itself. </P><P>You should set <CODE>wtrans = NULL</CODE> after this call since the address pointed
by <CODE>wtrans</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d wtrans=NULL; /* Internal use: no Input neither Output of module */

if  ( ((wtrans = mw_new_wtrans1d()) == NULL) ||  
       (mw_alloc_ortho_wtrans1d(wtrans, 8, 1024)==NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_wtrans1d(wtrans);
wtrans = NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_wtrans1d</FONT></B> - Create a new Wtrans1d</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wtrans1d mw_new_wtrans1d();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Wtrans1d </TT>structure with empty arrays of signals <CODE>A</CODE>, <CODE>AP</CODE>, <CODE>D</CODE>, <CODE>DP</CODE>.
No signal can be addressed at this time.
The arrays of signals should be allocated using one of the functions <CODE>mw_alloc_X_wtrans1d</CODE> where <CODE>X</CODE> depends of the type of the transformation.</P><P>You don&#X2019;t need this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). 
This function is used to create internal variables.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d wtrans=NULL; /* Internal use: no Input neither Output of module */

if  ( ((wtrans = mw_new_wtrans1d()) == NULL) ||  
       (mw_alloc_continuous_wtrans1d(wtrans, 8, 10, 1024)) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><!--TOC section Two-dimensional wavelet-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">5.2</A>&#XA0;&#XA0;Two-dimensional wavelet</H2><!--SEC END --><P><A NAME="wavelets_wtrans2d"></A></P><P>The <EM>Two-dimensional wavelet</EM><A NAME="@default66"></A> memory type is used to represent the result
of a wavelet transform applied to an image.
Notice that, at this time, the structure does not allow to record more than
one voice per octave for the decomposition.
Consequently, the continuous wavelet transform is not available in the 2D case.
The wavelet is also assumed to be of real values (complex case not supported).</P><!--TOC subsection The structure Wtrans2d-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc52">5.2.1</A>&#XA0;&#XA0;The structure Wtrans2d</H3><!--SEC END --><P>
<A NAME="wavelets_wtrans2d_structure"></A></P><P>
<A NAME="@default67"></A></P><P>The C structure is the following:
</P><PRE CLASS="verbatim">typedef struct wtrans2d {
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the wtrans2d */

  int type;  /* Type of the wtrans2d performed */
  int edges; /* Type of the edges statments */
  char filter_name[mw_namesize][mw_max_nfilter_2d];   /* Filters used */

  int nrow;
  int ncol;     /* Size of the original image */
  int nlevel;   /* Number of levels (octave) for this decomposition */
  int norient;  /* Number of orientations for this decomposition */
  int nfilter;  /* Number of filters used to compute the decomposition */

  Fimage images[mw_max_nlevel+1][mw_max_norient+1]; /* Wavelet decomposition space */

} *Wtrans2d;
</PRE><P>The first two fields of this structure is well known by the reader.
The field <CODE>type</CODE> records the type of the wavelet transform used.
Its value can be:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mw_orthogonal</CODE> : orthogonal wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_biorthogonal</CODE> : biorthogonal wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_dyadic</CODE> : dyadic wavelet transform.
</LI></UL><P>The field <CODE>edges</CODE> gives the type of the edges statment used to compute
the transformation. Indeed, since it is implemented as a bank of convolution
products, errors occur near the borders if no special statment is performed.
This field can have the following values:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mw_edges_zeropad</CODE> : the image is zero-padded (no special statment);
</LI><LI CLASS="li-itemize"><CODE>mw_edges_periodic</CODE> : the image is made periodic;
</LI><LI CLASS="li-itemize"><CODE>mw_edges_mirror</CODE> : the image is padded by mirror effect (avoid first-order discontinuities);
</LI><LI CLASS="li-itemize"><CODE>mw_edges_wadapted</CODE> : special border functions are added to the wavelets (wavelets on the rectangle).
</LI></UL><P>The field <CODE>filter_name</CODE> is an array of strings, where the names of the filters used for the decomposition are put. 
The number of filters is put into the field <CODE>nfilter</CODE>.
This number and the meaning of each filter depend to the wavelet type.</P><P>The fields <CODE>nrow</CODE> (number of rows) and <CODE>ncol</CODE> (number of columns) contain the size of the original image, which is put into <CODE>images[0][0]</CODE> (see below).
The field <CODE>nlevel</CODE> is the number of levels used in this decomposition; it corresponds to the number of octaves.</P><P>The field <CODE>norient</CODE> gives the number of orientations used for the decomposition;
usually (but the user may modify that) the first orientation (index <I>r</I>=0 in the array <CODE>images[][r]</CODE>) corresponds to the coarse image at the given resolution (low-pass image or smooth image);
the second orientation (index <I>r</I>=1) corresponds to the detail image (wavelet coefficients) along the y direction (horizontal details);
the third orientation (index <I>r</I>=2) corresponds to the detail image (wavelet coefficients) along the x direction (vertical details);
in the orthonormal and biorthonormal cases, there is another direction (index <I>r</I>=3) which corresponds to the detail image (wavelet coefficients) along the diagonal direction (cross details).</P><P>The result of the wavelet decomposition is put into one two-dimensional arrays of images called <CODE>images</CODE>:
<CODE>images[l][r]</CODE> for <I>l</I>=1 &#X2026; <TT>nlevel</TT> and for
<I>r</I>=0 &#X2026; <TT>norient</TT> is the coarse or the detail image at the octave <I>l</I> and at the orientation <I>r</I>.</P><P>Notice that the images <CODE>images[0][r]</CODE> are unused except for <I>r</I>=0.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc53">5.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="wavelets_wtrans2d-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_WTRANS2D"</CODE><A NAME="@default68"></A> MegaWave2 Data Ascii format with a <CODE>def Wtrans2d</CODE> area.
This area includes the value of the different fields of the object, as
<CODE>comments, type, edges, ...</CODE>. 
The values of the wavelet coefficients are not recorded in this file, but in 
a set of <CODE>Fimage</CODE> objects.
Let be <CODE>wavelet</CODE> the name of the object. 
The names of these image files are, for <CODE>&lt;j&gt;</CODE> the level number (octave)
and <CODE>&lt;r&gt;</CODE> the orientation number,
<UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>wavelet_&lt;j&gt;_S.wtrans2d</CODE> Average image of the object (<CODE>&lt;r&gt;</CODE> = 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;_D&lt;r&gt;.wtrans2d</CODE> Detail image of the object (<CODE>&lt;r&gt;</CODE> &gt; 0).
</LI></UL>
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">5.2.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="wavelets_wtrans2d_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Wtrans2d</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_biortho_wtrans2d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_biortho_wtrans2d(wtrans,level,nrow,ncol)</P><P>Wtrans2d wtrans;</P><P>int level; </P><P>int nrow,ncol; 
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the array <CODE>images</CODE> of a <TT>Wtrans2d </TT>structure previously created using <CODE>mw_new_wtrans2d</CODE>, in order to receive
an biorthonormal wavelet representation (spatial decimation, <CODE>norient</CODE> =3).
Each image <CODE>images[l][r]</CODE> for <I>l</I>=1 &#X2026; <TT>nlevel</TT>, <I>r</I>=0 &#X2026; <TT>norient</TT> is created and allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original image is given by <CODE>nrow</CODE> (number of rows), <CODE>ncol</CODE> (number of columns).</P><P>The array <CODE>images</CODE> can be addressed after this call, if the allocation successed. There is no default values for the images.
The <CODE>type</CODE> field of the <TT>Wtrans2d </TT>structure is set to <CODE>mw_biorthogonal</CODE>.</P><P>The function <CODE>mw_alloc_biortho_wtrans2d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the images. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans2d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d Output; /* optional Output of the module */
Fimage Image;    /* needed Input of the module: original image */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_biortho_wtrans2d(Output, 8, Image-&gt;nrow, Image-&gt;ncol)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;images[0][0] = Image;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_dyadic_wtrans2d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_dyadic_wtrans2d(wtrans,level,nrow,ncol)</P><P>Wtrans2d wtrans;</P><P>int level; </P><P>int nrow,ncol; 
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the array <CODE>images</CODE> of a <TT>Wtrans2d </TT>structure previously created using <CODE>mw_new_wtrans2d</CODE>, in order to receive
an dyadic wavelet representation (no spatial decimation, <CODE>norient</CODE> =2).
Each image <CODE>images[l][r]</CODE> for <I>l</I>=1 &#X2026; <TT>nlevel</TT>, <I>r</I>=0 &#X2026; <TT>norient</TT> is created and allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original image is given by <CODE>nrow</CODE> (number of rows), <CODE>ncol</CODE> (number of columns).</P><P>The array <CODE>images</CODE> can be addressed after this call, if the allocation successed. There is no default values for the images.
The <CODE>type</CODE> field of the <TT>Wtrans2d </TT>structure is set to <CODE>mw_dyadic</CODE>.</P><P>The function <CODE>mw_alloc_dyadic_wtrans2d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the images. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans2d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d Output; /* optional Output of the module */
Fimage Image;    /* needed Input of the module: original image */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_dyadic_wtrans2d(Output, 8, Image-&gt;nrow, Image-&gt;ncol)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;images[0][0] = Image;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_ortho_wtrans2d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_ortho_wtrans2d(wtrans,level,nrow,ncol)</P><P>Wtrans2d wtrans;</P><P>int level; </P><P>int nrow,ncol; 
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the array <CODE>images</CODE> of a <TT>Wtrans2d </TT>structure previously created using <CODE>mw_new_wtrans2d</CODE>, in order to receive
an orthonormal wavelet representation (spatial decimation, <CODE>norient</CODE> =3).
Each image <CODE>images[l][r]</CODE> for <I>l</I>=1 &#X2026; <TT>nlevel</TT>, <I>r</I>=0 &#X2026; <TT>norient</TT> is created and allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original image is given by <CODE>nrow</CODE> (number of rows), <CODE>ncol</CODE> (number of columns).</P><P>The array <CODE>images</CODE> can be addressed after this call, if the allocation successed. There is no default values for the images.
The <CODE>type</CODE> field of the <TT>Wtrans2d </TT>structure is set to <CODE>mw_orthogonal</CODE>.</P><P>The function <CODE>mw_alloc_ortho_wtrans2d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the images. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans2d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d Output; /* optional Output of the module */
Fimage Image;    /* needed Input of the module: original image */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_ortho_wtrans2d(Output, 8, Image-&gt;nrow, Image-&gt;ncol)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;images[0][0] = Image;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_wtrans2d</FONT></B> - Deallocate the wavelet transform space</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_wtrans2d(wtrans)</P><P>Wtrans2d wtrans;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the memory used by the wavelet transform space <CODE>wtrans</CODE> that is, all the memory used by the array of images <CODE>images</CODE> (if any), and the structure itself. </P><P>You should set <CODE>wtrans = NULL</CODE> after this call since the address pointed
by <CODE>wtrans</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d wtrans=NULL; /* Internal use: no Input neither Output of module */

if  ( ((wtrans = mw_new_wtrans2d()) == NULL) ||  
       (mw_alloc_ortho_wtrans2d(wtrans, 6, 512, 512)==NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_wtrans2d(wtrans);
wtrans = NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_wtrans2d</FONT></B> - Create a new Wtrans2d</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wtrans2d mw_new_wtrans2d();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Wtrans2d </TT>structure with empty array of images <CODE>images</CODE>.
No image can be addressed at this time.
The array of images should be allocated using one of the functions <CODE>mw_alloc_X_wtrans2d</CODE> where <CODE>X</CODE> depends of the type of the transformation.</P><P>You don&#X2019;t need this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). 
This function is used to create internal variables.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_wtrans2d</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d wtrans=NULL; /* Internal use: no Input neither Output of module */

if  ( ((wtrans = mw_new_wtrans2d()) == NULL) ||  
       (mw_alloc_dyadic_wtrans2d(wtrans, 6, 512, 512)) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><!--TOC section Two-dimensional wavelet packets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc55">5.3</A>&#XA0;&#XA0;Two-dimensional wavelet packets</H2><!--SEC END --><P><A NAME="wavelets_wpack2d"></A></P><P>The <EM>Two-dimensional wavelet packages</EM><A NAME="@default69"></A> memory type is used to represent the result
of a wavelet packets transform applied to a gray-levels image.
The wavelet packet basis is described by a quad-tree<A NAME="@default70"></A>
(for simplicity, we will just say a tree<A NAME="@default71"></A>) and a signal (or a pair of signals for biorthogonal wavelet packets). 
The wavelet packet transform of a <CODE>Fimage</CODE> contains the coordinates of the image in the wavelet packet basis
(if the size of this image is not a power of 2, some redundancy might be introduced).</P><!--TOC subsection The structure Wpack2d-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc56">5.3.1</A>&#XA0;&#XA0;The structure Wpack2d</H3><!--SEC END --><P>
<A NAME="wavelets_wpack2d_structure"></A></P><P>
<A NAME="@default72"></A></P><P>The C structure is the following:
</P><PRE CLASS="verbatim">typedef struct wpack2d {
  char cmt[mw_cmtsize];    /* Comments */
  char name[mw_namesize]; /* Name of the wpack2d */

  Fsignal signal1;    /* Impulse response of the filter 'h'*/
  Fsignal signal2;    /* Imp. resp. of the dual filter, for biortho. wavelet packet*/
  int level;          /* Decomposition level (calculated) */
  Cimage tree;        /* Decomposition tree */
  Fimage *images;     /* Array for output images (containing the wavelet packet coefficients) */
 
  int img_array_size; /* Number of elements in *images */
   
  int img_ncol; /*number of colums in the image before the decomposition*/
  int img_nrow; /*number of rows in the image before the decomposition*/

  struct wpack2d *previous; /* Pointer to the previous wpack2d (may be NULL) */ 
  struct wpack2d *next;     /* Pointer to the previous wpack2d (may be NULL) */
} *Wpack2d;
</PRE><P>The fields of this structure should not be modified manually, but trough
functions of the system library only.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc57">5.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="wavelets_wpack2d-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_WPACK2D"</CODE><A NAME="@default73"></A> MegaWave2 Data Ascii format with a <CODE>def Wpack2d</CODE> area.
This area contains the following lines
<PRE CLASS="verbatim">    name
    comments
    signal1 file name
    signal2 file name
    tree file name
    original image number of columns
    original image number of rows
    previous Fpack file name
    next Fpack file name

    image 1 file name
    image 2 file name
    (...)
    image n file name
</PRE>Let us detail an example. We have a <CODE>Wpack2d</CODE>
named <EM>my_pack</EM> with a description &#X201D;this is my comment&#X201D;. 
It uses a signal saved in a file named <EM>da04.ir</EM> and a tree saved in a file named
<EM>wavelet1</EM>. There are 4 images in the decomposition. We have neither
previous <CODE>Wpack2d</CODE> nor next <CODE>Wpack2d</CODE>. 
The content of the corresponding <CODE>A_WPACK2D</CODE> file will be
<PRE CLASS="verbatim">%
MegaWave2 - DATA ASCII file -
%
def Wpack2d

name : my_pack
comment : this is my comment
signal1 : da04.ir
signal2 : da04.ir
tree : wavelet1
img_ncol : 512
img_nrow : 512
previous : null
next : null

my_pack0_0
my_pack1_0
my_pack0_1
my_pack1_1
</PRE></LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">5.3.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="wavelets_wpack2d_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Wpack2d</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_wpack2d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wpack2d mw_alloc_wpack2d(pack, tree, signal1, signal2, start_nrow, start_ncol)</P><P>Wpack2d pack;</P><P>Cimage tree;</P><P>Fsignal signal1;</P><P>Fsignal signal2;</P><P>int start_nrow;</P><P>int start_ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates images array and fills fields of <CODE>pack</CODE> to fit inputs 
(tree and the signals), assuming the <CODE>pack</CODE> structure has been created with <CODE>mw_new_wpack2d</CODE> first. 
It creates images in cells that will receive wavelet packet coefficients. Other cells are filled with <TT>NULL</TT>
pointers. When modifying wavelet packet coefficients, you should check if a
cell is <TT>NULL</TT> or not before you try to use it because a <TT>NULL</TT> cell means there
should be no image there. To get an example, see module <CODE>wp2doperate.c</CODE>.</P><P>Here is the description of the different arguments :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>pack</CODE> : It provides the address of the output
<CODE>Wpack2d</CODE>, its fields <CODE>name</CODE> and <CODE>cmt</CODE> are not modified.
</LI><LI CLASS="li-itemize"><CODE>tree</CODE> : It provides the tree of the <CODE>Wpack2d</CODE>.
</LI><LI CLASS="li-itemize"><CODE>signal1</CODE> : It provides the impulse response of h filter.
</LI><LI CLASS="li-itemize"><CODE>signal2</CODE> : If not <TT>NULL</TT>, it provides the impulse response of
h filter (for bi-orthogonal wavelet packets). If <TT>NULL</TT>, <CODE>signal1</CODE> plays the role of 
h filter (this corresponds to orthogonal wavelet packets). 
</LI><LI CLASS="li-itemize"><CODE>start_nrow</CODE> : Number of columns of the image on which wavelet packet transform is computed.
</LI><LI CLASS="li-itemize"><CODE>start_ncol</CODE> : Number of rows of the image on which wavelet packet transform is computed.
</LI></UL><P>The function returns <TT>NULL</TT> if not enough memory is available to allocate one of the fields. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack=NULL; /* Internal use: no Input neither Output of module */

if (!(pack=mw_new_wpack2d()) ||
!(mw_alloc_wpack2d(pack, tree, Ri, Ri_biortho, A-&gt;nrow, A-&gt;ncol)))
   mwerror(FATAL,-1,"Not enough memory\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_wpack2d</FONT></B> - Changes the memory allocation of a Wpack2d</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wpack2d mw_change_wpack2d(pack, tree, signal1, signal2, start_nrow, start_ncol)</P><P>Wpack2d pack;</P><P>Cimage tree;</P><P>Fsignal signal1;</P><P>Fsignal signal2;</P><P>int start_nrow;</P><P>int start_ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
</P><P>This function is made to change the memory allocation of a <EM>Wpack2d</EM>.
It changes the tree, the impulse responses and the allocation of 
images fields according to the input values. </P><P>The structure address is not changed (if not <TT>NULL</TT>) and both name and
comments are kept. Any pointer on the structure will still be usable.</P><P>Here is the description of the different arguments :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>pack</CODE> : If not <TT>NULL</TT>, it provides the address of the output
<CODE>Wpack2d</CODE>, its fields <CODE>name</CODE> and <CODE>cmt</CODE> are not modified. 
If <TT>NULL</TT> a new <CODE>Wpack2d</CODE> is created and memory is allocated.
</LI><LI CLASS="li-itemize"><CODE>tree</CODE> : It provides the tree of the <CODE>Wpack2d</CODE>.
</LI><LI CLASS="li-itemize"><CODE>signal1</CODE> : It provides the impulse response of the h filter.
</LI><LI CLASS="li-itemize"><CODE>signal2</CODE> : If not <TT>NULL</TT>, it provides the impulse response of
h filter (for bi-orthogonal wavelet packets). If <TT>NULL</TT>, <CODE>signal1</CODE>
plays the role of h (this corresponds to orthogonal wavelet packets). 
</LI><LI CLASS="li-itemize"><CODE>start_nrow</CODE> : Number of columns of the image on which wavelet packet transform is computed.
</LI><LI CLASS="li-itemize"><CODE>start_ncol</CODE> : Number of rows of the image on which wavelet packet transform is computed.
</LI></UL><P>The function returns <TT>NULL</TT> if not enough memory is available to allocate one of the fields. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack;
Cimage tree;
Fsignal h,htilde;
Fimage A;

/* Usage when &lt;pack&gt; IS NOT an output of the module(and has not been
   previously allocated): the function returns a new structure's address
*/
pack=mw_change_wpack2d(NULL, tree, h, htilde, A-&gt;nrow,A-&gt;ncol);

/* Usage when &lt;pack&gt; IS an output of the module (or has been previously
   allocated): DO NOT change the structure's address
*/
pack=mw_change_wpack2d(pack, tree, h, htilde, A-&gt;nrow,A-&gt;ncol);

if(!pack) mwerror(FATAL, 1, "Not enough memory.\n")

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_checktree_wpack2d</FONT></B> - Check a quad-tree</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
int mw_checktree_wpack2d(tree)</P><P>Cimage tree;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
</P><P>This function checks if the input image <CODE>tree</CODE> can be considered
as a tree (quad-tree) for a wavelet packet decomposition.
If the image is a tree, the function returns its maximum level of decomposition.
If not, a fatal error is generated and a corresponding error message is issued.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack;
Cimage tree; /* input image (must be previously filled) */

pack= mw_new_wpack2d();
if (!pack) mwerror(FATAL,1,"Not enough memory.\n");
  
/* Checks tree and computes the maximum decomposition level */   
pack-&gt;level = mw_checktree_wpack2d(tree);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_wpack2d</FONT></B> - Clear all wavelet packet coefficients</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_wpack2d(pack,v)</P><P>Wpack2d pack;</P><P>float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function clears all wavelet packet coefficients of <CODE>pack</CODE>
by uniformly setting the value <CODE>v</CODE> in all images (most of time you will 
use <I>v</I>=0).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack; /* Input pack (previously filled) */

 /* Clear all wavelet packet coefficients in &lt;pack&gt; */
 mw_clear_wpack2d(pack, 0.0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_wpack2d</FONT></B> - Copy a wavelet packet decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_wpack2d(in,out,new_tree_size)</P><P>Wpack2d in;</P><P>Wpack2d out;</P><P>int new_tree_size;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the wavelet packet <CODE>in</CODE> into another <CODE>out</CODE>,
by copying wavelet packet coefficients and other fields so that <CODE>out</CODE> contains
a valid wavelet packet decomposition which corresponds to the decomposition of
the same image in the same basis.</P><P>The structure <CODE>out</CODE> must have been created using <CODE>mw_new_wpack2d</CODE> before
the copy, but <CODE>mw_copy_wpack2d</CODE> will make any required size modification or allocation.</P><P>Here is the description of the different arguments :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>in</CODE> : Input <CODE>Wpack2d</CODE>. It must contain a wavelet packet decomposition. 
</LI><LI CLASS="li-itemize"><CODE>out</CODE> : Ouput <CODE>Wpack2d</CODE>, with a valid address.
</LI><LI CLASS="li-itemize"><CODE>new_tree_size</CODE> : 
<UL CLASS="itemize"><LI CLASS="li-itemize">
If <CODE>new_tree_size</CODE> is smaller than <CODE>in-&gt;tree-&gt;ncol</CODE>, <CODE>in</CODE> is
just copied into <CODE>out</CODE>.
</LI><LI CLASS="li-itemize">if <CODE>new_tree_size</CODE> is larger than <CODE>in-&gt;tree-&gt;ncol</CODE>, <CODE>new_tree_size</CODE>
must be a power of 2. In this case, <CODE>out</CODE> corresponds to
the same wavelet packet decomposition as <CODE>in</CODE>, BUT <CODE>out-&gt;tree-&gt;ncol</CODE>
equals <CODE>new_tree_size</CODE>. Of course, <CODE>out</CODE> is correct : all the modifications
requested by this size change are performed. For an exemple, see 
module <CODE>wp2dchangepack</CODE>.
</LI></UL>
</LI></UL><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d old_pack; /* Input pack (previously filled) */
Wpack2d pack;

 pack=mw_new_wpack2d();
 if (!pack) mwerror(FATAL,-1,"Not enough memory\n");
 mw_copy_wpack2d(old_pack,pack,0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_wpack2d</FONT></B> - Delete a wavelet packet decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_wpack2d(pack)</P><P>Wpack2d pack;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
<CODE>mw_delete_wpack2d</CODE> releases all the memory previously
allocated for the <CODE>Wpack2d</CODE>. Notice that all substructures
like images and signals are also freed.</P><P>The behavior of <CODE>previous</CODE> and <CODE>next</CODE> fields needs to be
explained. To help user to manage <CODE>Wpack2d</CODE> movies,
<CODE>mw_delete_wpack2d</CODE> keeps consistency in the <CODE>Wpack2d</CODE> movie.
If four <CODE>Wpack2d</CODE> are linked this way 
</P><PRE CLASS="verbatim">  A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D
</PRE><P>and if <CODE>mw_delete_wpack2d</CODE> is used to delete C, one obtains : 
</P><PRE CLASS="verbatim">  A &lt;-&gt; B &lt;-&gt; D
</PRE><P>After a call to <CODE>mw_delete_wpack2d</CODE> any access to the deleted
<CODE>Wpack2d</CODE> will cause unpredictable errors. You should set the
deleted <CODE>Wpack2d</CODE> to <TT>NULL</TT>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack; /* Previously allocated wavelet packet */

mw_delete_wpack2d(pack);
pack=NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_wpack2d</FONT></B> - Create a new Wpack2d</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wpack2d mw_new_wpack2d();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Wpack2d </TT>structure with empty image array
(every fields are set to default). Image array and other fields directly
related to decomposition still need to be allocated using
<CODE>mw_alloc_wpack2d</CODE>, before they can be used.</P><P>You don&#X2019;t need this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). 
This function is used to create internal variables.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_wpack2d</CODE> returns <TT>NULL</TT> if not enough memory is available 
to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack=NULL; /* Internal use: no Input neither Output of module */

if (!(pack=mw_new_wpack2d()) ||
!(mw_alloc_wpack2d(pack, tree, Ri, Ri_biortho, A-&gt;nrow, A-&gt;ncol)))
   mwerror(FATAL,-1,"Not enough memory\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_prune_wpack2d</FONT></B> - Prune the tree of a wavelet packet decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_prune_wpack2d(in, out, tree)</P><P>Wpack2d in;</P><P>Wpack2d out;</P><P>Cimage tree;
</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function should only be called when the wavelet packet decomposition
contained in <CODE>in</CODE> corresponds to the tree defined by <CODE>tree</CODE>, but is coded
by a <CODE>Cimage</CODE> whose size is larger than the size of <CODE>tree</CODE>, 
such as in the case where the <CODE>Cimage</CODE> <CODE>in-&gt;tree</CODE> describes the same quad-tree 
than <CODE>tree</CODE>.</P><P>In such a case, if <CODE>tree-&gt;ncol</CODE> is smaller than <CODE>in-&gt;tree-&gt;ncol</CODE>, the
output corresponds to the same wavelet packet decomposition as <CODE>in</CODE> but
<CODE>out-&gt;tree</CODE> contains <CODE>tree</CODE>. The <CODE>Wpack2d</CODE> <CODE>out</CODE> is correct :
all the modifications requested by this size change are performed. 
For an example, see module <CODE>wp2dchangepack</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack1;
Wpack2d pack2;
Cimage tree1;
Cimage tree2;

mw_copy_wpack2d(pack1,pack2,tree2-&gt;ncol);
mw_prune_wpack2d(pack2,pack1,tree1);
</PRE><!--TOC chapter Geometrical structures : Point, Curves, Polygons and Lists-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc59">Chapter&#XA0;6</A>&#XA0;&#XA0;Geometrical structures : Point, Curves, Polygons and Lists</H1><!--SEC END --><P>
<A NAME="curves-polygons"></A>
</P><P>The family of curves, polygons and lists objects are mainly used to handle geometrical
processes, as mathematical morphology algorithms, shape analysis, snakes, &#X2026;</P><P>In MegaWave2, a <EM>curve</EM><A NAME="@default74"></A> (section&#XA0;<A HREF="#curves-polygons_curve">6.2</A>) is a set of 
points<A NAME="@default75"></A> in the plane that is, a set of (<I>x</I>,<I>y</I>) coordinates. 
Although there is no such explicit condition in the system library, most modules assume that 
this set is really a curve, meaning that points are adjacent for the 4 or 8-connectivity,
and that the dimension of the set is less than 2. For a two-dimensional set of points,
to avoid memory blowup, consider the segment structure (Section&#XA0;<A HREF="#hsegment">7.4</A>).
A curve is implemented as a chain of points:
the curve begins with a first point, from which we can go to the next 
point, and so one up to the last point. 
There is no condition set about the geometry of the curve (e.g. the curve can
cut itself) but your algorithm may want to put some. 
There is no an a priori rule to interpolate the curve between two adjacent points
in the chain, in the case where they are not adjacent in the plane. Your algorithm may
have to process such interpolation.</P><P>You may want to handle a <EM>set of curves</EM> (it can be for example the result of an edge detector applied to an image). 
Such object is also provided in MegaWave2 (section&#XA0;<A HREF="#curves-polygons_curves">6.3</A>) and it is implemented as a chain of curves.</P><P>What we call <EM>polygon</EM><A NAME="@default76"></A> (section&#XA0;<A HREF="#curves-polygons_polygon">6.4</A>) is basically a closed curve that is, a chain of (<I>x</I>,<I>y</I>) coordinates where the point next the last point is assumed to be the first point. 
But one can associate to a polygon a list of real parameters.
It can be, for example, only one value which gives the gray level of the
constant region delimited by the closed curve. 
The meaning of the parameters is not pre-defined, so you can used it freely
in your algorithms. </P><P>You may also want to handle a <EM>set of polygons</EM> (it can be for example the result of a region-segmentation algorithm applied to an image).
This object, explained in section&#XA0;<A HREF="#curves-polygons_polygons">6.5</A>, is of course
implemented as a chain of polygons.</P><P>All of the objects we have enumerated can record integer or real coordinates 
(for some 
applications, you may need real coordinates - e.g. when you compute a P.D.E. 
to evolve a curve -). 
In the following, we give a full description of the objects for which 
coordinates are integers.
By putting a <CODE>F</CODE> (floating-point precision) or <CODE>D</CODE> (double) at the beginning
of the <EM>curve</EM> and <EM>polygon</EM> object&#X2019;s name, you get the corresponding 
object with real coordinates 
fields (see section&#XA0;<A HREF="#curves-polygons_real">6.6</A> for a short description).</P><P>We shall begin our description by the basic object used by curves and polygons: the point.</P><!--TOC section Point of a planar curve-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc60">6.1</A>&#XA0;&#XA0;Point of a planar curve</H2><!--SEC END --><P><A NAME="curves-polygons_point"></A>

<A NAME="@default77"></A></P><P>A <TT>Point_curve</TT><A NAME="@default78"></A> is nothing more than two coordinates (<I>x</I>,<I>y</I>) which can be linked
to a previous and to a next <TT>Point_curve</TT>, in order to constitute a curve.</P><!--TOC subsection The structure Point_curve-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc61">6.1.1</A>&#XA0;&#XA0;The structure Point_curve</H3><!--SEC END --><P>
<A NAME="curves-polygons_point_structure"></A></P><P>This is the C definition of the structure:
</P><PRE CLASS="verbatim">typedef struct point_curve {
  int x,y; /* Coordinates of the point */

  /* For use in Curve only */
  struct point_curve *previous; /*Pointer to the previous point (may be NULL)*/
  struct point_curve *next; /* Pointer to the next point (may be NULL) */
} *Point_curve;
</PRE><P>The first two fields <CODE>x</CODE> and <CODE>y</CODE> are the coordinates (<I>x</I>,<I>y</I>) of
the point in the plane. 
Since the <CODE>Curve</CODE> and the <CODE>Polygon</CODE> structures are defined as
a chain of <TT>Point_curve</TT>, there are two pointers <CODE>previous</CODE> and <CODE>next</CODE> associated to each point.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc62">6.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="curves-polygons_point-file_type"></A></P><P>Not available: at this time, the <TT>Point_curve</TT> object cannot be used as input/output variables of modules.</P><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc63">6.1.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="curves-polygons_point_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Point_curve</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_point_curve</FONT></B> - Define the point_curve structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_curve mw_change_point_curve(point)</P><P>Point_curve point;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a Point_curve structure if the input <CODE>point = NULL</CODE>.
It is provided despite the <CODE>mw_new_point_curve</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_point_curve</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Point_curve point=NULL; /* Internal use: no Input neither Output of module */

/* Define the point (5,1) of the plane */

point = mw_change_point_curve(point);
if (point == NULL) mwerror(FATAL,1,"Not enough memory.\n");
point-&gt;x = 5;
point-&gt;y = 1;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_point_curve</FONT></B> - Copy all points starting from the given one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_curve mw_copy_point_curve(in,out)</P><P>Point_curve in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the current point and the next points contained in the chain 
defined at the starting point <CODE>in</CODE>. The result is put in <CODE>out</CODE>, which
may not be a predefined structure : in case of <CODE>out=NULL</CODE>, the <CODE>out</CODE>
structure is allocated.</P><P>The function <CODE>mw_copy_point_curve</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Point_curve in; /* Predefined point */
Point_curve out=NULL; 

out=mw_copy_point_curve(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_point_curve</FONT></B> - Deallocate the point_curve structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_point_curve(point)</P><P>Point_curve point;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the <TT>Point_curve</TT> structures starting from
the given <CODE>point</CODE>, including this point itself.
You should set <CODE>point = NULL</CODE> after this call since the address pointed
by <CODE>point</CODE> is no longer valid.
Warning : to deallocate only a point and not all the next points of a 
chain, just use <CODE>free(point)</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Remove the first point of an existing curve */

Curve curve;  /* Existing curve (e.g. Input of module) */
Point_curve point;  /* Internal use */

point = curve-&gt;first;
curve-&gt;first=point-&gt;next;
point-&gt;next-&gt;previous = NULL;
free(point);
point = NULL;

/* Remove all points of an existing curve */

mw_delete_point_curve(curve-&gt;first);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_point_curve</FONT></B> - Create a new point_curve structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_curve mw_new_point_curve();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Point_curve</TT> structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal point structures before the end
of the module, except if they are part of an input or output curve.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Insert the point (0,0) at the end of an existing curve */

Curve curve;  /* Existing curve (e.g. Input of module) */
Point_curve point,p;  /* Internal use: no Input neither Output of module */

/* Define the point (0,0) */
point = mw_new_point_curve();
if (point == NULL) mwerror(FATAL,1,"Not enough memory.\n");
point-&gt;x = point-&gt;y = 0;
point-&gt;next = NULL;

/* Find the last point of the curve */
p = curve-&gt;first; while (p-&gt;next) p=p-&gt;next;

/* Insert the point */
p-&gt;next = point;
point-&gt;previous = p;

/* Do not deallocate point or curve will become inconsistent */ 
</PRE><!--TOC section Planar curve-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc64">6.2</A>&#XA0;&#XA0;Planar curve</H2><!--SEC END --><P><A NAME="curves-polygons_curve"></A>

<A NAME="@default79"></A></P><P>You may want to use the <TT>Curve</TT> memory type each type you need to 
constitute a chain of (<I>x</I>,<I>y</I>) coordinates.</P><!--TOC subsection The structure Curve-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc65">6.2.1</A>&#XA0;&#XA0;The structure Curve</H3><!--SEC END --><P>
<A NAME="curves-polygons_curve_structure"></A></P><P>If <CODE>curve</CODE> is of <TT>Curve</TT> memory type, then <CODE>curve-&gt;first</CODE> is
of <TT>Point_curve</TT>memory type and it is the first point of the curve; 
<CODE>curve-&gt;first-&gt;next</CODE> is the second point, etc.
The end of the curve occurs when the <CODE>next</CODE> field of a point is
<TT>NULL</TT>.</P><PRE CLASS="verbatim">typedef struct curve {
  Point_curve first; /* Pointer to the first point of the curve */

  /* For use in Curves only */
  struct curve *previous; /* Pointer to the previous curve (may be NULL) */
  struct curve *next; /* Pointer to the next curve (may be NULL) */
} *Curve;
</PRE><P>You may notice that the <TT>Curve</TT>type includes also the fields
<CODE>previous</CODE> and <CODE>next</CODE>, as the <TT>Point_curve</TT>type. This is because
curves can be linked together to define a set of curves (See&#XA0;<A HREF="#curves-polygons_curve_function">6.2.3</A> page&#XA0;<A HREF="#curves-polygons_curve_function">??</A>).
If the curve is not part of a set, those pointers must be <TT>NULL</TT>.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc66">6.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="curves-polygons_curve-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_CURVE"</CODE><A NAME="@default80"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">6.2.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="curves-polygons_curve_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Curve</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_curve</FONT></B> - Define the curve structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curve mw_change_curve(curve)</P><P>Curve curve;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a Curve structure if the input <CODE>curve = NULL</CODE>.
It is provided despite the <CODE>mw_new_curve</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_curve</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal curve structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curve with 10 points which is the straight line (0,0)-(9,9) */

Curve curve=NULL; /* Internal use: no Input neither Output of module */
Point_curve newp,oldp=NULL;
int i;

curve = mw_change_curve(curve);
if (curve == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_curve</CODE> function).</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_curve</FONT></B> - Copy a curve into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curve mw_copy_curve(in,out)</P><P>Curve in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function duplicates the points contained in <CODE>in</CODE>.
The result is put in <CODE>out</CODE>, which may not be a predefined structure : in case 
of <CODE>out=NULL</CODE>, the <CODE>out</CODE> structure is allocated.</P><P>The function <CODE>mw_copy_curve</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Curve in; /* Predefined curve */
Curve out=NULL; 

out=mw_copy_curve(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_curve</FONT></B> - Deallocate a curve</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_curve(curve)</P><P>Curve curve;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory allocated by the curve variable that is, all the points belonging to this chain and the <TT>Curve</TT>structure itself.
You should set <CODE>curve = NULL</CODE> after this call since the address pointed
by <CODE>curve</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Remove the first curve of an existing curve set (curves) */

Curves curves;/* Existing curve set (e.g. Input of module) */
Curve curve;  /* Internal use */

curve = curves-&gt;first;
curves-&gt;first=curves-&gt;next;
curves-&gt;next-&gt;previous = NULL;
mw_delete_curve(curve);
curve = NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_curve</FONT></B> - Return the number of points of a curve</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_curve(cv);</P><P>Curve cv;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function return the number of points contained in the given
curve <CODE>cv</CODE>. It returns 0 if the structure is empty.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Curve curve; /* Internal use: no Input neither Output of module */
Point_curve newp,oldp=NULL;
int i;

curve = mw_new_curve();
if (curve == NULL) mwerror(FATAL,1,"Not enough memory.\n");

/* Define a curve with 5 points */
for (i=1;i&lt;=5;i++)
{
 newp = mw_new_point_curve();
 if (newp == NULL) mwerror(FATAL,1,"Not enough memory.\n");
 if (i=0) curve-&gt;first = newp;
 newp-&gt;x = newp-&gt;y = i;
 newp-&gt;previous = oldp;
 if (oldp) oldp-&gt;next = newp;
 oldp=newp;
} 

/* The length is 5 */
printf("Length=%d\n",mw_length_curve(curve));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_curve</FONT></B> - Create a new curve</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curve mw_new_curve();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Curve</TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curve with 10 points which is the straight line (0,0)-(9,9) */

Curve curve; /* Internal use: no Input neither Output of module */
Point_curve newp,oldp=NULL;
int i;

curve = mw_new_curve();
if (curve == NULL) mwerror(FATAL,1,"Not enough memory.\n");

for (i=0;i&lt;10;i++)
{
 newp = mw_new_point_curve();
 if (newp == NULL) mwerror(FATAL,1,"Not enough memory.\n");
 if (i=0) curve-&gt;first = newp;
 newp-&gt;x = newp-&gt;y = i;
 newp-&gt;previous = oldp;
 if (oldp) oldp-&gt;next = newp;
 oldp=newp;
} 
</PRE><!--TOC section Set of planar curves-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc68">6.3</A>&#XA0;&#XA0;Set of planar curves</H2><!--SEC END --><P><A NAME="curves-polygons_curves"></A>

<A NAME="@default81"></A></P><P>The <TT>Curves</TT> memory type is used when you want to handle several curves
into only one variable. </P><!--TOC subsection The structure Curves-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc69">6.3.1</A>&#XA0;&#XA0;The structure Curves</H3><!--SEC END --><P>
<A NAME="curves-polygons_curves_structure"></A></P><P>This is the C definition of the structure:
</P><PRE CLASS="verbatim">typedef struct curves {
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the set */
  Curve first;    /* Pointer to the first curve */
} *Curves;
</PRE><P>If <CODE>curves</CODE> is of <TT>Curves</TT> memory type, then <CODE>curves-&gt;first</CODE> is
of <TT>Curve</TT> memory type and it is the first curve of the set; 
therefore, <CODE>curves-&gt;first-&gt;first</CODE> is the first point of the first
curve.
<CODE>curves-&gt;first-&gt;next</CODE> is the second curve, etc.
The end of the set occurs when the <CODE>next</CODE> field of a curve is
<TT>NULL</TT>.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">6.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="curves-polygons_curves-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_CURVES"</CODE><A NAME="@default82"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">6.3.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="curves-polygons_curves_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Curves</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_curves</FONT></B> - Define the curves structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curves mw_change_curves(curves)</P><P>Curves curves;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a Curves structure if the input <CODE>curves = NULL</CODE>.
It is provided despite the <CODE>mw_new_curves</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_curves</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal curves structures before the end
of the module.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curves set to be two pre-defined curves  */

Curves curves=NULL;   /* Internal use: no Input neither Output of module */
Curve curve1,curve2;  /* Pre-defined curves (e.g. inputs of module) */

curves = mw_change_curves(curves);
if (curves == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_curves</CODE> function).</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_curves</FONT></B> - Deallocate a curves set</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_curves(curves)</P><P>Curves curves;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory allocated by the curves variable
that is, all the points belonging to all curves into this set, all <TT>Curve</TT>structures and the <TT>Curves</TT>structure itself.
You should set <CODE>curves = NULL</CODE> after this call since the address pointed
by <CODE>curves</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Curves curves=NULL;   /* Internal use: no Input neither Output of module */

curves = mw_new_curves();
if (curves == NULL) mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_curves(curves);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_curves</FONT></B> - Return the number of curves into a curves structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_curves(cvs);</P><P>Curves cvs;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of curves contained in the given
<CODE>cvs</CODE>. It returns 0 if the structure is empty.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curves set to be two pre-defined curves  */

Curves curves=NULL;   /* Internal use: no Input neither Output of module */
Curve curve1,curve2;  /* Pre-defined curves (e.g. inputs of module) */

curves = mw_new_curves();
if (curves == NULL) mwerror(FATAL,1,"Not enough memory.\n");

curves-&gt;first=curve1;
curve1-&gt;previous = curve2-&gt;next = NULL;
curve1-&gt;next = curve2;
curve2-&gt;previous = curve1;

/* The length would be 2 */
printf("Length=%d\n",mw_length_curves(curves));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_curves</FONT></B> - Create a new curves</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curves mw_new_curves();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Curves</TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curves set to be two pre-defined curves  */

Curves curves=NULL;   /* Internal use: no Input neither Output of module */
Curve curve1,curve2;  /* Pre-defined curves (e.g. inputs of module) */

curves = mw_new_curves();
if (curves == NULL) mwerror(FATAL,1,"Not enough memory.\n");

curves-&gt;first=curve1;
curve1-&gt;previous = curve2-&gt;next = NULL;
curve1-&gt;next = curve2;
curve2-&gt;previous = curve1;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_npoints_curves</FONT></B> - Return the total number of points a curves structure contains</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_npoints_curves(cvs);</P><P>Curves cvs;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the total number of points contained in the given
<CODE>cvs</CODE>, that is the sum of <CODE>mw_length_curve(cv)</CODE> for all
curves <CODE>cv</CODE> contained in <CODE>cvs</CODE>.
The function returns 0 if the structure is empty.</P><!--TOC section Polygon, a variant of curve-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc72">6.4</A>&#XA0;&#XA0;Polygon, a variant of curve</H2><!--SEC END --><P><A NAME="curves-polygons_polygon"></A></P><P>
<A NAME="@default83"></A></P><P>You should use the <TT>Polygon</TT> memory type when you need to constitute a 
chain of (<I>x</I>,<I>y</I>) coordinates with some global properties.</P><!--TOC subsection The structure Polygon-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc73">6.4.1</A>&#XA0;&#XA0;The structure Polygon</H3><!--SEC END --><P>
<A NAME="curves-polygons_polygon_structure"></A></P><P>The first two fields of the structure register the global properties,
assumed to be represented as an array of channels; each channel is
a real number. 
The meaning of each channel has to be defined by the user; the number
of channels can be selected using the function <CODE>mw_alloc_polygon</CODE>
or <CODE>mw_change_polygon</CODE> (see below).</P><P>The next fields of the structure are similar to those in the <TT>Curve</TT>memory 
type.</P><PRE CLASS="verbatim">typedef struct polygon {
  int nb_channels;  /* Number of channels */
  float *channel;  /* Tab to the channel */
                   /* The number of elements is given by nb_channels */
  Point_curve first; /* Pointer to the first point of the curve */

  /* For use in Polygons only */
  struct polygon *previous; /* Pointer to the previous poly. (may be NULL) */
  struct polygon *next; /* Pointer to the next poly. (may be NULL) */
} *Polygon;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc74">6.4.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="curves-polygons_polygon-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_POLY"</CODE><A NAME="@default84"></A> MegaWave2 Data Ascii format with a <CODE>def Polygon</CODE> 
area. 
If a file of this format has several <CODE>def Polygon</CODE> areas, only the first one is meaningful for the <TT>Polygon</TT> object.
Since this format uses Ascii coding, you may read or modify the file just by
editing it using a text editor.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc75">6.4.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="curves-polygons_polygon_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Polygon</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_polygon</FONT></B> - Allocate the channels array</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygon mw_alloc_polygon(polygon,nc)</P><P>Polygon polygon;</P><P>int nc;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the channels array of a <TT>Polygon</TT>structure previously
created using <CODE>mw_new_polygon</CODE>. The size of the array is given by 
<CODE>nc</CODE>, it is the number of different channels.
A channel corresponds to a real parameter associated to the polygon. 
The meaning of such channel has to be defined by the user. 
For example, <CODE>polygon-&gt;channel[0]</CODE> may be the gray level of the polygon.</P><P>Do not use this function if <CODE>polygon</CODE> has already an allocated channels array: use the function <CODE>mw_change_polygon</CODE> instead.</P><P>The function <CODE>mw_alloc_polygon</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure or the channels array. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the function <CODE>mw_new_polygon</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_polygon</FONT></B> - Change the number of channels</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygon mw_change_polygon(polygon,nc)</P><P>Polygon polygon;</P><P>int nc;
</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation for the channels array of
a <TT>Polygon</TT>structure, even if no previously memory allocation was done. </P><P>The number of channels is given by <CODE>nc</CODE>; a channel corresponds to
a real parameter associated to the polygon. The meaning of such channel
has to be defined by the user. For example, <CODE>polygon-&gt;channel[0]</CODE> may be the gray level of the polygon.</P><P>This function can also create the structure if the input <CODE>polygon = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_polygon</CODE> and
<CODE>mw_alloc_polygon</CODE>. 
It is the recommended function to set the number of channels for polygons which are input/output of a module.
Since the function can set the address of <CODE>polygon</CODE>, the variable must be set to the return value of the function (See example below).</P><P>The function <CODE>mw_change_polygon</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure or the channels array. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Polygon polygon; /* Input of module */

polygon = mw_change_polygon(polygon,1);
if (polygon == NULL) mwerror(FATAL,1,"Not enough memory.\n");
polygon-&gt;channel[0] = 255.0;
...
</PRE><P>(End of this example as for the <CODE>mw_new_polygon</CODE> function).</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_polygon</FONT></B> - Deallocate a polygon</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_polygon(polygon)</P><P>Polygon polygon;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory allocated by the polygon variable that is, all the points belonging to this chain, the channels array (if needed) and the <TT>Polygon</TT>structure itself.
You should set <CODE>polygon = NULL</CODE> after this call since the address pointed
by <CODE>polygon</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Remove the first polygon of an existing polygon set (polygons) */

Polygons polygons;/* Existing polygons set (e.g. Input of module) */
Polygon polygon;  /* Internal use */

polygon = polygons-&gt;first;
polygons-&gt;first=polygons-&gt;next;
polygons-&gt;next-&gt;previous = NULL;
mw_delete_polygon(polygon);
polygon = NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_polygon</FONT></B> - Return the number of points of a polygon</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_polygon(poly);</P><P>Polygon poly;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function return the number of points contained in the given
polygon <CODE>poly</CODE>. It returns 0 if the structure is empty.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Polygon polygon; /* Internal use: no Input neither Output of module */
point_curve newp,oldp=NULL;
int i;

polygon = mw_new_polygon();
if (polygon == NULL) mwerror(FATAL,1,"Not enough memory.\n");

/* Define a polygon with 5 points */
for (i=1;i&lt;=5;i++)
{
 newp = mw_new_point_curve();
 if (newp == NULL) mwerror(FATAL,1,"Not enough memory.\n");
 if (i=0) polygon-&gt;first = newp;
 newp-&gt;x = newp-&gt;y = i;
 newp-&gt;previous = oldp;
 if (oldp) oldp-&gt;next = newp;
 oldp=newp;
} 

/* The length is 5 */
printf("Length=%d\n",mw_length_polygon(polygon));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_polygon</FONT></B> - Create a new polygon</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygon mw_new_polygon();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Polygon</TT>structure with an empty channels array.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output polygons set.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a polygon with 10 points which is the straight line (0,0)-(9,9) */

Polygon polygon; /* Internal use: no Input neither Output of module */
Point_curve newp,oldp=NULL;
int i;

polygon = mw_new_polygon();
if ((polygon == NULL) || (mw_alloc_polygon(polygon,1) == NULL))
    mwerror(FATAL,1,"Not enough memory.\n");
polygon-&gt;channel[0] = 255.0;

for (i=0;i&lt;10;i++)
{
 newp = mw_new_point_curve();
 if (newp == NULL) mwerror(FATAL,1,"Not enough memory.\n");
 if (i=0) polygon-&gt;first = newp;
 newp-&gt;x = newp-&gt;y = i;
 newp-&gt;previous = oldp;
 if (oldp) oldp-&gt;next = newp;
 oldp=newp;
} 
</PRE><!--TOC section Set of polygons-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc76">6.5</A>&#XA0;&#XA0;Set of polygons</H2><!--SEC END --><P><A NAME="curves-polygons_polygons"></A>

<A NAME="@default85"></A></P><P>The <TT>Polygons</TT> memory type is used when you want to handle several polygons
into only one variable. </P><!--TOC subsection The structure Polygons-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc77">6.5.1</A>&#XA0;&#XA0;The structure Polygons</H3><!--SEC END --><P>
<A NAME="curves-polygons_polygons_structure"></A></P><P>This is the C definition of the structure:
</P><PRE CLASS="verbatim">typedef struct polygons {
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the set */
  Polygon first;    /* Pointer to the first polygon */
} *Polygons;
</PRE><P>If <CODE>polygons</CODE> is of <TT>Polygons</TT> memory type, then <CODE>polygons-&gt;first</CODE> is
of <TT>Polygon</TT> memory type and it is the first polygon of the set; 
therefore, <CODE>polygons-&gt;first-&gt;first</CODE> is the first point of the first
polygon.
<CODE>polygons-&gt;first-&gt;next</CODE> is the second polygon, etc.
The end of the set occurs when the <CODE>next</CODE> field of a polygon is
<TT>NULL</TT>.</P><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc78">6.5.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="curves-polygons_polygons-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_POLY"</CODE><A NAME="@default86"></A> 
MegaWave2 Data Ascii format with as many <CODE>def Polygon</CODE> areas as the number of polygons recorded.
Since this format uses Ascii coding, you may read or modify the file just by
editing it using a text editor.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc79">6.5.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="curves-polygons_polygons_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Polygons</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_polygons</FONT></B> - Define the polygons structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygons mw_change_polygons(polygons)</P><P>Polygons polygons;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a Polygons structure if the input <CODE>polygons = NULL</CODE>.
It is provided despite the <CODE>mw_new_polygons</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_polygons</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal polygons structures before the end
of the module.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a polygons set to be two pre-defined polygons  */

Polygons polygons=NULL;   /* Internal use: no Input neither Output of module */
Polygon polygon1,polygon2;  /* Pre-defined polygons (e.g. inputs of module) */

polygons = mw_change_polygons(polygons);
if (polygons == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_polygons</CODE> function).</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_polygons</FONT></B> - Deallocate a polygons set</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_polygons(polygons)</P><P>Polygons polygons;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory allocated by the polygons variable
that is, all the points belonging to all polygons into this set, all channels arrays (if any), all <TT>Polygon</TT>structures and the <TT>Polygons</TT>structure itself.
You should set <CODE>polygons = NULL</CODE> after this call since the address pointed
by <CODE>polygons</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Polygons polygons=NULL;   /* Internal use: no Input neither Output of module */

polygons = mw_new_polygons();
if (polygons == NULL) mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_polygons(polygons);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_polygons</FONT></B> - Return the number of polygons into a polygons structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_polygons(polys);</P><P>Polygons polys;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of polygons contained in the given
<CODE>polys</CODE>. It returns 0 if the structure is empty.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a polygons set to be two pre-defined polygons  */

Polygons polygons=NULL;   /* Internal use: no Input neither Output of module */
Polygon polygon1,polygon2;  /* Pre-defined polygons (e.g. inputs of module) */

polygons = mw_new_polygons();
if (polygons == NULL) mwerror(FATAL,1,"Not enough memory.\n");

polygons-&gt;first=polygon1;
polygon1-&gt;previous = polygon2-&gt;next = NULL;
polygon1-&gt;next = polygon2;
polygon2-&gt;previous = polygon1;

/* The length would be 2 */
printf("Length=%d\n",mw_length_polygons(polygons));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_polygons</FONT></B> - Create a new polygons</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygons mw_new_polygons();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Polygons</TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a polygons set to be two pre-defined polygons  */

Polygons polygons=NULL;   /* Internal use: no Input neither Output of module */
Polygon polygon1,polygon2;  /* Pre-defined polygons (e.g. inputs of module) */

polygons = mw_new_polygons();
if (polygons == NULL) mwerror(FATAL,1,"Not enough memory.\n");

polygons-&gt;first=polygon1;
polygon1-&gt;previous = polygon2-&gt;next = NULL;
polygon1-&gt;next = polygon2;
polygon2-&gt;previous = polygon1;
</PRE><!--TOC section Points, Curves and Polygons with real coordinates-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc80">6.6</A>&#XA0;&#XA0;Points, Curves and Polygons with real coordinates</H2><!--SEC END --><P><A NAME="curves-polygons_real"></A></P><P>Until now, all of the objects we have described in the
section&#XA0;<A HREF="#curves-polygons">6</A> record the coordinates as integers.
Use the following objects if you need coordinates of floating point
values:
<TT>Point_fcurve</TT><A NAME="@default87"></A>, <TT>Fcurve</TT><A NAME="@default88"></A>, <TT>Fcurves</TT><A NAME="@default89"></A>,
<TT>Fpolygon</TT><A NAME="@default90"></A>, <TT>Fpolygons</TT><A NAME="@default91"></A>.
If you need higher precision, use the following objects (coordinates
are recorded as double): <TT>Point_dcurve</TT><A NAME="@default92"></A>, <TT>Dcurve</TT><A NAME="@default93"></A>, 
<TT>Dcurves</TT><A NAME="@default94"></A>.</P><P>We will not give the full description of these objects and of their related
functions since it is equivalent to the former description, just keep in
mind to translate the words <EM>curve</EM> to <EM>fcurve</EM> or <EM>dcurve</EM> and <EM>polygon</EM>
to <EM>fpolygon</EM>, both in the type names (the first letter being upper-case) and in the function 
names.</P><P>And, of course, do not forget that the coordinates are now real.
The C definition of the structure <TT>Point_fcurve</TT> is the following:
</P><PRE CLASS="verbatim">typedef struct point_fcurve {
  float x,y; /* Coordinates of the point */

  /* For use in Fcurve only */
  struct point_fcurve *previous; /*Pointer to the previous point (may be NULL)*/
  struct point_fcurve *next; /* Pointer to the next point (may be NULL) */
} *Point_fcurve;
</PRE><P>
The C definition of the structure <TT>Point_dcurve</TT> is the following:
</P><PRE CLASS="verbatim">typedef struct point_dcurve {
  double x,y; /* Coordinates of the point */

  /* For use in Dcurve only */
  struct point_dcurve *previous; /*Pointer to the previous point (may be NULL)*/
  struct point_dcurve *next; /* Pointer to the next point (may be NULL) */
} *Point_dcurve;
</PRE><!--TOC section Lists of <I>n</I>-tuple reals-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc81">6.7</A>&#XA0;&#XA0;Lists of <I>n</I>-tuple reals</H2><!--SEC END --><P>Some algorithms dealing with curves can be made more efficient if image coordinates
are not recorded as a chain of points (<I>x</I>,<I>y</I>), but as part of an array<A NAME="@default95"></A>.
In such case, use one of the <TT>Flist</TT>, <TT>Flists</TT>, <TT>Dlist</TT>, <TT>Dlists</TT> objects above.
These types can more generally be used to handle any list<A NAME="@default96"></A> of <I>n</I>-tuple reals, the
case of points in the plane corresponding to <I>n</I>=2.
As for curves, <TT>Dlist</TT> and <TT>Dlists</TT> are the counterpart of <TT>Flist</TT> and <TT>Flists</TT> :
the only difference between them is that values are of type double instead of float.</P><!--TOC subsection The structure Flist-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc82">6.7.1</A>&#XA0;&#XA0;The structure Flist</H3><!--SEC END --><P>
<A NAME="curves-polygons_flist"></A></P><P>In a variable of <TT>Flist</TT><A NAME="@default97"></A> memory type, data such as coordinates are
recorded in the array named <CODE>values</CODE>.
We call <EM>dimension</EM> (field named <CODE>dim</CODE>) the number of
components per elements the array is composed, while the field
named <CODE>size</CODE> gives the number of elements.
When a <TT>Flist</TT> is used as a <TT>Fcurve</TT>, the dimension is 2 (number of coordinates
in the plane) and the size is the number of points.</P><P>The field <CODE>data</CODE> can be used to record any additional information
(when no information is available, it is set to <CODE>NULL</CODE>).
The size of the space pointed by <CODE>data</CODE> is set in <CODE>data_size</CODE>.</P><PRE CLASS="verbatim">typedef struct flist {
  int size;          /* size (number of elements) */
  int max_size;      /* currently allocated size (maximum number of elements) */ 
  int dim;           /* dimension (number of components per element) */
  float *values;     /* values = size * dim array
                          nth element = values[n*dim+i], i=0..dim-1 */
  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */
} *Flist;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc83">6.7.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="curves-polygons_flist-file_type"></A></P><P>The list of the available native formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_FLIST"</CODE><A NAME="@default98"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">6.7.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="curves-polygons_flist_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Flist</TT> type. The list is in alphabetical order.
Notice that these functions do not manage the <CODE>data</CODE> field.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_flist</FONT></B> - Define and allocate a <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_change_flist(l,max_size,size,dim)</P><P>Flist l;
int max_size,size,dim;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the <CODE>values</CODE> array
of a <TT>Flist</TT> structure, even if no previously memory allocation was done.
The new size (number of elements) of the structure is given by <CODE>size</CODE>,
the size to allocate (maximal number of elements) by <CODE>max_size</CODE>,
and the dimension by <CODE>dim</CODE>.</P><P>It can also create the structure if the input <CODE>l = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_flist</CODE> and
<CODE>mw_realloc_flist</CODE>. 
Since the function can set the address of <CODE>l</CODE>, the variable must be set 
to the return value of the function (See example below).</P><P>The function <CODE>mw_change_flist</CODE> returns <TT>NULL</TT> if not enough memory is 
available to allocate the structure or the <CODE>values</CODE> array, and an error 
message is issued. 
Your code should check this return value to eventually send a fatal error 
message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist l;

/* 
   Allocate l to handle at most 10 samples of couples (2) of 
   floating point values, the default number of samples being 0. 
*/
l = mw_change_flist(NULL,10,0,2);
if (!l) mwerror(FATAL,1,"Not enough memory to continue !\n");


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_flist</FONT></B> - Clear the array of a <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_flist(l,v)</P><P>Flist l;
float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function clears the <CODE>values</CODE> array by filling it
with the value <CODE>v</CODE> (up to the current number of samples).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist l;

/* 
   Allocate l to handle at most 10 samples of couples (2) of 
   floating point values, the default number of samples being 5. 
*/
l = mw_change_flist(NULL,10,5,2);
if (!l) mwerror(FATAL,1,"Not enough memory to continue !\n");

/* 
  Clear the 5 current samples with 0.
*/
mw_clear_flist(l,0.0);


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_flist</FONT></B> - Copy a the array <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_copy_flist(in,out)</P><P>Flist in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the <CODE>values</CODE> array and <CODE>data</CODE> field 
of the <TT>Flist</TT> structure <CODE>in</CODE> into <CODE>out</CODE>. 
The duplicated <TT>Flist</TT> <CODE>out</CODE> is allocated to
at least the current size of <CODE>in</CODE>.</P><P>Since the function can set the address of <CODE>out</CODE>, the variable must be set 
to the return value of the function (See example below).</P><P>The function <CODE>mw_copy_flist</CODE> returns <TT>NULL</TT> if not enough memory is 
available to allocate the structure or the <CODE>values</CODE> array, and an error 
message is issued. 
Your code should check this return value to eventually send a fatal error 
message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist in,out=NULL;

/* 
   Allocate in to handle at most 10 samples of couples (2) of 
   floating point values, the current number of samples being 5. 
*/
in = mw_change_flist(NULL,10,5,2);
if (!in) mwerror(FATAL,1,"Not enough memory to continue !\n");

/* 
  Clear the 5 current samples with 1.
*/
mw_clear_flist(in,1.0);

/*
 Copy in into out. Allocated size for out is 5 samples.
*/
out=mw_copy_flist(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory to copy flist !\n");


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_flist</FONT></B> - Delete the array and the <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_flist(l)</P><P>Flist l;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deletes the <CODE>values</CODE> array and the structure itself.
Warning : the memory of the user-defined field <CODE>data</CODE> is not freed.
If this field has been allocated, you should free it before calling
<CODE>mw_delete_flist</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist l;

/* 
   Allocate l to handle at most 10 samples of couples (2) of 
   floating point values, the default number of samples being 5. 
*/
l = mw_change_flist(NULL,10,5,2);
if (!l) mwerror(FATAL,1,"Not enough memory to continue !\n");

/* 
  Allocate the data field for 20 integers.
*/
l-&gt;data_size=20*sizeof(int);
l-&gt;data= (int *)malloc(l-&gt;data_size);
if (!l-&gt;data) mwerror(FATAL,1,"Not enough memory to continue !\n");


/*
    ... (statement)...
*/

/* 
  Free the list, including data field. 
*/
free(l-&gt;data);
mw_delete_flist(l);


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_enlarge_flist</FONT></B> - Enlarge the array of a <TT>Flist</TT></P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_enlarge_flist(l)</P><P>Flist l;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function performs a memory reallocation on the array
<CODE>l-&gt;values</CODE> to increase the number of elements that can be recorded.
The enlargement factor is fixed by the constant <CODE>MW_LIST_ENLARGE_FACTOR</CODE>
defined in the include file <CODE>list.h</CODE>.
This function is useful when one does not know by advance the size of
the list, and when one wish to avoid multiple reallocations.</P><P>If not enough memory is available to perform the reallocation, an error
message is issued and the function returns <CODE>NULL</CODE>.
Otherwise, the function returns <CODE>l</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">

/* Fill a flist with diagonal points using mw_enlarge_flist 
   up to a random size, unknown by advance.
*/

Flist l; 

l = mw_change_flist(NULL,2,0,2);
if (l==NULL) mwerror(FATAL,1,"Not enough memory to continue !\n");
i=0;
do
  {
   if ((2*i == l-&gt;max_size) &amp;&amp; (!mw_enlarge_flist(l)))
       mwerror(FATAL,1,"Not enough memory to continue !\n");
   l-&gt;values[i++] = l-&gt;values[i++] = i;
  }  while (rand() != 0);
l-&gt;size=(i+1)/2;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_flist</FONT></B> - Create a <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_new_flist()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Flist</TT> structure. The fields are initialized
to 0 or <TT>NULL</TT>value.
The function returns the address of the new structure, or
<TT>NULL</TT> if not enough memory is available.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist l;

/*
  Define the structure
*/
l = mw_new_flist();
if (!l) mwerror(FATAL,1,"Not enough memory to define the list !\n");

/* 
  At that time, the FList is empty.
*/
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_realloc_flist</FONT></B> - Realloc the array of a <TT>Flist</TT></P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_realloc_flist(l,n)</P><P>Flist l;</P><P>int n;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function performs a memory reallocation on the array
<CODE>l-&gt;values</CODE> so that at most <I>n</I> elements can be recorded.</P><P>If not enough memory is available to perform the reallocation, an error
message is issued and the function returns <TT>NULL</TT>.
Otherwise, the function returns <CODE>l</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Flist l;

/* 
   Allocate l to handle at most 1000 samples of 500-tuple of 
   floating point values, the default number of samples being 1000. 
*/
l = mw_change_flist(NULL,1000,1000,500);
if (!l) mwerror(FATAL,1,"Not enough memory to continue !\n");

/*
    ... (statement)...
*/

/*
   Now we need space for 20 samples only : by doing reallocation,
   we allow to free some memory.
*/
l = mw_realloc_flist(l,20);
if (!l) mwerror(FATAL,1,"Couldn't realloc flist !\n");


</PRE><!--TOC subsection The structure Flists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">6.7.4</A>&#XA0;&#XA0;The structure Flists</H3><!--SEC END --><P>
<A NAME="curves-polygons_flists"></A></P><P>A <TT>Flists</TT><A NAME="@default99"></A> structure is an array of <TT>Flist</TT> not necessary of the same size.
As for the <TT>Flist</TT> structure, the <TT>Flists</TT> structure contains a <CODE>data</CODE> 
field that can be used to record any additional information
(when no information is available, it is set to <CODE>NULL</CODE>).
The size of the space pointed by <CODE>data</CODE> is set in <CODE>data_size</CODE>.</P><PRE CLASS="verbatim">typedef struct flists {
  char cmt[mw_cmtsize];     /* Comments */
  char name[mw_namesize];   /* Name */
  int size;          /* size (number of lists) */
  int max_size;      /* currently allocated size (maximum number of lists) */
  Flist *list;       /* array of Flist */
  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */
} *Flists;

</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc86">6.7.5</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="curves-polygons_flists-file_type"></A></P><P>The list of the available native formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_FLISTS"</CODE><A NAME="@default100"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc87">6.7.6</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="curves-polygons_flists_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Flists</TT> type. The list is in alphabetical order.
Notice that these functions do not manage the <CODE>data</CODE> field.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_flists</FONT></B> - Define and allocate a <TT>Flists</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_change_flists(ls,max_size,size)</P><P>Flist ls;</P><P>int max_size,size;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the <CODE>list</CODE> array
of a <TT>Flists</TT> structure, even if no previously memory allocation was done.
The new size (number of lists) of the structure is given by <CODE>size</CODE>,
and the size to allocate (maximal number of lists) by <CODE>max_size</CODE>.</P><P>It can also create the structure if the input <CODE>ls = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_flists</CODE> and
<CODE>mw_realloc_flists</CODE>. 
Since the function can set the address of <CODE>ls</CODE>, the variable must be set 
to the return value of the function (See example below).</P><P>The function <CODE>mw_change_flists</CODE> returns <TT>NULL</TT> if not enough memory is 
available to allocate the structure or the <CODE>list</CODE> array, and an error 
message is issued. 
Your code should check this return value to eventually send a fatal error 
message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flists ls;

/* 
   Allocate ls to handle at most 10 lists, the current number of
   lists being 0 (no list).
*/
ls = mw_change_flists(NULL,10,0);
if (!ls) mwerror(FATAL,1,"Not enough memory to continue !\n");


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_flists</FONT></B> - Copy the lists contained in a <TT>Flists</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_copy_flists(in,out)</P><P>Flists in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the <CODE>list</CODE> array and <CODE>data</CODE> field 
of the <TT>Flists</TT> structure <CODE>in</CODE> into <CODE>out</CODE> : 
each list contained in <CODE>in</CODE> are duplicated. 
The duplicated <TT>Flists</TT> <CODE>out</CODE> is allocated to at least
the current size of <CODE>in</CODE>. </P><P>Since the function can set the address of <CODE>out</CODE>, the variable must be set 
to the return value of the function (See example below).</P><P>The function <CODE>mw_copy_flists</CODE> returns <TT>NULL</TT> if not enough memory is 
available to allocate the structure or the <CODE>list</CODE> array, and an error 
message is issued. 
Your code should check this return value to eventually send a fatal error 
message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flists in,out=NULL;

/* 
   Allocate ls to handle at most 10 lists, the current number of
   lists being 3.
*/
ls = mw_change_flists(NULL,10,3);
if (!ls) mwerror(FATAL,1,"Not enough memory to continue !\n");


/* ... (Here fill the lists) ... */

/*
 Copy in into out. Allocated size for out is 3 lists.
*/
out=mw_copy_flists(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory to copy the lists !\n");


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_flists</FONT></B> - Delete the lists and the <TT>Flists</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_flists(ls)</P><P>Flist ls;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deletes the lists contained in the <CODE>list</CODE> array,
and the structure <TT>Flists</TT> itself.
Warning : the memory of the user-defined field <CODE>data</CODE> is not freed.
If this field has been allocated, you should free it before calling
<CODE>mw_delete_flists</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist ls;
int i;

/*
    ... (Assume ls has been previoulsy allocated)...
*/

/* 
  Free the lists, including data field. 
*/
for (i=ls-&gt;size;i--;) if (ls-&gt;list[i]-&gt;data) free(ls-&gt;list[i]-&gt;data);
if (ls-&gt;data) free(ls-&gt;data);
mw_delete_flists(ls);


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_enlarge_flists</FONT></B> - Enlarge the number of lists a <TT>Flists</TT> may contain</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_enlarge_flist(ls)</P><P>Flist ls;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function performs a memory reallocation on the array
<CODE>ls-&gt;list</CODE> to increase the number of lists that can be recorded.
The enlargement factor is fixed by the constant <CODE>MW_LIST_ENLARGE_FACTOR</CODE>
defined in the include file <CODE>list.h</CODE>.
This function is useful when one does not know by advance the number
of lists, and when one wish to avoid multiple reallocations.</P><P>If not enough memory is available to perform the reallocation, an error
message is issued and the function returns <CODE>NULL</CODE>.
Otherwise, the function returns <CODE>ls</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">

/* Fill a flists with lists until the user enters 'Q'.
*/

Flist ls; 
Flist l;
char c;

ls = mw_change_flists(NULL,10,0);
if (ls==NULL) mwerror(FATAL,1,"Not enough memory to continue !\n");
do {
  if (ls-&gt;size == ls-&gt;max_size) 
    if (mw_enlarge_flists(ls)==NULL)
      mwerror(FATAL,1,"Not enough memory to continue !\n");
  l = mw_change_flist(NULL,10,10,2);
  if (l==NULL) mwerror(FATAL,1,"Not enough memory to continue !\n");
  mw_clear_flist(l,1.0)
  ls-&gt;list[ls-&gt;size++] = l;
  scanf("%c",&amp;c);
    } while (c!='Q');
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_flists</FONT></B> - Create a <TT>Flists</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_new_flists()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Flists</TT> structure. The fields are initialized
to 0 or <TT>NULL</TT>value.
The function returns the address of the new structure, or
<TT>NULL</TT> if not enough memory is available.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flists ls;

/*
  Define the structure
*/
ls = mw_new_flists();
if (!ls) mwerror(FATAL,1,"Not enough memory to define the lists !\n");

/* 
  At that time, the FLists is empty (no lists).
*/
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_realloc_flists</FONT></B> - Realloc the list array of the <TT>Flists</TT></P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_realloc_flists(ls,n)</P><P>Flists ls;</P><P>int n;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function performs a memory reallocation on the array
<CODE>ls-&gt;list</CODE> so that at most <I>n</I> lists can be recorded.</P><P>If not enough memory is available to perform the reallocation, an error
message is issued and the function returns <TT>NULL</TT>.
Otherwise, the function returns <CODE>ls</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Flists ls;

/*
   Allocate ls to handle 10 lists.
*/

ls = mw_new_flists();
if (!ls) mwerror(FATAL,1,"Not enough memory to continue !\n");
ls = mw_realloc_flists(ls,10);
if (!ls) mwerror(FATAL,1,"Not enough memory to continue !\n");

</PRE><!--TOC subsection The structures Dlist and Dlists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">6.7.7</A>&#XA0;&#XA0;The structures Dlist and Dlists</H3><!--SEC END --><P>
<A NAME="curves-polygons_dlist-dlists"></A></P><P>As for curves, <TT>Dlist</TT><A NAME="@default101"></A> and <TT>Dlists</TT><A NAME="@default102"></A> are the counterpart 
of <TT>Flist</TT> and <TT>Flists</TT> :
the only difference between them is that values are of type double instead of float.
Since you can easily imagine how it works, we will not document the functions
associated to <TT>Dlist</TT> and <TT>Dlists</TT>. Just change the letter <CODE>f</CODE> to <CODE>d</CODE>.</P><PRE CLASS="verbatim">typedef struct dlist {

  int size;          /* size (number of elements) */
  int max_size;      /* currently allocated size (number of ELEMENTS) */
  int dim;           /* dimension (number of components per element) */

  double *values;    /* values = size * dim array
                          nth element = values[n*dim+i], i=0..dim-1 */

  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */

} *Dlist;
</PRE><PRE CLASS="verbatim">typedef struct dlists {

  char cmt[mw_cmtsize];     /* Comments */
  char name[mw_namesize];   /* Name */

  int size;          /* size (number of elements) */
  int max_size;      /* currently allocated size (number of ELEMENTS) */

  Dlist *list;       /* array of Dlist */

  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */

} *Dlists;

</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">6.7.8</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="curves-polygons_dlist-dlists-file_type"></A></P><P>Here is the list of available native formats associated to <TT>Dlist</TT> internal type :
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_DLIST"</CODE><A NAME="@default103"></A> MegaWave2 binary format.
</LI></OL><P>The list of available native formats associated to <TT>Dlists</TT> internal type is
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_DLISTS"</CODE><A NAME="@default104"></A> MegaWave2 binary format.
</LI></OL><!--TOC chapter Level sets and morphological structures-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc90">Chapter&#XA0;7</A>&#XA0;&#XA0;Level sets and morphological structures</H1><!--SEC END --><P>
<A NAME="morpho"></A>
</P><P>This section describes the various morphological structures used to represent
images. We call morphological representation<A NAME="@default105"></A>
any complete decomposition which
is invariant by (local or global) contrast changes. More precisely, 
if  <FONT COLOR=red><I>R</I></FONT> is the representation operator and <I>c</I> a contrast change function
<A NAME="@default106"></A> (that is, any non-decreasing real function), the contrast change
invariance 
corresponds to the property  <FONT COLOR=red><I>R</I></FONT>(<I>c</I>(<I>u</I>)) = <I>c</I>( <FONT COLOR=red><I>R</I></FONT>(<I>u</I>)) for every image <I>u</I>.
Exemples of such representations are based by level sets<A NAME="@default107"></A>, level lines and connected
components of level sets.</P><P>We begin our description with the <TT>Shape</TT><A NAME="@default108"></A> and <TT>Shapes</TT> structures. These are not
the first developed in MegaWave2, but they are going to play an increasing role :
they allow to handle level sets and connected components of level sets in a tree
structure very useful to develop morphological shape-based applications.
In addition, computation of these structures can be performed in a way faster
than the traditional level set decomposition, using the Fast Level Set
Transform<A NAME="@default109"></A> (<EM>FLST</EM><A NAME="@default110"></A> in short).
The FLST has been created by Pascal Monasse during its PhD thesis.
The following description of the <TT>Shape</TT> and <TT>Shapes</TT> structures has been
written with his help.</P><!--TOC section Shape-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">7.1</A>&#XA0;&#XA0;Shape</H2><!--SEC END --><P><A NAME="shape"></A></P><P>A <TT>Shape</TT><A NAME="@default111"></A> is a set of pixels based on a level set of an
image. It can be a level set itself, one of its connected component,
or a shape as defined by the FLST (see module <CODE>flst</CODE>) that is,
in short, a connected component of a level set with filled holes.
Notice that a <TT>Shape</TT> has no reference to the image in which it is extracted,
so a <TT>Shape</TT> can be constructed from scratch, without an initial image.</P><P>The basic fields are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>inferior_type</CODE>: a nonzero value indicates that the <TT>Shape</TT>
corresponds to a lower level set<A NAME="@default112"></A> of level &#X3BB; ({<I>x</I> : <I>u</I>(<I>x</I>) &#X2264; &#X3BB;}<SUP><A NAME="text1" HREF="#note1">1</A></SUP> or 
{<I>x</I> : <I>u</I>(<I>x</I>) &lt; &#X3BB;}, those sets being noted in short by
[<I>u</I> &#X2264; &#X3BB;] and [<I>u</I>&lt;&#X3BB;]),
while a zero value indicates an upper level set<A NAME="@default113"></A> ([<I>u</I>&#X2265; &#X3BB;] or [<I>u</I>&gt;&#X3BB;]).
</LI><LI CLASS="li-itemize"><CODE>value</CODE>: the gray level &#X3BB; of the level set.
</LI><LI CLASS="li-itemize"><CODE>area</CODE>: the area, i.e., the number of pixels of the shape.
</LI><LI CLASS="li-itemize"><CODE>pixels</CODE>: an array of pixel coordinates containing <CODE>area</CODE>
elements.
</LI><LI CLASS="li-itemize"><CODE>boundary</CODE>: a <TT>Flist</TT> of dimension two containing the
vertices of a polygonal representation of the boundary.
</LI><LI CLASS="li-itemize"><CODE>open</CODE>: a nonzero value indicates that the <TT>Shape</TT> meets
the border of the image. The name of this field comes from the fact that if
the boundary is a curve, it is an open curve.
</LI></UL><P>
Moreover, there is an additional field <CODE>removed</CODE> indicating if the
shape is to be taken into account. This field is interesting only in the case
where the shape is part of a structure.</P><P>A shape is supposed to be included in a tree structure driven by
inclusion. This is the case for example when the shapes are all lower (or all
upper) level sets: in this case the tree has no ramification, since the level
sets are monotone for inclusion. There is a true tree structure when they are
<EM>connected components</EM> of lower (or upper) level sets. This is also true
for the shapes in the sense of the FLST.</P><P>In the vocabulary of graphs, the edges of the tree adjacent to the shape are
stored in the fields <CODE>parent</CODE>, <CODE>child</CODE> and
<CODE>next_sibling</CODE>. The <CODE>child</CODE> field corresponds actually to the
first child of the shape. The other ones can be recovered by following the
pointers <CODE>next_sibling</CODE>. For example, to call the function <CODE>foo</CODE>
successively with the children of shape <CODE>s</CODE> as argument, we would write
the following code snippet:</P><P><CODE>for(c = s-&gt;child; c != NULL; c=c-&gt;next_sibling) foo(c);</CODE></P><P>The parent contains the shape while the shape contains its children. Functions
for accessing these three fields are given: they take into account that
some shapes may be ignored, as indicated by the field <CODE>removed</CODE>.</P><P>It is dangerous to remove the root of the tree by setting its <CODE>removed</CODE>
field: many functions rely on the fact that we have a root.</P><!--TOC subsection The structure Shape-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc92">7.1.1</A>&#XA0;&#XA0;The structure Shape</H3><!--SEC END --><P>
<A NAME="shape_structure"></A></P><P>The meaning of the different fields is explained above. There are two
additional fields, <CODE>data</CODE> and <CODE>data_size</CODE>, whose content is left
to the choice of the user. <CODE>data</CODE> is supposed to point to a memory
extent of (at least) <CODE>data_size</CODE> bytes, if this value is
positive. Failure in this assumption may lead to a memory corruption in
I/O operations. </P><PRE CLASS="verbatim">typedef struct shape
{
  char inferior_type; /* Indicates if it is extracted from a superior 
                         or inferior level set */
  float value; /* Limiting gray-level of the level set */
  char open; /* Indicates if the shape meets the border of the image */
  int area; /* Area of the shape = area of the cc of level set 
                                 + areas of the holes */
  char removed; /* Indicates whether the shape exists or not */

  Point_plane pixels; /* The array of pixels contained in the shape */

  Flist boundary; /* The boundary curve defining the shape */

  /* Data to include it in a tree. It has a parent (the smallest containing 
     shape), children (the largest contained shapes, whose first is pChild 
     and the others are its siblings), and siblings (the other children of 
     its parent) */
  struct shape *parent, *next_sibling, *child;

  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */

} *Shape;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">7.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="shape-file_type"></A></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_SHAPE"</CODE><A NAME="@default114"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">7.1.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="shape_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Shape</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_shape</FONT></B> - Create a <TT>Shape</TT> structure if necessary</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shape mw_change_shape(sh)</P><P>Shape sh;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a <TT>Shape</TT> structure if <CODE>sh</CODE> is not
already defined. 
The fields are initialized to 0 or <TT>NULL</TT>value.
The function returns the address of the structure, or
<TT>NULL</TT> if not enough memory is available.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Shape sh=NULL;

/*
  Define the structure
*/
sh = mw_change_shape(sh);
if (!sh) mwerror(FATAL,1,"Not enough memory to define the shape !\n");

/* 
  At that time, the shape is empty.
*/
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_shape</FONT></B> - Free the memory allocated for a <TT>Shape</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_shape(sh)</P><P>Shape sh;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deletes the <CODE>pixels</CODE> array, the <CODE>boundary</CODE> <TT>Flist</TT>,
the <CODE>data</CODE> array (if needed), and the structure itself.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">

Shape sh;

/*
  Define the structure
*/
sh = mw_new_shape();
if (!sh) mwerror(FATAL,1,"Not enough memory to define the shape !\n");

/*
    ...(computation of the shape)...
*/

/* 
  Free the shape, including data field. 
*/
mw_delete_shape(sh);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_get_first_child_shape</FONT></B> - Return the first child of a shape in the tree</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shape mw_get_first_child_shape(sh)</P><P>Shape sh;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the first child of the shape <CODE>sh</CODE>, skipping
removed shapes (field <CODE>removed</CODE>). This is equivalent to
<CODE>sh-&gt;child</CODE> if this shape is not removed.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_get_next_sibling_shape</FONT></B> - Return the next sibling of a shape in the
tree</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shape mw_get_next_sibling_shape(sh)</P><P>Shape sh;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the next sibling (shape sharing the same parent) of
the shape <CODE>sh</CODE>, skipping removed shapes (field <CODE>removed</CODE>). This
is equivalent to <CODE>sh-&gt;next_sibling</CODE> if this shape is not removed.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_get_not_removed_shape</FONT></B> - Return the first shape not removed in subtree</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shape mw_get_not_removed_shape(sh)</P><P>Shape sh;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns <CODE>sh</CODE> if this shape is not removed (field
<CODE>removed</CODE>), else it is equivalent to <CODE>mw_get_first_child(sh)</CODE> that
is, it returns the first child, skipping removed shapes.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_get_parent_shape</FONT></B> - Return the parent of the shape in the tree</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shape mw_get_parent_shape(sh)</P><P>Shape sh;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the parent of
the shape <CODE>sh</CODE>, skipping removed shapes (field <CODE>removed</CODE>). This
is equivalent to <CODE>sh-&gt;parent</CODE> if this shape is not removed.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_get_smallest_shape</FONT></B> - Return the smallest shape containing a given pixel</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shape mw_get_smallest_shape(shs,x,y)</P><P>Shapes shs;
int x,y;</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the smallest shape containing the pixel at position
(<I>x</I>,<I>y</I>), ignoring removed shapes (field <CODE>removed</CODE>). This is equivalent
to <CODE>shs-&gt;smallest_shape[y*shs-&gt;ncol+x]</CODE> provided this shape is not
removed.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_shape</FONT></B> - Create a <TT>Shape</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shape mw_new_shape()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Shape</TT> structure. The fields are initialized
to 0 or <TT>NULL</TT>value.
The function returns the address of the new structure, or
<TT>NULL</TT> if not enough memory is available.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Shape sh;

/*
  Define the structure
*/
sh = mw_new_shape();
if (!sh) mwerror(FATAL,1,"Not enough memory to define the shape !\n");

/* 
  At that time, the shape is empty.
*/
</PRE><!--TOC section Shapes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc95">7.2</A>&#XA0;&#XA0;Shapes</H2><!--SEC END --><P><A NAME="shapes"></A></P><P>A <TT>Shapes</TT><A NAME="@default115"></A> structure is a collection of shapes extracted from an image. 
The fields <CODE>nrow</CODE> and <CODE>ncol</CODE> are the dimensions of the image. 
The field <CODE>interpolation</CODE> is the convention used to extract level
lines. Currently, the valid values are 0 (module <CODE>flst</CODE>) and 1 (module
<CODE>flst_bilinear</CODE>).</P><P>The elements are stored consecutively in the array <CODE>the_shapes</CODE> of size
<CODE>nb_shapes</CODE>. By convention, the shape at index 0 is the root of the
tree.</P><P>The field <CODE>smallest_shape</CODE> is an array of size
<CODE>nrow</CODE>&#XD7;<CODE>ncol</CODE> giving for each pixel the smallest shape in
the tree that contains it. By going upward in the tree, it is possible to know
all the shapes containing a given pixel.</P><!--TOC subsection The structure Shapes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc96">7.2.1</A>&#XA0;&#XA0;The structure Shapes</H3><!--SEC END --><P>
<A NAME="shapes_structure"></A></P><P>The meaning of the fields is explained above. The fields <CODE>data_size</CODE>
and <CODE>data</CODE> are left to the user.
</P><PRE CLASS="verbatim">typedef struct shapes
{
  char cmt[mw_cmtsize];   /* Comments */
  char name[mw_namesize]; /* Name of the set */
  int nrow;               /* Number of rows (dy) of the image */
  int ncol;               /* Number of columns (dx) of the image */
  int interpolation;      /* Interpolation used for the level lines:
                             0=nearest neighbor, 1=bilinear */
  Shape the_shapes; /* Array of the shapes.
                       The root of the tree is at index 0 */
 
  int nb_shapes; /* The number of shapes (the size of the array the_shapes) */
 
  /* Link between pixels and shapes */
  Shape *smallest_shape; /* An image giving for each pixel
                            the smallest shape containing it */
 
  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */
 
} *Shapes;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc97">7.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="shapes-file_type"></A></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_SHAPES"</CODE><A NAME="@default116"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc98">7.2.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="shapes_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Shapes</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_shapes</FONT></B> - Allocate the fields of a <TT>Shapes</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shapes mw_alloc_shapes(shs, nrow, ncol, value)</P><P>Shapes shs;</P><P>int nrow, ncol;</P><P>float value; /* gray level value of the root */
</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function takes as argument a <TT>Shapes</TT> structure and returns it
after having allocated all necessary fields. The input <CODE>nrow</CODE> and 
<CODE>ncol</CODE> are the dimensions of the image. 
The field <CODE>the_shapes</CODE> is allocated to contain
<CODE>nrow</CODE>&#XD7;<CODE>ncol</CODE>+1 shapes, which is the maximal number of 
shapes extracted by the FLST (see module <CODE>flst</CODE>). 
In fact, only one shape is put, the root of the tree, supposed to be 
extracted at gray level <CODE>value</CODE>. 
The field <CODE>smallest_shape</CODE> is also allocated and
initialized, each pixel having as smallest shape the root.</P><P>The function returns <CODE>shs</CODE>, or <TT>NULL</TT> if not enough memory is available
to do the allocation.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Shapes shs;
Fimage image; /* Assume image is allocated */

/*
  Define the structure
*/
shs = mw_new_shapes();
if (!shs) mwerror(FATAL,1,"Not enough memory to define the shapes !\n");

/* 
  At that time, the structure exists but fields are empty : alloc them
  to handle the Fimage image.
*/
if (!mw_alloc_shapes(shs, image-&gt;nrow, image-&gt;ncol, image-&gt;gray[0]))
  mwerror(FATAL,1,"Not enough memory to alloc the shapes !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_shapes</FONT></B> - (Re)alloc the fields of a <TT>Shapes</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shapes mw_change_shapes(shs, nrow, ncol, value)</P><P>Shapes shs;</P><P>int nrow, ncol;</P><P>float value; /* gray level value of the root */
</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
If the input pointer <CODE>shs</CODE> is <TT>NULL</TT>, create a new
structure, otherwise delete the currently allocated fields 
(if any) and call <CODE>mw_alloc_shapes()</CODE>.</P><P>The function returns the new structure or <CODE>shs</CODE>, or <TT>NULL</TT> if not enough 
memory is available to do the allocation.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Shapes shs=NULL;
Fimage image; /* Assume image is allocated */

/*
  Define the structure and alloc the field to handle the Fimage image.
*/
shs = mw_change_shapes(shs, image-&gt;nrow, image-&gt;ncol, image-&gt;gray[0]);
if (!shs) mwerror(FATAL,1,"Not enough memory to alloc the shapes !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_shapes</FONT></B> - Delete a <TT>Shapes</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_shapes(shs)</P><P>Shapes shs;</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function frees the allocated fields and the
structure itself. 
After this call, the memory pointed to by <CODE>shs</CODE> must
not be accessed any longer.
Warning : in the contrary to <CODE>mw_delete_shape()</CODE>, the memory of the 
user-defined field <CODE>data</CODE> is not freed.
If this field has been allocated, you should free it before calling
<CODE>mw_delete_shapes()</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Shapes shs=NULL;
Fimage image; /* Assume image is allocated */

/*
  Define the structure and alloc the field to handle the Fimage image.
*/
shs = mw_change_shapes(shs, image-&gt;nrow, image-&gt;ncol, image-&gt;gray[0]);
if (!shs) mwerror(FATAL,1,"Not enough memory to alloc the shapes !\n");

/*
  ... (do the computation) ...
*/

/* 
  Delete the shapes
*/
if (!shs-&gt;data) free(shs-&gt;data);
mw_delete_shapes(shs);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_shapes</FONT></B> - Create a <TT>Shapes</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Shapes mw_new_shapes()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Shapes</TT> structure. The fields are initialized
to 0 or <TT>NULL</TT>value.
The function returns the address of the new structure, or
<TT>NULL</TT> if not enough memory is available.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Shapes shs;

/*
  Define the structure
*/
shs = mw_new_shapes();
if (!shs) mwerror(FATAL,1,"Not enough memory to define the shapes !\n");

/* 
  At that time, the structure exists but is empty.
*/
</PRE><!--TOC section Point with a type field-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc99">7.3</A>&#XA0;&#XA0;Point with a type field</H2><!--SEC END --><P><A NAME="point_type"></A>


</P><P>The <TT>Point_type</TT><A NAME="@default117"></A> structure is complementary to the <TT>Point_curve</TT> structure (See Section&#XA0;<A HREF="#curves-polygons_point">6.1</A>): it
is used to record the type of the point, a valuable information in morphological shape-based algorithms.
While the <TT>Point_curve</TT> structure was mainly defined to be used as part of a <TT>Curve</TT> structure, the <TT>Point_type</TT> structure
is related to the <TT>Morpho_line</TT> structure (See Section&#XA0;<A HREF="#morpho_line">7.7</A>).</P><!--TOC subsection The structure Point_type-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc100">7.3.1</A>&#XA0;&#XA0;The structure Point_type</H3><!--SEC END --><P>
<A NAME="point_type-structure"></A></P><P>This is the C definition of the structure:
</P><PRE CLASS="verbatim">typedef struct point_type {
  unsigned char type; /* Type of the point, e.g. (exact meaning can vary; See modules)
                         0 : regular point;
                         1 : point in the image's border;
                         2 : T-junction;
                         3 : Tau-junction;
                         4 : X-junction;
                         5 : Y-junction.
                         */
  struct point_type *previous; /* Pointer to the previous point (may be NULL) */
  struct point_type *next; /* Pointer to the next point (may be NULL) */
} *Point_type;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc101">7.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="point_type-file_type"></A></P><P>Not available: at this time, the <TT>Point_type</TT> object cannot be used as input/output variables of modules.
It can be saved as part of a <TT>Morpho_line</TT> or <TT>Fmorpho_line</TT> structure.</P><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc102">7.3.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="point_type-function"></A></P><P>The following is a description of all the functions related to 
the <TT>Point_type</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_point_type</FONT></B> - Define the point_type structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_type mw_change_point_type(pt)</P><P>Point_type pt;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a <TT>Point_type</TT> structure if the input <CODE>pt = NULL</CODE>.
It is provided despite the<BR>
<CODE>mw_new_point_type()</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_point_type</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Point_type pt=NULL; /* Internal use: no Input neither Output of module */

/* Define a point type as image border */

pt = mw_change_point_type(pt);
if (pt == NULL) mwerror(FATAL,1,"Not enough memory.\n");
pt-&gt;type = 1; /* image border */
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_point_type</FONT></B> - Copy all point types starting from the given one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_type mw_copy_point_type(in,out)</P><P>Point_type in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the current point type and the next point types contained in the chain defined at the starting point type <CODE>in</CODE>. 
The result is put in <CODE>out</CODE>, which
may not be a predefined structure : in case of <CODE>out=NULL</CODE>, the <CODE>out</CODE>
structure is allocated.</P><P>The function <CODE>mw_copy_point_type</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Point_type in; /* Predefined point */
Point_type out=NULL; 

out=mw_copy_point_type(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_point_type</FONT></B> - Deallocate the point_type structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_point_type(pt)</P><P>Point_type pt;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the <TT>Point_type</TT> structures starting from
the given <CODE>pt</CODE>, including this point itself.
You should set <CODE>pt = NULL</CODE> after this call since the address pointed
by <CODE>pt</CODE> is no longer valid.
To deallocate a point only and not all the next points of the
chain, just use <CODE>free(pt)</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Remove the first point_type of an existing morpho_line */

Morpho_line ll; /* Existing morpho_line (e.g. Input of module) */
Point_type pt;  /* Internal use */

pt = ll-&gt;first_type;
ll-&gt;first_type=pt-&gt;next;
pt-&gt;next-&gt;previous = NULL;
free(pt);
pt = NULL;

/* Remove all point_type of an existing morpho_line */

mw_delete_point_type(ll-&gt;first_type);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_point_type</FONT></B> - Create a new point_type structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_type mw_new_point_type();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Point_type</TT> structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal point structures before the end
of the module, except if they are part of an input or output curve.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Insert the point (0,0) with type 1 at the end of an existing morpho_line */

Morpho_line ll;  /* Existing morpho_line (e.g. Input of module) */
Point_curve point,p;  /* Internal use: no Input neither Output of module */
Point_type pt,t;

/* Define the point (0,0) with type 1 */
point = mw_new_point_curve();
if (point == NULL) mwerror(FATAL,1,"Not enough memory.\n");
pt = mw_new_point_type();
if (pt == NULL) mwerror(FATAL,1,"Not enough memory.\n");
point-&gt;x = point-&gt;y = 0;
pt-&gt;type=1;

/* Find the last point of the morpho_line */
p = ll-&gt;first_point; t = ll-&gt;first_type; 
while (p-&gt;next) {p=p-&gt;next; t=t-&gt;next;}

/* Insert the point */
p-&gt;next = point;
t-&gt;next = pt;
point-&gt;previous = p;
pt-&gt;previous = t;

/* Do not deallocate point_curve and point_type or morpho_line will become inconsistent */ 
</PRE><!--TOC section Horizontal segment-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc103">7.4</A>&#XA0;&#XA0;Horizontal segment</H2><!--SEC END --><P><A NAME="hsegment"></A></P><P><A NAME="@default118"></A></P><P>The <TT>Hsegment</TT> structure is useful for describing all pixels belonging to a (connected or non-connected)
set, without taking the border into consideration.
An horizontal segment is given by a left and a right point. 
If the shape of the set is more height than width, you should rather use vertical segments
(not yet defined).
The morpho set defined in Section&#XA0;<A HREF="#morpho_set">7.5</A> makes the use
of the <TT>Hsegment</TT> structure<A NAME="@default119"></A>, which defines an horizontal segment.</P><!--TOC subsection The structure Hsegment-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc104">7.4.1</A>&#XA0;&#XA0;The structure Hsegment</H3><!--SEC END --><P>
<A NAME="hsegment-structure"></A></P><P>This is the C definition of the structure <TT>Hsegment</TT>:
<A NAME="@default120"></A> 
</P><PRE CLASS="verbatim">typedef struct hsegment {
  int xstart; /* Left x-coordinate of the segment */
  int xend;   /* Right x-coordinate of the segment */
  int y;      /* y-coordinate of the segment */
  struct hsegment *previous; /* Pointer to the previous segment (may be NULL) */
  struct hsegment *next;     /* Pointer to the next segment (may be NULL) */
} *Hsegment;

</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc105">7.4.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="hsegment-file_type"></A></P><P>Not available: at this time, the <TT>Hsegment</TT> object cannot be used as input/output variables of modules.
It can be saved as part of a <TT>Morpho_set</TT> structure.</P><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc106">7.4.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="hsegment-function"></A></P><P>The following is a description of all the functions related to 
the <TT>Hsegment</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_hsegment</FONT></B> - Define the hsegment structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Hsegment mw_change_hsegment(seg)</P><P>Hsegment seg;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a <TT>Hsegment</TT> structure if the input <CODE>seg = NULL</CODE>.
It is provided despite the<BR>
<CODE>mw_new_hsegment()</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_hsegment</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Hsegment seg=NULL; /* Internal use: no Input neither Output of module */

/* Define the horizontal segment (0,10)-(200,10) */

seg = mw_change_hsegment(seg);
if (seg == NULL) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_hsegment</FONT></B> - Deallocate a chain of horizontal segments</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_hsegment(seg)</P><P>Hsegment seg;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the chain of horizontal segments starting
from <CODE>seg</CODE>. Previous segments are not deallocated.
You should set <CODE>seg = NULL</CODE> after this call since the address pointed
by <CODE>seg</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Hsegment seg0,newseg,oldseg; 
int i;

/* Create a chain of 10 horizontal segments, starting from seg0 */

if (!(seg0=mw_new_hsegment())) mwerror(FATAL,1,"Not enough memory.\n");
seg0-&gt;xstart=0; seg0-&gt;xend=200; seg0-&gt;y=1;
oldseg=seg0;
for (i=2; i&lt;=10; i++)
{
  if (!(newseg=mw_new_hsegment())) mwerror(FATAL,1,"Not enough memory.\n");
  newseg-&gt;xstart=0; newseg-&gt;xend=200; newseg-&gt;y=i;
  newseg-&gt;previous=oldseg;
  oldseg-&gt;next=newseg;
  oldseg=newseg;
}

/* .
   .
   (statement)
   .
   .
*/

/* Deallocate the chain of segments */
mw_delete_hsegment(seg0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_hsegment</FONT></B> - Create a new hsegment structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Hsegment mw_new_hsegment()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a new <TT>Hsegment</TT> structure, or <TT>NULL</TT> if not enough 
memory is available to allocate the structure. 
Your code should check this return value to send an error message in the 
<TT>NULL</TT> case, and do appropriate statement.</P><P>The new structure is created with fields set to 0 or <TT>NULL</TT>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Hsegment seg; /* Internal use: no Input neither Output of module */

/* Define the horizontal segment (0,10)-(200,10) */

if (!(seg=mw_new_hsegment())) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;
</PRE><!--TOC section Morpho set-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc107">7.5</A>&#XA0;&#XA0;Morpho set</H2><!--SEC END --><P><A NAME="morpho_set"></A></P><P>We call morpho set <A NAME="@default121"></A> any connected component of set of the form
{<I>x</I> : &#X3BB;<SUB>1</SUB> &#X2264; <I>u</I>(<I>x</I>) &#X2264; &#X3BB;<SUB>2</SUB>}, this set being noted in short by
[&#X3BB;<SUB>1</SUB> &#X2264; <I>u</I> &#X2264; &#X3BB;<SUB>2</SUB>]. Notice that for &#X3BB;<SUB>1</SUB>=&#X2212;&#X221E; we get
a lower level set<A NAME="@default122"></A> and for &#X3BB;<SUB>2</SUB>=+&#X221E; an upper level 
set<A NAME="@default123"></A>. In the case &#X3BB;<SUB>1</SUB> = &#X3BB;<SUB>2</SUB> the morpho set
will be called iso set<A NAME="@default124"></A>.
The structure <TT>Morpho_set</TT><A NAME="@default125"></A> can be used to handle such
morpho set. A <TT>Morpho_set</TT> is given by a list of horizontal segments (See Section&#XA0;<A HREF="#hsegment">7.4</A>),
where levels &#X3BB;<SUB>1</SUB> and &#X3BB;<SUB>2</SUB> are recorded. Some additional information can
be recorded, such as the neighbor morpho sets. 
Please notice that some fields are likely to change in the future.</P><!--TOC subsection The structure Morpho_set-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc108">7.5.1</A>&#XA0;&#XA0;The structure Morpho_set</H3><!--SEC END --><P>
<A NAME="mset-structure"></A></P><P>This is the C definition of the structure <TT>Morpho_set</TT>:
<A NAME="@default126"></A> 
</P><PRE CLASS="verbatim">typedef struct morpho_set {
  unsigned int num;      /* Morpho set number (range in the Morpho_sets struct.) */
  Hsegment first_segment; /* Pointer to the first segment of the morpho set */
  Hsegment last_segment;  /* Pointer to the last segment of the morpho set */  
  float minvalue;        /* Minimum gray level value of this set */
  float maxvalue;        /* Maximum gray level value of this set */
  unsigned char stated;  /* 1 if this m.s. has already been stated, 0 otherwise */
  int area;              /* Area of the set (number of pixels belonging to this set) */
  struct morpho_sets *neighbor; /* Pointer to a chain of neighbor morpho sets (may be NULL)*/
} *Morpho_set;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc109">7.5.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="mset-file_type"></A></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_MORPHO_SET"</CODE><A NAME="@default127"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc110">7.5.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="mset-function"></A></P><P>The following is a description of all the functions related to 
the <TT>Morpho_set</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_morpho_set</FONT></B> - Define a morpho set, if not already defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_set mw_change_morpho_set(ms)</P><P>Morpho_set ms;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a <TT>Morpho_set</TT> structure if the input <CODE>ms = NULL</CODE>.
It is provided despite the<BR>
<CODE>mw_new_morpho_set()</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_morpho_set</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_set ms=NULL; /* Internal use: no Input neither Output of module */
Hsegment seg=NULL;

/* Define a morpho set containing one segment only */

if (!(seg=mw_change_hsegment(seg)) ||
    !(ms=mw_change_morpho_set(ms))) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;

ms-&gt;first_segment=seg;
ms-&gt;minvalue=0.0;
ms-&gt;maxvalue = 1.0;
ms-&gt;area=201;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_morpho_set</FONT></B> - Copy a morpho set into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_set mw_copy_morpho_set(in,out)</P><P>Morpho_set in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the <TT>Morpho_set</TT> <CODE>in</CODE> into <CODE>out</CODE>.
The chain of segments are also duplicated.
The result is put in <CODE>out</CODE>, which may not be a predefined structure : in case 
of <CODE>out=NULL</CODE>, the <CODE>out</CODE> structure is allocated.</P><P>The function <CODE>mw_copy_morpho_set</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_set in; /* Predefined morpho_set */
Morpho_set out=NULL; 

out=mw_copy_morpho_set(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_morpho_set</FONT></B> - Deallocate a morpho set</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_morpho_set(ms)</P><P>Morpho_set ms;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the <TT>Morpho_set</TT> <CODE>ms</CODE>, including the
chain of horizontal segments.
You should set <CODE>ms = NULL</CODE> after this call since the address pointed
by <CODE>ms</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_set ms; /* Internal use: no Input neither Output of module */
Hsegment seg;

/* Define a morpho set containing one segment only */

if (!(seg=mw_new_hsegment()) ||
    !(ms=mw_new_morpho_set())) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;

ms-&gt;first_segment=seg;
ms-&gt;minvalue=0.0;
ms-&gt;maxvalue = 1.0;
ms-&gt;area=201;

/* .
   .
   (statement)
   .
   .
*/

/* Deallocate the morpho_set */
mw_delete_morpho_set(ms);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_morpho_set</FONT></B> - Return the number of segments a morpho set contains</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_morpho_set(ms)</P><P>Morpho_set ms;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of segments contained in the input
<CODE>ms</CODE>.
It returns 0 if the structure is empty or undefined.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_set ms=NULL; /* Internal use: no Input neither Output of module */
Hsegment seg=NULL;

/* Define a morpho set containing one segment only */

if (!(seg=mw_change_hsegment(seg)) ||
    !(ms=mw_change_morpho_set(ms))) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;

ms-&gt;first_segment=seg;
ms-&gt;minvalue=0.0;
ms-&gt;maxvalue = 1.0;
ms-&gt;area=201;

/* This will print 1 */
printf("%d",mw_length_morpho_set(ms));
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_morpho_set</FONT></B> - Create a new morpho set</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_set mw_new_morpho_set()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a new <TT>Morpho_set</TT> structure, or <TT>NULL</TT> if not enough 
memory is available to allocate the structure. 
Your code should check this return value to send an error message in the 
<TT>NULL</TT> case, and do appropriate statement.</P><P>The new structure is created with fields set to 0 or <TT>NULL</TT>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_set ms; /* Internal use: no Input neither Output of module */
Hsegment seg;

/* Define a morpho set containing one segment only */

if (!(seg=mw_new_hsegment()) ||
    !(ms=mw_new_morpho_set())) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;

ms-&gt;first_segment=seg;
ms-&gt;minvalue=0.0;
ms-&gt;maxvalue = 1.0;
ms-&gt;area=201;
</PRE><!--TOC section Chain of morpho sets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc111">7.6</A>&#XA0;&#XA0;Chain of morpho sets</H2><!--SEC END --><P><A NAME="morpho_sets"></A>

</P><P>The <TT>Morpho_sets</TT><A NAME="@default128"></A> structure is useful to record a set (or chain) of 
morpho sets. This structure is used by the <TT>Mimage</TT> structure (See Section&#XA0;<A HREF="#mimage">7.9</A>) to 
handle all the morpho sets an image contains.</P><!--TOC subsection The structure Morpho_sets-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc112">7.6.1</A>&#XA0;&#XA0;The structure Morpho_sets</H3><!--SEC END --><P>
<A NAME="msets-structure"></A></P><P>This is the C definition of the structure <TT>Morpho_sets</TT>:
<A NAME="@default129"></A> 
</P><PRE CLASS="verbatim">typedef struct morpho_sets {
  Morpho_set morphoset;         /* Pointer to the current morpho set */
  struct morpho_sets *previous; /* Pointer to the previous morpho sets of the chain */
  struct morpho_sets *next;     /* Pointer to the next morpho sets of the chain */
  /* For use in Mimage only */
  struct morpho_line *morpholine;  /* Pointer to the associated morpho line */
} *Morpho_sets;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">7.6.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="msets-file_type"></A></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_MORPHO_SETS"</CODE><A NAME="@default130"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc114">7.6.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="msets-function"></A></P><P>The following is a description of all the functions related to 
the <TT>Morpho_sets</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_morpho_sets</FONT></B> - Define a morpho sets, if not already defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_sets mw_change_morpho_sets(mss)</P><P>Morpho_sets mss;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a <TT>Morpho_sets</TT> structure if the input <CODE>mss = NULL</CODE>.
It is provided despite the<BR>
<CODE>mw_new_morpho_sets()</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_morpho_sets</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Morpho_sets mss=NULL; /* Internal use: no Input neither Output of module */
Hsegment seg;
Morpho_set ms;

/* Define a morpho sets containing one morpho set */

if (!(seg=mw_new_hsegment()) ||
    !(ms=mw_new_morpho_set()) ||
    !(mss=mw_change_morpho_sets(mss))) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;

ms-&gt;first_segment=seg;
ms-&gt;minvalue=0.0;
ms-&gt;maxvalue = 1.0;
ms-&gt;area=201;

mss-&gt;morphoset=ms;


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_morpho_sets</FONT></B> - Copy a morpho sets into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_sets mw_copy_morpho_sets(in,out)</P><P>Morpho_sets in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the <TT>Morpho_sets</TT> <CODE>in</CODE> into <CODE>out</CODE>.
The <TT>Morpho_set</TT> pointed by the <CODE>in-&gt;morphoset</CODE> field is not only copied, but
also all the chain starting from <CODE>in</CODE>.
The neighbor <TT>Morpho_sets</TT> pointed by each <TT>Morpho_set</TT> are also copied.
The result is put in <CODE>out</CODE>, which may not be a predefined structure : in case 
of <CODE>out=NULL</CODE>, the <CODE>out</CODE> structure is allocated.</P><P>The function <CODE>mw_copy_morpho_sets</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_sets in; /* Predefined morpho_sets */
Morpho_sets out=NULL; 

out=mw_copy_morpho_sets(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_morpho_sets</FONT></B> - Deallocate a morpho sets</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_morpho_sets(mss)</P><P>Morpho_sets mss;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function frees the <TT>Morpho_set</TT> <CODE>mss-&gt;morphoset</CODE>, all the
chain starting from <CODE>mss</CODE> and it deallocates the <TT>Morpho_sets</TT> <CODE>mss</CODE> structure.
You should sets <CODE>mss = NULL</CODE> after this call since the address pointed
by <CODE>mss</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_sets mss; /* Internal use: no Input neither Output of module */
Hsegment seg;
Morpho_set ms;

/* Define a morpho sets containing one morpho set */

if (!(seg=mw_new_hsegment()) ||
    !(ms=mw_new_morpho_set()) ||
    !(mss=mw_new_morpho_sets())) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;

ms-&gt;first_segment=seg; ms-&gt;minvalue=0.0; ms-&gt;maxvalue = 1.0; ms-&gt;area=201;
mss-&gt;morphoset=ms;

/* .
   .
   (statement)
   .
   .
*/

/* Deallocate the morpho_sets mss ; ms and seg will be also deallocated. */
mw_delete_morpho_set(mss);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_morpho_sets</FONT></B> - Return the number of morpho sets a Morpho_sets structure contains</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_morpho_sets(mss)</P><P>Morpho_sets mss;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of morpho sets the <TT>Morpho_sets</TT> structure <CODE>mss</CODE> contains,
starting the chain from the current position given by <CODE>mss</CODE>.
It returns 0 if the structure is empty or undefined.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_sets mss; /* Internal use: no Input neither Output of module */
Hsegment seg;
Morpho_set ms;

/* Define a morpho sets containing one morpho set */

if (!(seg=mw_new_hsegment()) ||
    !(ms=mw_new_morpho_set()) ||
    !(mss=mw_new_morpho_sets())) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;

ms-&gt;first_segment=seg; ms-&gt;minvalue=0.0; ms-&gt;maxvalue = 1.0; ms-&gt;area=201;
mss-&gt;morphoset=ms;

/* This will print 1 */
printf("%d",mw_length_morpho_sets(mss));
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_morpho_sets</FONT></B> - Create a new morpho sets</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_sets mw_new_morpho_sets()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a new <TT>Morpho_sets</TT> structure, or <TT>NULL</TT> if not enough 
memory is available to allocate the structure. 
Your code should check this return value to send an error message in the 
<TT>NULL</TT> case, and do appropriate statement.</P><P>The new structure is created with fields set to 0 or <TT>NULL</TT>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_sets mss; /* Internal use: no Input neither Output of module */
Hsegment seg;
Morpho_set ms;

/* Define a morpho sets containing one morpho set */

if (!(seg=mw_new_hsegment()) ||
    !(ms=mw_new_morpho_set()) ||
    !(mss=mw_new_morpho_sets())) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;

ms-&gt;first_segment=seg;
ms-&gt;minvalue=0.0;
ms-&gt;maxvalue = 1.0;
ms-&gt;area=201;

mss-&gt;morphoset=ms;

</PRE><!--TOC section Morpho line-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc115">7.7</A>&#XA0;&#XA0;Morpho line</H2><!--SEC END --><P><A NAME="morpho_line"></A>
</P><P>A morpho line <A NAME="@default131"></A> is the border of a morpho set.
Assuming a right choice of grid and point connectivity so that a Jordan&#X2019;s theorem 
follows, a morpho line is a closed curve dividing the grid in two connected components : 
the interior of the morpho set and the exterior one. Actually, because an image has a finite
support, a morpho line may also intersects the image border : in such case, the
curve remains open. There is another restriction to the Jordan&#X2019;s theorem : most
of modules using morpho lines (such as <CODE>ml_extract</CODE>) consider the 4-connectivity only in
the square grid, so the border may cut the connected component to several pieces and the 
corresponding morpho lines may be self-intersecting.
Notice that if the morpho set is a level set, the corresponding border is a
level line<A NAME="@default132"></A>. And if the morpho set is an iso set, its border is
an iso line<A NAME="@default133"></A>.</P><P>The structure <TT>Morpho_line</TT><A NAME="@default134"></A> can be used to handle such
morpho line. First a <TT>Morpho_line</TT> is a curve, so the <TT>Point_curve</TT> structure is used to record it
(field <CODE>first_point</CODE>). There are additional fields, to give information on the
line (type of the points, closed or open curve) and to allow the reconstruction of the
morpho set (<CODE>minvalue</CODE>, <CODE>maxvalue</CODE>).</P><!--TOC subsection The structure Morpho_line-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc116">7.7.1</A>&#XA0;&#XA0;The structure Morpho_line</H3><!--SEC END --><P>
<A NAME="mline-structure"></A></P><P>This is the C definition of the structure <TT>Morpho_line</TT>:
<A NAME="@default135"></A> 
</P><PRE CLASS="verbatim">typedef struct morpho_line {
  Point_curve first_point;/* Pointer to the first point of the morpho_line curve */
  Point_type first_type;  /* Pointer to the first Point_type */
  float minvalue;         /* Minimum gray level value of this morpho line */
  float maxvalue;         /* Maximum gray level value of this morpho line */
  unsigned char open;     /* 0 if the morpho line is closed, opened otherwise */
  float data;             /* User-defined data field (saved) */
  void *pdata;            /* User-defined data field : pointer to something (not saved) */
   
  /* For use in Mimage only */
  struct morpho_sets *morphosets;/* Pointer to the associated morpho sets */
  unsigned int num;              /* Morpho line number (range in the chain) */
  struct morpho_line *previous;  /* Pointer to the previous m.l. (may be NULL) */
  struct morpho_line *next;      /* Pointer to the next m.l. (may be NULL) */
} *Morpho_line;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc117">7.7.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="mline-file_type"></A></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_MORPHO_LINE"</CODE><A NAME="@default136"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc118">7.7.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="mline-function"></A></P><P>The following is a description of all the functions related to 
the <TT>Morpho_line</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_morpho_line</FONT></B> - Define a morpho line, if not already defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_line mw_change_morpho_line(ml)</P><P>Morpho_line ml;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a <TT>Morpho_line</TT> structure if the input <CODE>ml = NULL</CODE>.
It is provided despite the<BR>
<CODE>mw_new_morpho_line()</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_morpho_line</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
/* Copy the curve of a morpho line into another morpho line */
Morpho_line in,out=NULL;

out=mw_change_morpho_line(out);
if (!out) mwerror(FATAL,1,"Not enough memory !\n");
out-&gt;open = in-&gt;open;
if ( ((out-&gt;first_point = mw_new_point_curve()) == NULL) ||
     ((out-&gt;first_type = mw_new_point_type()) == NULL) )
   mwerror(FATAL, 1,"Not enough memory !\n");
mw_copy_point_curve(in-&gt;first_point,out-&gt;first_point);
mw_copy_point_type(in-&gt;first_type,out-&gt;first_type);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_morpho_line</FONT></B> - Copy a morpho line into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_line mw_copy_morpho_line(in,out)</P><P>Morpho_line in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the <TT>Morpho_line</TT> <CODE>in</CODE> into <CODE>out</CODE>.
All fields are copied but the following : <CODE>pdata</CODE>, <CODE>morphosets</CODE>,
<CODE>num</CODE>, <CODE>previous</CODE> and <CODE>next</CODE>.
The result is put in <CODE>out</CODE>, which may not be a predefined structure : in case 
of <CODE>out=NULL</CODE>, the <CODE>out</CODE> structure is allocated.</P><P>The function <CODE>mw_copy_morpho_line</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_line in; /* Predefined morpho_line */
Morpho_line out=NULL; 

out=mw_copy_morpho_line(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_morpho_line</FONT></B> - Deallocate a morpho line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_morpho_line(ml)</P><P>Morpho_line ml;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the <TT>Morpho_line</TT> <CODE>ml</CODE> structure, including the
curve (<TT>Point_curve</TT>) and the chain of types (<TT>Point_type</TT>). Other pointers are
not deallicated.
You should line <CODE>ml = NULL</CODE> after this call since the address pointed
by <CODE>ml</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_line ml; /* Internal use: no Input neither Output of module */
Point_curve pt;

/* Define a morpho line containing the point (0,0) only */

if (!(pt=mw_new_point_curve()) ||
    !(ml=mw_new_morpho_line())) mwerror(FATAL,1,"Not enough memory.\n");
pt-&gt;x=pt-&gt;y=0;
ml-&gt;first_point=pt;

/* .
   .
   (statement)
   .
   .
*/

/* Deallocate the morpho_line */
mw_delete_morpho_line(ml);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_morpho_line</FONT></B> - Return the number of points a morpho line contains</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_morpho_line(ml)</P><P>Morpho_line ml;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of points contained in the input
<CODE>ml</CODE>.
It returns 0 if the structure is empty or undefined.
If the field <CODE>first_type</CODE> is not <TT>NULL</TT>, the number of points
defined by this field must equal the number of points in the curve.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Morpho_line ml; /* Internal use: no Input neither Output of module */
Point_curve pt;

/* Define a morpho line containing the point (0,0) only */

if (!(pt=mw_new_point_curve()) ||
    !(ml=mw_new_morpho_line())) mwerror(FATAL,1,"Not enough memory.\n");
pt-&gt;x=pt-&gt;y=0;
ml-&gt;first_point=pt;

/* This will print 1 */
printf("%d",mw_length_morpho_line(ml));
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_morpho_line</FONT></B> - Create a new morpho line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Morpho_line mw_new_morpho_line()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a new <TT>Morpho_line</TT> structure, or <TT>NULL</TT> if not enough 
memory is available to allocate the structure. 
Your code should check this return value to send an error message in the 
<TT>NULL</TT> case, and do appropriate statement.</P><P>The new structure is created with fields set to 0 or <TT>NULL</TT>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
/* Copy the curve of a morpho line into another morpho line */
Morpho_line in,out;

out=mw_new_morpho_line();
if (!out) mwerror(FATAL,1,"Not enough memory !\n");
out-&gt;open = in-&gt;open;
if ( ((out-&gt;first_point = mw_new_point_curve()) == NULL) ||
     ((out-&gt;first_type = mw_new_point_type()) == NULL) )
   mwerror(FATAL, 1,"Not enough memory !\n");
mw_copy_point_curve(in-&gt;first_point,out-&gt;first_point);
mw_copy_point_type(in-&gt;first_type,out-&gt;first_type);

</PRE><!--TOC section Morpho line in the continuous plane-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc119">7.8</A>&#XA0;&#XA0;Morpho line in the continuous plane</H2><!--SEC END --><P><A NAME="fmorpho_line"></A>
</P><P>The structure <TT>Fmorpho_line</TT> <A NAME="@default137"></A> is used to
handle morpho lines in the continuous plane.
Indeed, if the morpho lines obtained from digital images contain discrete
(integer) coordinates, one may want to process the morpho lines using
continuous operators, such as geometric smoothing. The resulting morpho
lines are no more made by discrete coordinates.
In a <TT>Fmorpho_line</TT>, the points are recorded using the <TT>Point_fcurve</TT> structure (See
Section&#XA0;<A HREF="#curves-polygons_real">6.6</A>).</P><!--TOC subsection The structure Fmorpho_line-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc120">7.8.1</A>&#XA0;&#XA0;The structure Fmorpho_line</H3><!--SEC END --><P>
<A NAME="fmline-structure"></A></P><P>This is the C definition of the structure <TT>Fmorpho_line</TT>:
<A NAME="@default138"></A> 
</P><PRE CLASS="verbatim">typedef struct fmorpho_line {
  Point_fcurve first_point;/* Pointer to the first point of the fmorpho_line curve */
  Point_type first_type;   /* Pointer to the first Point_type */
  float minvalue;          /* Minimum gray level value of this morpho line */
  float maxvalue;          /* Maximum gray level value of this morpho line */
  unsigned char open;      /* 0 if the morpho line is closed, opened otherwise */
  float data;             /* User-defined data field (saved) */
  void *pdata;            /* User-defined data field : pointer to something (not saved) */
 
  /* For use in Mimage only */
  struct fmorpho_line *previous; /* Pointer to the previous m.l. (may be NULL) */
  struct fmorpho_line *next;     /* Pointer to the next m.l. (may be NULL) */
} *Fmorpho_line;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc121">7.8.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="fmline-file_type"></A></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_FMORPHO_LINE"</CODE><A NAME="@default139"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc122">7.8.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="fmline-function"></A></P><P>We won&#X2019;t waste space to describe functions related to the <TT>Fmorpho_line</TT> structure : they
are the same than those related to <TT>Morpho_line</TT>, except that the name &#X201C;morpho_line&#X201D; has
to be changed to &#X201C;fmorpho_line&#X201D;.</P><!--TOC section Morphological image-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc123">7.9</A>&#XA0;&#XA0;Morphological image</H2><!--SEC END --><P><A NAME="mimage"></A></P><P>A morphological image<A NAME="@default140"></A> may record in a structure called <TT>Mimage</TT> all morpho sets
and morpho lines the image contains. It is therefore potentially a very redundant
(and very huge) structure, but this plenty of information may be useful to perform 
morphological operations. Of course, not all fields need to be set as the same time,
for example a <TT>Mimage</TT> may contain the level lines only. But from this (complete) 
information, all other fields may be computed.</P><P>The <TT>Mimage</TT> structure has been created before the <TT>Shapes</TT> structure was developed
(See Section&#XA0;<A HREF="#shapes">7.2</A>).
It does not use the tree structure associated to FLST-based algorithms.
For this reason, the <TT>Shapes</TT> object should be preferred to the <TT>Mimage</TT> one for
future developments.</P><!--TOC subsection The structure Mimage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc124">7.9.1</A>&#XA0;&#XA0;The structure Mimage</H3><!--SEC END --><P>
<A NAME="mimage-structure"></A></P><P>This is the C definition of the structure <TT>Mimage</TT>:
<A NAME="@default141"></A> 
</P><PRE CLASS="verbatim">typedef struct mimage {
  char cmt[mw_cmtsize];   /* Comments */
  char name[mw_namesize]; /* Name of the set */
  int nrow;               /* Number of rows (dy) */
  int ncol;               /* Number of columns (dx) */
  float minvalue;         /* Minimal Gray level value in the image */
  float maxvalue;         /* Maximal Gray level value in the image */
  Morpho_line first_ml;   /* Pointer to the first morpho line in the discrete grid */
  Fmorpho_line first_fml; /* Pointer to the first morpho line in the continuous plane */
  Morpho_sets first_ms;   /* Pointer to the first morpho sets in the discrete grid */
} *Mimage;
</PRE><!--TOC subsection Related file (external) types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc125">7.9.2</A>&#XA0;&#XA0;Related file (external) types</H3><!--SEC END --><P>
<A NAME="mimage-file_type"></A></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_MIMAGE"</CODE><A NAME="@default142"></A> MegaWave2 binary format.
</LI></OL><!--TOC subsection Functions Summary-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc126">7.9.3</A>&#XA0;&#XA0;Functions Summary</H3><!--SEC END --><P>
<A NAME="mimage-function"></A></P><P>The following is a description of all the functions related to 
the <TT>Mimage</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_mimage</FONT></B> - Define a morphological image, if not already defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Mimage mw_change_mimage(mi)</P><P>Mimage mi;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a <TT>Mimage</TT> structure if the input <CODE>mi = NULL</CODE>.
It is provided despite the<BR>
<CODE>mw_new_mimage()</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_mimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Copy the morpho lines only of a morphological image into another morphological image */

Mimage in,out=NULL;

out=mw_change_mimage(out);
if (!out) mwerror(FATAL,1,"Not enough memory !\n");
out-&gt;nrow = in-&gt;nrow;
out-&gt;ncol = in-&gt;ncol;
out-&gt;minvalue=in-&gt;minvalue;
out-&gt;maxvalue=in-&gt;maxvalue;
if (in-&gt;firstml) 
  {
    out-&gt;firstml=mw_copy_morpho_line(in-&gt;firstml, out-&gt;firstml);
    if (!out-&gt;firstml) mwerror(FATAL, 1,"Not enough memory !\n");
  }
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_mimage</FONT></B> - Copy a morphological image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Mimage mw_copy_mimage(in,out)</P><P>Mimage in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the <TT>Mimage</TT> <CODE>in</CODE> into <CODE>out</CODE>.
All fields are copied, including the chains of <TT>Morpho_sets</TT>, <TT>Morpho_line</TT> and <TT>Fmorpho_line</TT>.
The result is put in <CODE>out</CODE>, which may not be a predefined structure : in case 
of <CODE>out=NULL</CODE>, the <CODE>out</CODE> structure is allocated.</P><P>The function <CODE>mw_copy_mimage</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
mimage in; /* Predefined mimage */
mimage out=NULL; 

out=mw_copy_mimage(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_mimage</FONT></B> - Deallocate a morphological image</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_mimage(mi)</P><P>mimage mi;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the <TT>Mimage</TT> <CODE>mi</CODE> structure, including the
chains of <TT>Morpho_sets</TT>, <TT>Morpho_line</TT> and <TT>Fmorpho_line</TT>.
You should line <CODE>mi = NULL</CODE> after this call since the address pointed
by <CODE>mi</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Mimage mi; /* Internal use: no Input neither Output of module */

Morpho_line ml; 
Point_curve pt;
Fmorpho_line fml; 
Point_fcurve fpt;
Morpho_sets mss;
Hsegment seg;
Morpho_set ms;


/* Define a morpho line containing the point (0,0) only */

if (!(pt=mw_new_point_curve()) ||
    !(ml=mw_new_morpho_line())) mwerror(FATAL,1,"Not enough memory.\n");
pt-&gt;x=pt-&gt;y=0;
ml-&gt;first_point=pt;

/* Define a fmorpho line containing the point (0.5,0.5) only */

if (!(fpt=mw_new_point_fcurve()) ||
    !(fml=mw_new_fmorpho_line())) mwerror(FATAL,1,"Not enough memory.\n");
fpt-&gt;x=fpt-&gt;y=0.5;
fml-&gt;first_point=fpt;

/* Define a morpho sets containing one morpho set */

if (!(seg=mw_new_hsegment()) ||
    !(ms=mw_new_morpho_set()) ||
    !(mss=mw_new_morpho_sets())) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;
ms-&gt;first_segment=seg; ms-&gt;minvalue=0.0; ms-&gt;maxvalue = 1.0; ms-&gt;area=201;
mss-&gt;morphoset=ms;

/* Define a morphological image made by one morpho line, one fmorpho line and
   one morpho sets.
*/

if (!(mi=mw_new_morpho_line())) mwerror(FATAL,1,"Not enough memory.\n");
mi-&gt;first_ml=ml;
mi-&gt;first_fml=fml;
mi-&gt;first_ms=ms;

/* .
   .
   (statement)
   .
   .
*/


/* Deallocate the mimage, including ml, fml and ms */
mw_delete_mimage(mi);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_fml_mimage</FONT></B> - Return the number of morpho lines a morphological image contains</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_fml_mimage(mi)</P><P>Mimage mi;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of fmorpho lines contained in the input
<CODE>mi</CODE>.
It returns 0 if the structure is empty or undefined.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See example page&#XA0;<A HREF="#length_ml-example">??</A>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_ml_mimage</FONT></B> - Return the number of morpho lines a morphological image contains</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_ml_mimage(mi)</P><P>Mimage mi;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of morpho lines contained in the input
<CODE>mi</CODE>.
It returns 0 if the structure is empty or undefined.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
<A NAME="length_ml-example"></A>
</P><PRE CLASS="verbatim">

Mimage mi; /* Internal use: no Input neither Output of module */

Morpho_line ml; 
Point_curve pt;
Fmorpho_line fml; 
Point_fcurve fpt;
Morpho_sets mss;
Hsegment seg;
Morpho_set ms;


/* Define a morpho line containing the point (0,0) only */

if (!(pt=mw_new_point_curve()) ||
    !(ml=mw_new_morpho_line())) mwerror(FATAL,1,"Not enough memory.\n");
pt-&gt;x=pt-&gt;y=0;
ml-&gt;first_point=pt;

/* Define a fmorpho line containing the point (0.5,0.5) only */

if (!(fpt=mw_new_point_fcurve()) ||
    !(fml=mw_new_fmorpho_line())) mwerror(FATAL,1,"Not enough memory.\n");
fpt-&gt;x=fpt-&gt;y=0.5;
fml-&gt;first_point=fpt;

/* Define a morpho sets containing one morpho set */

if (!(seg=mw_new_hsegment()) ||
    !(ms=mw_new_morpho_set()) ||
    !(mss=mw_new_morpho_sets())) mwerror(FATAL,1,"Not enough memory.\n");
seg-&gt;xstart=0; 
seg-&gt;xend=200;
seg-&gt;y=10;
ms-&gt;first_segment=seg; ms-&gt;minvalue=0.0; ms-&gt;maxvalue = 1.0; ms-&gt;area=201;
mss-&gt;morphoset=ms;

/* Define a morphological image made by one morpho line, one fmorpho line and
   one morpho sets.
*/

if (!(mi=mw_new_morpho_line())) mwerror(FATAL,1,"Not enough memory.\n");
mi-&gt;first_ml=ml;
mi-&gt;first_fml=fml;
mi-&gt;first_ms=ms;


/* This will print 1 */
printf("%d",mw_length_ml_mimage(mi));
/* This will print 1 */
printf("%d",mw_length_fml_mimage(mi));
/* This will print 1 */
printf("%d",mw_length_ms_mimage(mi));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_ms_mimage</FONT></B> - Return the number of morpho sets a morphological image contains</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_ms_mimage(mi)</P><P>Mimage mi;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of morpho sets contained in the input
<CODE>mi</CODE>.
It returns 0 if the structure is empty or undefined.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See example page&#XA0;<A HREF="#length_ml-example">??</A>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_mimage</FONT></B> - Create a new morphological image</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Mimage mw_new_mimage()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a new <TT>Mimage</TT> structure, or <TT>NULL</TT> if not enough 
memory is available to allocate the structure. 
Your code should check this return value to send an error message in the 
<TT>NULL</TT> case, and do appropriate statement.</P><P>The new structure is created with fields set to 0 or <TT>NULL</TT>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Copy the morpho lines only of a morphological image into another morphological image */

Mimage in,out;

out=mw_new_mimage();
if (!out) mwerror(FATAL,1,"Not enough memory !\n");
out-&gt;nrow = in-&gt;nrow;
out-&gt;ncol = in-&gt;ncol;
out-&gt;minvalue=in-&gt;minvalue;
out-&gt;maxvalue=in-&gt;maxvalue;
if (in-&gt;firstml) 
  {
    out-&gt;firstml=mw_copy_morpho_line(in-&gt;firstml, out-&gt;firstml);
    if (!out-&gt;firstml) mwerror(FATAL, 1,"Not enough memory !\n");
  }
</PRE><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">we denote by <I>x</I> a point in the image <I>u</I>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Unstructured material or raw data-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc127">Chapter&#XA0;8</A>&#XA0;&#XA0;Unstructured material or raw data</H1><!--SEC END --><P>
<A NAME="rawdata"></A>
</P><P>When none of the previous structures matches your need, or when you want to
write or to read files in a format which is not recognized by MegaWave2, use
the raw data<A NAME="@default143"></A> type : this internal type allows you to load/save 
any kind of data from/to disk.</P><!--TOC section The structure Rawdata-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc128">8.1</A>&#XA0;&#XA0;The structure Rawdata</H2><!--SEC END --><P>
<A NAME="@default144"></A>
<A NAME="rawdata_structure"></A></P><P>The <TT>Rawdata</TT> structure is nothing else than an array of bytes (<CODE>data</CODE> field). The
size of the array is set in the <CODE>size</CODE> field.</P><PRE CLASS="verbatim">typedef struct rawdata {
  int size;               /* Number of samples */
  unsigned char *data;    /* data field */
} *Rawdata;
</PRE><!--TOC section Related file (external) types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc129">8.2</A>&#XA0;&#XA0;Related file (external) types</H2><!--SEC END --><P>
<A NAME="rawdata-file_type"></A></P><P>There is no file types associated to the <TT>Rawdata</TT> structure : when the content of a <TT>Rawdata</TT> 
variable is written into a file, the content of the file is exactly the content of the <CODE>data</CODE>
field. There is no header added. Consequently, file of any format can be loaded into a <TT>Rawdata</TT>
variable. If this file contains a header (as most of MegaWave2 file formats), the header will
be loaded into the <CODE>data</CODE> field together with the data themselves.
Of course, there cannot be any conversion format associated to <TT>Rawdata</TT>.</P><!--TOC section Functions Summary-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc130">8.3</A>&#XA0;&#XA0;Functions Summary</H2><!--SEC END --><P>
<A NAME="rawdata_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Rawdata</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_rawdata</FONT></B> - Allocate the data array of a <TT>Rawdata</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Rawdata mw_alloc_rawdata(rd,size)</P><P>Rawdata rd;</P><P>int size;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the <CODE>data</CODE> array of a <TT>Rawdata</TT>structure previously created using <CODE>mw_new_rawdata</CODE>. The size of the data is given by 
<CODE>size</CODE>, it corresponds to the number of bytes.</P><P>Values can be addressed after this call, if the allocation successed. There is
no default values.</P><P>Do not use this function if <CODE>rd</CODE> has already an allocated array: use
the function <CODE>mw_change_rawdata</CODE> instead.</P><P>The function <CODE>mw_alloc_rawdata</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the array. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Rawdata rd=NULL; /* Internal use: no Input neither Output of module */
int i;

/* Create a rawdata of 1000 bytes */
if  ( ((rd = mw_new_rawdata()) == NULL) ||
      (mw_alloc_rawdata(rd,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set the byte #i to the value i mod 256 */
for (i=0;i&lt;rd-&gt;size;i++) rd-&gt;data[i] = i % 256;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_rawdata</FONT></B> - Change the size of the data array of a <TT>Rawdata</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Rawdata mw_change_rawdata(rd, newsize)</P><P>Rawdata rd;</P><P>int newsize;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the <CODE>data</CODE> array of a <TT>Rawdata</TT> structure, even if no previously memory allocation was done.
The new size of the array is given by <CODE>newsize</CODE>, it corresponds to the number 
of allocated bytes.</P><P>The function <CODE>mw_change_rawdata</CODE> can also create the structure if the input <CODE>rd = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_rawdata</CODE> and
<CODE>mw_alloc_rawdata</CODE>. It is the recommended function to allocate <TT>Rawdata</TT> variables
used as input/output of modules. Since the function can set the 
address of <CODE>rd</CODE>, the variable must be set to the return value of 
the function (See example below).</P><P>The function <CODE>mw_change_rawdata</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the array. 
Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Rawdata Output; /* Output of module */

/* Set the size of the array to be 1000 bytes */
Output = mw_change_rawdata(Output, 1000);
if (Output == NULL) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_rawdata</FONT></B> - Copy the data of a <TT>Rawdata</TT>+ structure into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_rawdata(in, out)</P><P>Rawdata in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the array <CODE>data</CODE> of the <TT>Rawdata</TT>+ structure <CODE>in</CODE> into the array <CODE>data</CODE> of <CODE>out</CODE>.
The variable <CODE>out</CODE> must be an allocated <TT>Rawdata</TT> structure of same
size than <CODE>in</CODE>.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Rawdata G; /* Needed Input */
Rawdata F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_rawdata(F, G-&gt;size)) == NULL)
        mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_rawdata(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_rawdata</FONT></B> - Deallocate the data array of a <TT>Rawdata</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_rawdata(rd)</P><P>Rawdata rd;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the array <CODE>values</CODE> of a <TT>Rawdata</TT> structure previously allocated using<BR>
 <CODE>mw_alloc_rawdata</CODE> or <CODE>mw_change_rawdata</CODE>, and the structure itself. </P><P>You should set <CODE>rd = NULL</CODE> after this call since the address pointed
by <CODE>rd</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Rawdata rd=NULL; /* Internal use: no Input neither Output of module */

if  ( ((rd = mw_new_rawdata()) == NULL) ||
      (mw_alloc_rawdata(rd,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
/* .
   .
   (statement)
   .
   .
*/
mw_delete_rawdata(rd);
rd = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_rawdata</FONT></B> - Create a new <TT>Rawdata</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Rawdata mw_new_rawdata();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Rawdata</TT> structure with an empty <CODE>data</CODE> array and
<CODE>size</CODE> field set to 0.
No data can be addressed at this time.
The <CODE>data</CODE> should be allocated using the function <CODE>mw_alloc_rawdata</CODE> or <CODE>mw_change_rawdata</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_rawdata</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_rawdata</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Rawdata rd=NULL; /* Internal use: no Input neither Output of module */

if  ( ((rd = mw_new_rawdata()) == NULL) ||
      (mw_alloc_rawdata(rd,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><!--TOC chapter Miscellaneous Features-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc131">Chapter&#XA0;9</A>&#XA0;&#XA0;Miscellaneous Features</H1><!--SEC END --><P>
<A NAME="miscellaneous"></A>
</P><P>You will find in this section some utilities which may help you to write your modules. 
Contrary to the former sections, some functions described here are not about a memory 
format. </P><!--TOC section Global System Variables-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc132">9.1</A>&#XA0;&#XA0;Global System Variables</H2><!--SEC END --><P><A NAME="misc_glob-sys-var"></A></P><P>At any time in a module, you can access to the following external variables<A NAME="@default145"></A>.
Those variables are for reading only, do not change their values !
Notice that you don&#X2019;t have to define those variables in your module, the
definitions are done into the include file <CODE>mw.h</CODE>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>char *mwname</CODE><A NAME="@default146"></A> :
This variable contains the name of the current module.</LI><LI CLASS="li-itemize"><CODE>char *mwgroup</CODE><A NAME="@default147"></A> :
This variable contains the group name of the current module, as for example <CODE>"common/signal"</CODE> which means that the current module belongs to the subgroup <CODE>signal</CODE> which is part of the main group <CODE>common</CODE>.</LI><LI CLASS="li-itemize"><CODE>int mwerrcnt</CODE><A NAME="@default148"></A> :
Give the number of time the function <CODE>mwerror</CODE> has be called with the
argument <CODE>ERROR</CODE> (see section&#XA0;<A HREF="#misc_function">9.3</A> page&#XA0;<A HREF="#misc_function">??</A>).
Since <CODE>ERROR</CODE> is not a fatal event, the user has the possibility to terminate the algorithm by checking <CODE>mwerrcnt</CODE>, if too many errors have been
encountered.</LI><LI CLASS="li-itemize"><CODE>int mwrunmode</CODE><A NAME="@default149"></A> :
The value of this variable indicates in which context the module is executed.
<UL CLASS="itemize"><LI CLASS="li-itemize">
If set to 1, the module is called in the run-time mode;
</LI><LI CLASS="li-itemize">if set to 2, the module is called by the window-oriented interpreter (XMegaWave2).
</LI></UL></LI></UL><!--TOC section Conversion between memory types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc133">9.2</A>&#XA0;&#XA0;Conversion between memory types</H2><!--SEC END --><P><A NAME="conv_memory_types"></A></P><P>The System Library contains functions to convert memory types<A NAME="@default150"></A>. 
However do not expect to find a function to convert structures
which are very dissimilar, as <CODE>Curves</CODE> and <CODE>Cimage</CODE>.
If the meaning one can give of a conversion is not evident or not unique,
a conversion procedure has to be implemented as a module rather than 
as a system function.</P><P>Conversion function summaries follow the following rule :
<CODE>out = (Y) mw_x_to_y(in,old)</CODE> where <CODE>x</CODE> is the internal C type of the
input <CODE>in</CODE>, <CODE>y</CODE> the internal C type of the requested output 
<CODE>out</CODE> (letters in lowercase) and <CODE>Y</CODE> the cast to the output 
(internal C type of <CODE>out</CODE> with first letter in uppercase).
In the last argument <CODE>old</CODE> you may put the name of a variable of type <CODE>Y</CODE> :
in such a case, the memory allocation will be reused for <CODE>out</CODE> (the pointer
<CODE>old</CODE> will have the same address than <CODE>out</CODE>). This is especially useful
when converting lot of images with same size, to avoid memory blowup. 
If you do not want to use this possibility, just put <CODE>NULL</CODE> as the last argument :
memory for <CODE>out</CODE> will be allocated.</P><P>In addition to the various <CODE>mw_x_to_y()</CODE> undocumented conversion 
functions, there exists an &#X201C;all-purpose&#X201D; conversion function called 
<CODE>mw_conv_internal_type()</CODE> and documented next page.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_conv_internal_type</FONT></B> - Convert any possible internal type to another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_conv_internal_type(mwstruct,typein,typeout)</P><P>void *mwstruct; /* Any type of MegaWave2 structure */</P><P>char *typein; /* Type of the input &lt;mwstruct&gt; */</P><P>char *typeout; /* Type of the output structure */
</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function may be used instead of the <CODE>mw_x_to_y()</CODE> various functions 
to convert any possible internal type <CODE>a</CODE> to <CODE>b</CODE>, even if the 
<CODE>mw_a_to_b()</CODE> function does not exist : the system creates 
<CODE>mw_conv_internal_type()</CODE> by analyzing existing <CODE>mw_x_to_y()</CODE> 
functions, by finding the shortest path between two internal types, say
<CODE>a</CODE> and <CODE>b</CODE>, and by calling appropriate <CODE>mw_x_to_y()</CODE> functions
(for example, <CODE>mw_a_to_c()</CODE> and <CODE>mw_c_to_b()</CODE> if those functions exist).</P><P>The input <CODE>mwstruct</CODE> is a variable of internal C type given by the
string <CODE>typein</CODE> (use lower letters only). 
The output of the function is a variable of internal C type given by the 
string <CODE>typeout</CODE>, or <CODE>NULL</CODE> if the conversion is impossible.</P><P>Do not forget to cast the output to the right type.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage in;  
Cimage out1;
Fimage out2;

/* The line */
out1 = (Cimage) mw_conv_internal_type(in,"ccimage","cimage");
/* is equivalent to */
out1 = (Cimage) mw_ccimage_to_cimage(in);

if (out1==NULL) mwerror(FATAL,1,"Cannot convert Ccimage to Cimage !\n");

/* But to convert a Ccimage to a Fimage you shall use */
out2 = (Fimage) mw_conv_internal_type(in,"ccimage","fimage");
/* Since the following function does not exist at this time */
out2 = (Fimage) mw_ccimage_to_fimage(in);

if (out2==NULL) mwerror(FATAL,1,"Cannot convert Ccimage to Fimage !\n");

</PRE><!--TOC section Miscellaneous System Functions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc134">9.3</A>&#XA0;&#XA0;Miscellaneous System Functions</H2><!--SEC END --><P><A NAME="misc_function"></A></P><P>The following is a description of some miscellaneous system functions 
which may be of interest for the user.
The list is in alphabetical order.</P><P>The most usefull are <CODE>mwerror</CODE> and <CODE>mwdebug</CODE>. 
Please notice that you need to process any error (especially memory allocation failure) by displaying an error message using <CODE>mwerror</CODE>, and by doing
appropriate statement.</P><P>Some other functions are about dynamic memory allocation<A NAME="@default151"></A>. 
They are important, since you are discouraged to use static memory allocation (as <CODE>double data[10000]</CODE>), but you may skip their description if you are
familiar with the standard C dynamic memory functions.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mwcalloc</FONT></B> - Dynamic memory allocation</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mwcalloc (nelem, elsize)</P><P>unsigned nelem, elsize;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates space for an array of <CODE>nelem</CODE> elements,
each of size <CODE>elsize</CODE> bytes, and initializes the space to zeros.</P><P>This function returns a pointer to space suitably aligned (after possible pointer coercion) for storage of any type of object. 
Do not forget to cast the return value to the right type of your variable
(see example below).
If not enough memory is available to allocate the array, the function returns <TT>NULL</TT>.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Each space allocated by <CODE>mwcalloc</CODE> must be deallocated using <CODE>mwcfree</CODE> before exiting the module.</P><P>Notice that in the MegaWave2 modules, the standard C function <CODE>calloc</CODE> is
redefined to be <CODE>mwcalloc</CODE>. 
Therefore, if you use <CODE>calloc</CODE> in your code you actually call <CODE>mwcalloc</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">float *data=NULL; /* Internal use: no Input neither Output of module */

/* Allocates space for 1000 samples of float values */
if  ( (data = (float *) mwcalloc (1000, sizeof(float))) == NULL )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set the sample #i to the value i */
for (i=0;i&lt;1000;i++) data[i] = i;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mwcfree</FONT></B> - Dynamic memory deallocation</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mwcfree (ptr)</P><P>char *ptr;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the space pointed to by 
<CODE>ptr</CODE> and which has previously been allocated by <CODE>mwcalloc</CODE>. It does 
nothing if <CODE>ptr</CODE> = <TT>NULL</TT>.</P><P>You should set <CODE>ptr</CODE> to <TT>NULL</TT>after this call since the address pointed to by <CODE>ptr</CODE> is no longer valid.</P><P>Notice that in the MegaWave2 modules, the standard C function <CODE>cfree</CODE> is
redefined to be <CODE>mwcfree</CODE>. 
Therefore, if you use <CODE>cfree</CODE> in your code you actually call <CODE>mwcfree</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">float *data=NULL; /* Internal use: no Input neither Output of module */

/* Allocates space for 1000 samples of float values */
if  ( (data = (float *) mwcalloc (1000, sizeof(float))) == NULL )
    mwerror(FATAL,1,"Not enough memory.\n");
.
. (statement)
.
/* End of statement: deallocation of the array */
mwcfree((char *) data);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mwdebug</FONT></B> - print if debug</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mwdebug(format, &#X2026;);</P><P>char *format;</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function prints its arguments in &#X2026;under control of the format in <CODE>format</CODE>, exactly in the same manner that the standard C function <CODE>printf</CODE> does. 
The string <CODE>&lt;dbg&gt;</CODE> is added to the beginning of the line.</P><P>The print is active only when the module has been called with the debugging option on.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; 
int x,y;

for (x=0;x&lt;image-&gt;ncol;x++) for (y=0;y&lt;image-&gt;nrow;y++)
{
  mwdebug("processing pixel (%d,%d)...\n",x,y);
  .
  . (statement)
  .
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mwerror</FONT></B> - print an error message</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mwerror(type, exit_code, format, &#X2026;);</P><P>int type;</P><P>int exit_code;</P><P>char *format;</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function prints its arguments in &#X2026;under control of the format in <CODE>format</CODE> on the standard error output, in the same manner that the standard C function <CODE>fprintf(stdout,format,...)</CODE> does. </P><P>A message is added to the print, and an action may be performed, according to the value in <CODE>type</CODE> :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>WARNING</CODE> :
the additional message is <CODE>MegaWave warning (</CODE><EM>mwname</EM><CODE>) : </CODE> (following is the requested print);</LI><LI CLASS="li-itemize"><CODE>ERROR</CODE> :
the additional message is <CODE>MegaWave error (</CODE><EM>mwname</EM><CODE>) : </CODE> (following is the requested print), and
the variable <CODE>mwerrcnt</CODE> is incremented.</LI><LI CLASS="li-itemize"><CODE>FATAL</CODE> :
the additional message is <CODE>MegaWave fatal (</CODE><EM>mwname</EM><CODE>) : </CODE> (following is the requested print), and a call to <CODE>mwexit(exit_code)</CODE> is performed.</LI><LI CLASS="li-itemize"><CODE>INTERNAL</CODE> :
the additional message is <CODE>MegaWave internal (</CODE><EM>mwname</EM><CODE>) : </CODE> (following is the requested print), and a call to <CODE>mwexit(exit_code)</CODE> is performed.
Use it when such error normally never may occur. 
Then, such event points out a fault of the algorithm and the code should be fixed.
One uses to add in the beginning of the print the text <CODE>[X]</CODE> where <CODE>X</CODE> is the name of the function where the error has been found, in order to make easier the debugging process (see example below).</LI><LI CLASS="li-itemize"><CODE>USAGE</CODE> : 
after the requested print, is printing the usage of the module.
Use it when the input values you get in your module function does not correspond to what the usage requests.
</LI></UL><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Compute some norm of any fimage */
static float fnorm(image) 
Fimage image; 

{ float norm;  /* result of the computation */
  .
  .  (statement)
  .
  if (norm &lt; 0.0)
   mwerror(INTERNAL,1,"[fnorm] Negative norm value computed ! (norm=%f)",norm);
  else return(norm);
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mwexit</FONT></B> - Module termination</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mwexit (status)</P><P>int status;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function causes normal program termination of a MegaWave2 module.
The variable <CODE>status</CODE> indicates the status of the module when the
termination occurred; value 0 means successful termination, other values are user-dependent.</P><P>Notice that in the MegaWave2 modules, the standard C function <CODE>exit</CODE> is
redefined to be <CODE>mwexit</CODE>. 
Therefore, if you use <CODE>exit</CODE> in your code you actually call <CODE>mwexit</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Output of module */

/* Try several times an allocation of a fimage of size 256x256 */
while (mw_alloc_fimage(image,256,256) == NULL)
  {
     mwerror(ERROR,1,"Not enough memory !\n");
     if (mwerrcnt &gt; 10) mwexit(-1);
     sleep(2);  /* Wait 2 seconds */
  }
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mwfree</FONT></B> - Dynamic memory deallocation</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mwfree (ptr)</P><P>char *ptr;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the space pointed to by 
<CODE>ptr</CODE> and which has previously been allocated by <CODE>mwmalloc</CODE>. It does 
nothing if <CODE>ptr</CODE> = <TT>NULL</TT>.</P><P>You should set <CODE>ptr</CODE> to <TT>NULL</TT>after this call since the address pointed to by <CODE>ptr</CODE> is no longer valid.</P><P>Notice that in the MegaWave2 modules, the standard C function <CODE>free</CODE> is
redefined to be <CODE>mwfree</CODE>. 
Therefore, if you use <CODE>free</CODE> in your code you actually call <CODE>mwfree</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">float *data=NULL; /* Internal use: no Input neither Output of module */

/* Allocates space for 1000 samples of float values */
if  ( (data = (float *) mwmalloc (1000*sizeof(float))) == NULL )
    mwerror(FATAL,1,"Not enough memory.\n");
.
. (statement)
.
/* End of statement: deallocation of the array */
mwfree((char *) data);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mwmalloc</FONT></B> - Dynamic memory allocation</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mwmalloc (size)</P><P>size_t size;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates space for a block of at least size bytes, but does not initialize the space.</P><P>This function returns a pointer to space suitably aligned (after possible pointer coercion) for storage of any type of object. 
Do not forget to cast the return value to the right type of your variable
(see example below).
If not enough memory is available to allocate the array, the function returns <TT>NULL</TT>. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Each space allocated by <CODE>mwmalloc</CODE> must be deallocated using <CODE>mwfree</CODE> before exiting the module.</P><P>Notice that in the MegaWave2 modules, the standard C function <CODE>malloc</CODE> is
redefined to be <CODE>mwmalloc</CODE>. 
Therefore, if you use <CODE>malloc</CODE> in your code you actually call <CODE>mwmalloc</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">long *data=NULL; /* Internal use: no Input neither Output of module */

/* Allocates space for 5000 samples of long values */
if  ( (data = (long *) mwmalloc (5000*sizeof(long))) == NULL )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set the sample #i to the value i */
for (i=0;i&lt;5000;i++) data[i] = i;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mwrealloc</FONT></B> - Dynamic memory re-allocation</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mwrealloc(ptr, size)</P><P>char *ptr;
unsigned size;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the size of the block pointed to by <CODE>ptr</CODE> to
<CODE>size</CODE> bytes and returns a pointer to the (possibly moved) block. 
Existing contents are unchanged up to the lesser of the new and old sizes. 
If <CODE>ptr</CODE> is a <TT>NULL</TT>pointer, <CODE>mwrealloc</CODE> behaves like 
<CODE>mwmalloc</CODE> for the specified size. 
If <CODE>size</CODE> is zero and <CODE>ptr</CODE> is not a <TT>NULL</TT>pointer, the object it points to is freed and <TT>NULL</TT>is returned.</P><P>If not enough memory is available to allocate the array, the function returns <TT>NULL</TT>. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Do not forget to cast the return value to the right type of your variable, and to cast the type of the input pointer <CODE>ptr</CODE> to be <CODE>char *</CODE> (see example below).</P><P>Each space allocated by <CODE>mwrealloc</CODE> must be deallocated using <CODE>mwfree</CODE> before exiting the module.</P><P>Notice that in the MegaWave2 modules, the standard C function <CODE>realloc</CODE> is
redefined to be <CODE>mwrealloc</CODE>. 
Therefore, if you use <CODE>realloc</CODE> in your code you actually call <CODE>mwrealloc</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">long *ldata=NULL;   /* Internal use: no Input neither Output of module */
double *ddata=NULL;

/* Allocates space for 5000 samples of long values */
if  ( (ldata = (long *) mwmalloc (5000*sizeof(long))) == NULL )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
/* Re-allocates space for 2000 samples of double values, using space allocated
   for ldata 
*/
if  ( (ddata = (double *) mwrealloc ((char *) ldata, 2000*sizeof(double))) == NULL )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Warning : do not use anymore the array ldata ! */
</PRE><!--TOC chapter Wdevice Library and window facilities-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc135">Chapter&#XA0;10</A>&#XA0;&#XA0;Wdevice Library and window facilities</H1><!--SEC END --><P>
<A NAME="wdevice"></A>
</P><P>The Wdevice library<A NAME="@default152"></A> provides an interface to the window manager<A NAME="@default153"></A>: 
it helps the user to write modules which have to access to the window manager resources, as the screen, the mouse, etc.
It not only replaces some painful operations which require a lot of code (such opening a window, mapping the content of an image into a window, etc.) to a simple call to one function, but it provides also an interface which is independant to the type of the window system: the calls to the Wdevice functions remain the same even if the window system changes (and the result should be the same).</P><P>This library is independant to the MegaWave2 System Library although some modules cannot be linked
without it : it is added when needed during the link process of a MegaWave2 command.
Of course, one Wdevice library per window system is needed. 
At this time, there exists a Wdevice library for the X Window System<A NAME="@default154"></A> Version 11
(X11) only.
In the past, one could find a Wdevice library for the Suntools<A NAME="@default155"></A> System but, because of the 
renunciation of Suntools from Sun MicroSystem, this library is no longer maintained 
(and no longer distributed).</P><P>On can found in the system library some packages that use functions defined by Wdevice to perform
more high-levels tasks, such as Wpanel :
The Wpanel<A NAME="@default156"></A> (Panel<A NAME="@default157"></A> display facilities) is a small package that allows to 
handle buttons and bars. It is not documented yet, and will probably change quite much in the future. For the time 
being, it is used only in the module <CODE>llview.c</CODE>.</P><!--TOC section Functions Summary-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc136">10.1</A>&#XA0;&#XA0;Functions Summary</H2><!--SEC END --><P>
<A NAME="wdevice_function"></A></P><P>The following is a description of the Wdevice library functions 
which may be called by the user. 
The list is in alphabetical order.</P><P>You may notice that each function name begins with the letter <CODE>W</CODE>.</P><P>Warning: the functions summary is not documented yet. 
If you need to access to the screen into a MegaWave2 module (e.g. to draw some figure, etc.) please read the code of the following public MegaWave2 modules, and take inspiration from those:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>view_demo.c</CODE>;
</LI><LI CLASS="li-itemize"><CODE>cview.c</CODE>;
</LI><LI CLASS="li-itemize"><CODE>ccview.c</CODE>;
</LI><LI CLASS="li-itemize"><CODE>cmview.c</CODE>;
</LI><LI CLASS="li-itemize"><CODE>splot.c</CODE>;
</LI><LI CLASS="li-itemize"><CODE>readpoly.c</CODE>.
</LI></UL><P>
Nevertheless, and because those MegaWave2 modules already exist, you are not likely to really need to learn about the Wdevice library.
</P><!--TOC chapter Index-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Index</H1><!--SEC END --><P></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">
array of points, see <I>list</I>
</LI><LI CLASS="li-indexenv">audio, <A HREF="#@default53">4.1.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">biorthogonal wavelet transform, <A HREF="#@default58">5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">C type , see <I>structure</I>
</LI><LI CLASS="li-indexenv">color model, <A HREF="#@default36">2.4.1</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
HSI, <A HREF="#@default39">2.4.1</A>
</LI><LI CLASS="li-indexenv">HSV, <A HREF="#@default40">2.4.1</A>
</LI><LI CLASS="li-indexenv">RGB, <A HREF="#@default37">2.4.1</A>
</LI><LI CLASS="li-indexenv">YUV, <A HREF="#@default38">2.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">continuous wavelet transform, <A HREF="#@default56">5</A>
</LI><LI CLASS="li-indexenv">contrast change, <A HREF="#@default106">7</A>
</LI><LI CLASS="li-indexenv">convert memory types, <A HREF="#@default150">9.2</A>
</LI><LI CLASS="li-indexenv">curve, <A HREF="#@default74">6</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">dyadic wavelet transform, <A HREF="#@default59">5</A>
</LI><LI CLASS="li-indexenv">dynamic memory allocation, <A HREF="#@default151">9.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">external type, see <I>file format</I>
</LI><LI CLASS="li-indexenv">external variable, <A HREF="#@default145">9.1</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
mwerrcnt, <A HREF="#@default148">9.1</A>
</LI><LI CLASS="li-indexenv">mwgroup, <A HREF="#@default147">9.1</A>
</LI><LI CLASS="li-indexenv">mwname, <A HREF="#@default146">9.1</A>
</LI><LI CLASS="li-indexenv">mwrunmode, <A HREF="#@default149">9.1</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Fast Level Set Transform, <A HREF="#@default109">7</A>
</LI><LI CLASS="li-indexenv">FLST, see <I>Fast Level Set Transform</I>
</LI><LI CLASS="li-indexenv">file format, <A HREF="#@default8">1.3.1</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
A_FSIGNAL, <A HREF="#@default49">4.1.2</A>
</LI><LI CLASS="li-indexenv">A_POLY, <A HREF="#@default84">6.4.2</A>, <A HREF="#@default86">6.5.2</A>
</LI><LI CLASS="li-indexenv">A_WPACK2D, <A HREF="#@default73">5.3.2</A>
</LI><LI CLASS="li-indexenv">A_WTRANS1D, <A HREF="#@default65">5.1.2</A>
</LI><LI CLASS="li-indexenv">A_WTRANS2D, <A HREF="#@default68">5.2.2</A>
</LI><LI CLASS="li-indexenv">BIN, <A HREF="#@default24">2.1.2</A>
</LI><LI CLASS="li-indexenv">BMP, <A HREF="#@default18">2.1.2</A>
</LI><LI CLASS="li-indexenv">BMPC, <A HREF="#@default28">2.2.2</A>
</LI><LI CLASS="li-indexenv">EPSF, <A HREF="#@default21">2.1.2</A>
</LI><LI CLASS="li-indexenv">GIF, <A HREF="#@default17">2.1.2</A>
</LI><LI CLASS="li-indexenv">IMG, <A HREF="#@default12">2.1.2</A>
</LI><LI CLASS="li-indexenv">INR, <A HREF="#@default22">2.1.2</A>
</LI><LI CLASS="li-indexenv">JFIF, <A HREF="#@default19">2.1.2</A>
</LI><LI CLASS="li-indexenv">JFIFC, <A HREF="#@default30">2.2.2</A>
</LI><LI CLASS="li-indexenv">MTI, <A HREF="#@default23">2.1.2</A>
</LI><LI CLASS="li-indexenv">MW2_CURVE, <A HREF="#@default80">6.2.2</A>
</LI><LI CLASS="li-indexenv">MW2_CURVES, <A HREF="#@default82">6.3.2</A>
</LI><LI CLASS="li-indexenv">MW2_DLIST, <A HREF="#@default103">6.7.8</A>
</LI><LI CLASS="li-indexenv">MW2_DLISTS, <A HREF="#@default104">6.7.8</A>
</LI><LI CLASS="li-indexenv">MW2_FLIST, <A HREF="#@default98">6.7.2</A>
</LI><LI CLASS="li-indexenv">MW2_FLISTS, <A HREF="#@default100">6.7.5</A>
</LI><LI CLASS="li-indexenv">MW2_FMORPHO_LINE, <A HREF="#@default139">7.8.2</A>
</LI><LI CLASS="li-indexenv">MW2_MIMAGE, <A HREF="#@default142">7.9.2</A>
</LI><LI CLASS="li-indexenv">MW2_MORPHO_LINE, <A HREF="#@default136">7.7.2</A>
</LI><LI CLASS="li-indexenv">MW2_MORPHO_SET, <A HREF="#@default127">7.5.2</A>
</LI><LI CLASS="li-indexenv">MW2_MORPHO_SETS, <A HREF="#@default130">7.6.2</A>
</LI><LI CLASS="li-indexenv">MW2_SHAPE, <A HREF="#@default114">7.1.2</A>, <A HREF="#@default116">7.2.2</A>
</LI><LI CLASS="li-indexenv">PGMA, <A HREF="#@default14">2.1.2</A>
</LI><LI CLASS="li-indexenv">PGMR, <A HREF="#@default15">2.1.2</A>
</LI><LI CLASS="li-indexenv">PM_C, <A HREF="#@default16">2.1.2</A>
</LI><LI CLASS="li-indexenv">PM_F, <A HREF="#@default34">2.3.2</A>
</LI><LI CLASS="li-indexenv">PMC_C, <A HREF="#@default27">2.2.2</A>
</LI><LI CLASS="li-indexenv">PMC_F, <A HREF="#@default41">2.4.2</A>
</LI><LI CLASS="li-indexenv">PPM, <A HREF="#@default29">2.2.2</A>
</LI><LI CLASS="li-indexenv">PS, <A HREF="#@default20">2.1.2</A>
</LI><LI CLASS="li-indexenv">RIM, <A HREF="#@default33">2.3.2</A>
</LI><LI CLASS="li-indexenv">TIFF, <A HREF="#@default13">2.1.2</A>
</LI><LI CLASS="li-indexenv">TIFFC, <A HREF="#@default26">2.2.2</A>
</LI><LI CLASS="li-indexenv">WAVE_PCM, <A HREF="#@default50">4.1.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">file type, see <I>file format</I>
</LI><LI CLASS="li-indexenv">frame, <A HREF="#@default60">5</A>
</LI><LI CLASS="li-indexenv">function, <A HREF="#@default1">1.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">image, <A HREF="#@default10">2</A>
</LI><LI CLASS="li-indexenv">internal type , see <I>structure</I>
</LI><LI CLASS="li-indexenv">iso line, <A HREF="#@default133">7.7</A>
</LI><LI CLASS="li-indexenv">iso set, <A HREF="#@default124">7.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">JPEG, see <I>file format:JFIF,JFIFC</I>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">level line, <A HREF="#@default132">7.7</A>
</LI><LI CLASS="li-indexenv">level set, <A HREF="#@default107">7</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
lower, <A HREF="#@default112">7.1</A>, <A HREF="#@default122">7.5</A>
</LI><LI CLASS="li-indexenv">upper, <A HREF="#@default113">7.1</A>, <A HREF="#@default123">7.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">list, <A HREF="#@default96">6.7</A>
</LI></UL></TD><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">memory type , see <I>structure</I>
</LI><LI CLASS="li-indexenv">morpho line, <A HREF="#@default131">7.7</A>
</LI><LI CLASS="li-indexenv">morpho set, <A HREF="#@default121">7.5</A>
</LI><LI CLASS="li-indexenv">morphological image, <A HREF="#@default140">7.9</A>
</LI><LI CLASS="li-indexenv">morphological representation, <A HREF="#@default105">7</A>
</LI><LI CLASS="li-indexenv">movie, <A HREF="#@default42">3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">object, <A HREF="#@default0">1.1</A>
</LI><LI CLASS="li-indexenv">one-dimensional wavelet, <A HREF="#@default63">5.1</A>
</LI><LI CLASS="li-indexenv">orthogonal wavelet transform, <A HREF="#@default57">5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">panel, see <I>Wpanel</I>
</LI><LI CLASS="li-indexenv">point, <A HREF="#@default78">6.1</A>
</LI><LI CLASS="li-indexenv">polygon, <A HREF="#@default76">6</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">quad-tree, <A HREF="#@default70">5.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">raw data, <A HREF="#@default143">8</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Suntools, <A HREF="#@default155">10</A>
</LI><LI CLASS="li-indexenv">search path, <A HREF="#@default9">1.3.2</A>
</LI><LI CLASS="li-indexenv">segment<UL CLASS="indexenv"><LI CLASS="li-indexenv">
horizontal, <A HREF="#@default119">7.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">set of points, see <I>curve</I>, see <I>segment</I>
</LI><LI CLASS="li-indexenv">shape, <A HREF="#@default108">7</A>
</LI><LI CLASS="li-indexenv">signal, <A HREF="#@default47">4</A>
</LI><LI CLASS="li-indexenv">sound processing, <A HREF="#@default51">4.1.2</A>
</LI><LI CLASS="li-indexenv">speech processing, <A HREF="#@default52">4.1.2</A>
</LI><LI CLASS="li-indexenv">structure, <A HREF="#@default5">1.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<TT>Ccimage </TT>, <A HREF="#@default25">2.2.1</A>
</LI><LI CLASS="li-indexenv"><TT>Ccmovie </TT>, <A HREF="#@default44">3.2</A>
</LI><LI CLASS="li-indexenv"><TT>Cfimage </TT>, <A HREF="#@default35">2.4.1</A>
</LI><LI CLASS="li-indexenv"><TT>Cfmovie </TT>, <A HREF="#@default46">3.4</A>
</LI><LI CLASS="li-indexenv"><TT>Cimage </TT>, <A HREF="#@default11">2.1.1</A>
</LI><LI CLASS="li-indexenv"><TT>Cmovie </TT>, <A HREF="#@default43">3.1</A>
</LI><LI CLASS="li-indexenv"><TT>Curve</TT>, <A HREF="#@default79">6.2</A>
</LI><LI CLASS="li-indexenv"><TT>Curves</TT>, <A HREF="#@default81">6.3</A>
</LI><LI CLASS="li-indexenv"><TT>Dcurve</TT>, <A HREF="#@default93">6.6</A>
</LI><LI CLASS="li-indexenv"><TT>Dcurves</TT>, <A HREF="#@default94">6.6</A>
</LI><LI CLASS="li-indexenv"><TT>Dlist</TT>, <A HREF="#@default101">6.7.7</A>
</LI><LI CLASS="li-indexenv"><TT>Dlists</TT>, <A HREF="#@default102">6.7.7</A>
</LI><LI CLASS="li-indexenv"><TT>Fcurve</TT>, <A HREF="#@default88">6.6</A>
</LI><LI CLASS="li-indexenv"><TT>Fcurves</TT>, <A HREF="#@default89">6.6</A>
</LI><LI CLASS="li-indexenv"><TT>Fimage </TT>, <A HREF="#@default32">2.3</A>
</LI><LI CLASS="li-indexenv"><TT>Flist</TT>, <A HREF="#@default97">6.7.1</A>
</LI><LI CLASS="li-indexenv"><TT>Flists</TT>, <A HREF="#@default99">6.7.4</A>
</LI><LI CLASS="li-indexenv"><TT>Fmorpho_line</TT>, <A HREF="#@default137">7.8</A>, <A HREF="#@default138">7.8.1</A>
</LI><LI CLASS="li-indexenv"><TT>Fmovie </TT>, <A HREF="#@default45">3.3</A>
</LI><LI CLASS="li-indexenv"><TT>Fpolygon</TT>, <A HREF="#@default90">6.6</A>
</LI><LI CLASS="li-indexenv"><TT>Fpolygons</TT>, <A HREF="#@default91">6.6</A>
</LI><LI CLASS="li-indexenv"><TT>Fsignal</TT>, <A HREF="#@default48">4.1</A>
</LI><LI CLASS="li-indexenv"><TT>Hsegment</TT>, <A HREF="#@default120">7.4.1</A>
</LI><LI CLASS="li-indexenv"><TT>Mimage</TT>, <A HREF="#@default141">7.9.1</A>
</LI><LI CLASS="li-indexenv"><TT>Morpho_line</TT>, <A HREF="#@default134">7.7</A>, <A HREF="#@default135">7.7.1</A>
</LI><LI CLASS="li-indexenv"><TT>Morpho_set</TT>, <A HREF="#@default125">7.5</A>, <A HREF="#@default126">7.5.1</A>
</LI><LI CLASS="li-indexenv"><TT>Morpho_sets</TT>, <A HREF="#@default128">7.6</A>, <A HREF="#@default129">7.6.1</A>
</LI><LI CLASS="li-indexenv"><TT>Point_curve</TT>, <A HREF="#@default77">6.1</A>
</LI><LI CLASS="li-indexenv"><TT>Point_dcurve</TT>, <A HREF="#@default92">6.6</A>
</LI><LI CLASS="li-indexenv"><TT>Point_fcurve</TT>, <A HREF="#@default87">6.6</A>
</LI><LI CLASS="li-indexenv"><TT>Point_type</TT>, <A HREF="#@default117">7.3</A>
</LI><LI CLASS="li-indexenv"><TT>Polygon</TT>, <A HREF="#@default83">6.4</A>
</LI><LI CLASS="li-indexenv"><TT>Polygons</TT>, <A HREF="#@default85">6.5</A>
</LI><LI CLASS="li-indexenv"><TT>Rawdata</TT>, <A HREF="#@default144">8.1</A>
</LI><LI CLASS="li-indexenv"><TT>Shape</TT>, <A HREF="#@default111">7.1</A>
</LI><LI CLASS="li-indexenv"><TT>Shapes</TT>, <A HREF="#@default115">7.2</A>
</LI><LI CLASS="li-indexenv"><TT>Wpack2d </TT>, <A HREF="#@default72">5.3.1</A>
</LI><LI CLASS="li-indexenv"><TT>Wtrans1d </TT>, <A HREF="#@default64">5.1.1</A>
</LI><LI CLASS="li-indexenv"><TT>Wtrans2d </TT>, <A HREF="#@default67">5.2.1</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">tree, see <I>quad-tree</I>
</LI><LI CLASS="li-indexenv">two-dimensional wavelet, <A HREF="#@default66">5.2</A>
</LI><LI CLASS="li-indexenv">two-dimensional wavelet packages, <A HREF="#@default69">5.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Wdevice library, <A HREF="#@default152">10</A>
</LI><LI CLASS="li-indexenv">Wpanel, <A HREF="#@default156">10</A>
</LI><LI CLASS="li-indexenv">wavelet, <A HREF="#@default54">5</A>
</LI><LI CLASS="li-indexenv">wavelet maxima representation, <A HREF="#@default61">5</A>
</LI><LI CLASS="li-indexenv">wavelet packet, <A HREF="#@default62">5</A>
</LI><LI CLASS="li-indexenv">wavelet transform, <A HREF="#@default55">5</A>
</LI><LI CLASS="li-indexenv">window manager, <A HREF="#@default153">10</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">X Window System, <A HREF="#@default154">10</A>
</LI></UL></TD></TR>
</TABLE><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->

</BODY>
</HTML>
