\Name{mw\_alloc\_fimage}{Allocate the gray plane}
\Summary{
Fimage mw\_alloc\_fimage(image,nrow,ncol)

Fimage image;

int nrow, ncol;
}
\Description
This function allocates the gray plane of a \fimage structure previously
created using \verb+mw_new_fimage+. The size of the image is given by 
\verb+nrow+ (number of rows or maximum range of $y$ plus one) and \verb+ncol+
(number of columns or maximum range of $x$ plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.

Do not use this function if \verb+image+ has already an allocated plane: use
the function \verb+mw_change_fimage+ instead.

The function \verb+mw_alloc_fimage+ returns \Null\ if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the \Null\ case, and do appropriate statement.

\Next
\Example
\begin{verbatim}
Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to the value -1.0 */
image->gray[256] = -1.0;

\end{verbatim}

\newpage %......................................

\Name{mw\_change\_fimage}{Change the size of the gray plane}
\Summary{
Fimage mw\_change\_fimage(image, nrow, ncol)

Fimage image;

int nrow, ncol;
}
\Description
This function changes the memory allocation of the gray plane of a \fimage
structure, even if no previously memory allocation was done.
The new size of the image is given by \verb+nrow+ (number of rows or maximum 
range of $y$ plus one) and \verb+ncol+ (number of columns or maximum range of 
$x$ plus one). 

It can also create the structure if the input \verb+image = NULL+.
Therefore, this function can replace both \verb+mw_new_fimage+ and
\verb+mw_alloc_fimage+. It is the recommended function to set image 
dimension of input/output modules. Since the function can set the 
address of \verb+image+, the variable must be set to the return value of 
the function (See example below).

The function \verb+mw_change_fimage+ returns \Null\ if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the \Null\ case, and do appropriate statement.

\Next
\Example
\begin{verbatim}
Fimage u; 

/* Usage when <u> IS NOT an output of the module (and has not been
   previously allocated): the function returns a new structure's address
*/
u = mw_change_fimage(NULL, 256, 256);

/* Usage when <u> IS an output of the module (or has been previously
   allocated): DO NOT change the structure's address
*/
u = mw_change_fimage(u, 256, 256);

if (u == NULL) mwerror(FATAL,1,"Not enough memory.\n");
\end{verbatim}


\newpage %......................................

\Name{mw\_clear\_fimage}{Clear the gray plane}
\Summary{
void mw\_clear\_fimage(image, v)

Fimage image;

float v;
}
\Description
This function fills the fimage \verb+image+ with the gray value given by $v$:
all pixels will have the gray level $v$. 

\Next
\Example
\begin{verbatim}
Fimage image; /* Output of module */

image = mw_change_fimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to 0.0 */
mw_clear_fimage(image,0.0);

\end{verbatim}

\newpage %......................................

\Name{mw\_copy\_fimage}{Copy the pixel values of an image into another one}
\Summary{
void mw\_copy\_fimage(in, out)

Fimage in,out;
}
\Description
This function copies the content of the gray plane of the image \verb+in+ into 
the gray plane of the image \verb+out+.
The size of the two gray planes must be the same.

The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).

\Next
\Example
\begin{verbatim}

Fimage G; /* Needed Input */
Fimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_fimage(F, G->nrow, G->ncol)) == NULL)
	mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_fimage(G, F);
   }
  else  printf("F option is not active\n");
\end{verbatim}

\newpage %......................................

\Name{mw\_delete\_fimage}{Deallocate the gray plane}
\Summary{
void mw\_delete\_fimage(image)

Fimage image;
}
\Description
This function deallocates the gray plane of a \fimage structure previously
allocated using \verb+mw_alloc_fimage+ or \verb+mw_change_fimage+, and the
structure itself. 

You should set \verb+image = NULL+ after this call since the address pointed
by \verb+image+ is no longer valid.

\Next
\Example
\begin{verbatim}
Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_fimage(image);
image = NULL;

\end{verbatim}

\newpage %......................................


\Name{mw\_draw\_fimage}{Draw a line}
\Summary{
void mw\_draw\_fimage(image, a0, b0, a1, b1, c)

Fimage image;

int a0,b0,a1,b1;
float c;
}
\Description
This function draws in \verb+image+ a connected line of gray level $c$ between the pixel $(a0,b0)$ and the pixel $(a1,b1)$.

\Next
\Example
\begin{verbatim}
Fimage image; /* Output of module */

image = mw_change_fimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Clear all pixels */
mw_clear_fimage(image,0.0);
/* Draw a diagonal line of gray level 1.0 */
mw_draw_fimage(image,0,0,99,99,1.0);
\end{verbatim}

\newpage %......................................

\Name{mw\_getdot\_fimage}{Return the gray level value}
\Summary{
float mw\_getdot\_fimage(image, x, y)

Fimage image;

int x,y;
}
\Description
This function returns the gray level value (any floating point number) of the given \verb+image+ for the pixel $(x,y)$ (column $\# x$ and row $\# y$).

Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value. See section~\ref{images} page~\pageref{images} for how to read pixels fast.

\Next
\Example
\begin{verbatim}
Fimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

if ((x < image->ncol) && (y < image->nrow))
	printf("image(%d,%d) = %f\n",x,y,mw_getdot_fimage(image,x,y));
else mwerror(ERROR,1,"Out of bounds !\n");

\end{verbatim}

\newpage %......................................

\Name{mw\_newtab\_gray\_fimage}{Create a bi-dimensional tab for the pixels of a Fimage}
\Summary{
float ** mw\_newtab\_gray\_fimage(image)

Fimage image;
}
\Description
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels' gray level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the gray plane of the given image.

This function must be called after the gray plane has been allocated,
using for example one of the functions \verb+mw_new_fimage+, 
\verb+mw_alloc_fimage+ or \verb+mw_change_fimage+. 
After that, if the gray plane allocation is changed
(by e.g. \verb+mw_change_fimage+ or \verb+mw_delete_fimage+), the tab is
no longer valid and must be deleted using \verb+free(tab)+.

Ones the tab has been correctly created, is it possible to read or to
write the value of the pixel $(x,y)$ ($x$ being an index for column and $y$
for row) using\verb+tab[y][x]+.

\Next
\Example
\begin{verbatim}
Fimage image; /* Needed Input of module (gray plane already allocated and filled) */
int x,y;      /* Needed Input of module */
float **tab;

tab =  mw_newtab_gray_fimage(image);
if (tab==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put 0 in the pixel (x,y) */
if ((x < image->ncol) && (y < image->nrow)) tab[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(tab);

\end{verbatim}

\newpage %......................................\Name{mw\_new\_fimage}{Create a new Fimage}
\Summary{
Fimage mw\_new\_fimage();
}
\Description
This function creates a new \fimage structure with an empty gray plane.
No pixels can be addressed at this time.
The gray plane may be allocated using the function \verb+mw_alloc_fimage+ or
\verb+mw_change_fimage+.

Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see \volI). Use instead the function \verb+mw_change_fimage+.
Do not forget to deallocate the internal structures before the end
of the module.

The function \verb+mw_new_fimage+ returns \Null\ if not enough memory is available to create the structure. Your code should check this value to send an
error message in the \Null\ case, and do appropriate statement.

\Next
\Example
\begin{verbatim}
Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
\end{verbatim}

\newpage %......................................

\Name{mw\_plot\_fimage}{Set the gray level value}
\Summary{
void mw\_plot\_fimage(image, x, y, v)

Fimage image;

int x,y;

float v;
}
\Description
This function set the gray level value of the given \verb+image+ for the pixel $(x,y)$ (column $\# x$ and row $\# y$) to be \verb+v+  (any floating point number).

Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section~\ref{images} page~\pageref{images} for how to write pixels fast.

\Next
\Example
\begin{verbatim}
Fimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put 0.0 in the pixel (x,y) */
if ((x < image->ncol) && (y < image->nrow))
        mw_plot_fimage(image,x,y,0.0);
else mwerror(ERROR,1,"Out of bounds !\n");

\end{verbatim}
\newpage %......................................

