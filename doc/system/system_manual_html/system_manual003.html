<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="system_manual.css">
<TITLE>Images</TITLE>
</HEAD>
<BODY >
<A HREF="system_manual002.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual004.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc7">Chapter&#XA0;2</A>&#XA0;&#XA0;Images</H1><UL>
<LI><A HREF="system_manual003.html#toc4">Char Images</A>
</LI><LI><A HREF="system_manual003.html#toc5">Color Char Images</A>
</LI><LI><A HREF="system_manual003.html#toc6">Float Images</A>
</LI><LI><A HREF="system_manual003.html#toc7">Color Float Images</A>
</LI></UL>
<P>
<A NAME="images"></A>
</P><P>All image<A NAME="@default10"></A> structures share the following important fields:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>nrow,ncol</CODE> : define the size of the image, by the number of
rows and the number of columns (not to be overwritten by user).
Notice that the range over the <I>x</I> axis is 0 &#X2026; <CODE>ncol</CODE> &#X2212;1 and that
the range over the <I>y</I> axis is 0 &#X2026; <CODE>nrow</CODE> &#X2212;1.
</LI><LI CLASS="li-itemize"><CODE>previous, next</CODE> : pointers to the previous and the next image. These fields are used only when the image is part of a movie.
</LI></UL><P>Each image structure has also one or several fields to record the pixel values.
When the image is monochrome, there is only one field called <CODE>gray</CODE>.
Color images use three fields called <CODE>red</CODE>, <CODE>green</CODE> and <CODE>blue</CODE>.
The C type of these array fields depends to the image object: they can be pointers to <CODE>unsigned char</CODE> values or pointers to <CODE>floating points</CODE> values.</P><P>You can put values in those arrays, at the expressed condition that you respect
the C type of the field and that you do not exceed the maximum value of the 
index, given by ncol &#XD7; nrow &#X2212; 1.
For example, <CODE>image-&gt;gray[y*image-&gt;ncol+x]</CODE> is the gray level of the pixel of coordinates (<I>x</I>,<I>y</I>) that is, the column #<I>x</I> and the row #<I>y</I>.
Ranges are 0 &#X2026; <I>nrow</I> &#X2212;1 for <I>y</I> and 0 &#X2026; <I>ncol</I> &#X2212;1 for <I>x</I>.</P><P>You can shorten this expression in your modules using C macro, for example:
</P><PRE CLASS="verbatim">#define _(a,i,j) ((a)-&gt;gray[(j)*(a)-&gt;ncol+(i)] )
</PRE><P>
allows you to access to the pixel (<I>x</I>,<I>y</I>) by writing <CODE>_(image,x,y)</CODE>.</P><P>Tip to speed your modules: images are built from left to right and up to down.
If you can write your algorithm to access to the pixel following this natural order,
you can speed it considerably using the following scheme. In this example, one 
copies each pixel of the cimage M into the fimage B only if the pixel of M is not
equal to zero:
</P><PRE CLASS="verbatim">  Cimage M;    /* Input of the module */
  Fimage *B;   /* Output of the module */

  register float *ptrB;
  register unsigned char *ptrM;
  register int i;

  for (i=0, ptrB = (*B)-&gt;gray, ptrM = M-&gt;gray;
               i&lt; M-&gt;ncol*M-&gt;nrow;
               i++, ptrB++, ptrM++)
            if (*ptrM) *ptrB = (float) *ptrM;
</PRE><P>
If you scan the pixels in a random order, you may rather define a bi-dimensional
tab <CODE>A</CODE> so that <CODE>A[l][c]</CODE> points to the pixel&#X2019;s value <CODE>(c,l)</CODE>.
See the functions <CODE>mw_newtab_cimage()</CODE>, <CODE>mw_newtab_fimage()</CODE>, &#X2026;</P><H2 CLASS="section"><A NAME="toc4"></A><A NAME="htoc8">2.1</A>&#XA0;&#XA0;Char Images</H2><P><A NAME="images_char-images"></A></P><P>Use preferably the <EM>Char Images</EM> memory type each time you can write an algorithm which directly computes the gray level as an integer between 0 (black) and 255 (white) : such discrete scheme will be more accurate, faster and will require far less memory than a continuous scheme (i.e. with floating points computations).</P><H3 CLASS="subsection"><A NAME="htoc9">2.1.1</A>&#XA0;&#XA0;The structure Cimage</H3><P>
<A NAME="images_char-images_structure"></A></P><P>
<A NAME="@default11"></A></P><P>Beginners should only focus on the first three fields of this structure. 
You should also consider the fields <CODE>previous</CODE> and <CODE>next</CODE> if your
image is part of a movie.
Some fields are not used this time, such <CODE>firstcol</CODE> &#X2026;<CODE>lastrow</CODE>,
but future modules may access to them.</P><PRE CLASS="verbatim">typedef struct cimage {
  int nrow;        /* Number of rows (dy) */
  int ncol;        /* Number of columns (dx) */
  unsigned char *gray;     /* The Gray level plane (may be NULL) */

  float scale;     /* Scale of the picture (should be 1 for original pict.) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the picture : */
  int firstcol;    /* index of the first col not affected by left side effect*/
  int lastcol;     /* index of the last col not affected by right side effect*/
  int firstrow;    /* index of the first row not aff. by upper side effect */  
  int lastrow;     /* index of the last row not aff. by lower side effect */  

  /* For use in Movies only */
  struct cimage *previous; /* Pointer to the previous image (may be NULL) */
  struct cimage *next; /* Pointer to the next image (may be NULL) */

} *Cimage;
</PRE><P>Do not change by yourself the content of <CODE>nrow</CODE> and <CODE>ncol</CODE>: the size
of the image has to be modified using functions of the library only (see section&#XA0;<A HREF="#images_char-images_function">2.1.3</A> page&#XA0;<A HREF="#images_char-images_function">??</A>).</P><H3 CLASS="subsection"><A NAME="htoc10">2.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="images_char-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"IMG"</CODE><A NAME="@default12"></A> Original format defined by the defunct software PCVision (from ImageAction), and widely used by MegaWave1.
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
</LI><LI CLASS="li-enumerate"><CODE>"TIFF"</CODE><A NAME="@default13"></A> Tag Image Format with one 8-bits plane (unsigned char gray levels).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by Sam Leffler and Silicon Graphics, Inc.
To use this format, you need the TIFF library (libtiff). See the Volume One, section 
&#X201C;Installation&#X201D;. Output objects are created without compression.
</LI><LI CLASS="li-enumerate"><CODE>"PGMA"</CODE><A NAME="@default14"></A> PGM (portable graymap file format) in Ascii version.
</LI><LI CLASS="li-enumerate"><CODE>"PGMR"</CODE><A NAME="@default15"></A> PGM (portable graymap file format) in Rawbits version.
</LI><LI CLASS="li-enumerate"><CODE>"PM_C"</CODE><A NAME="@default16"></A> PM format with one 8-bits plane (unsigned char gray levels).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the University of Pennsylvania, USA.
</LI><LI CLASS="li-enumerate"><CODE>"GIF"</CODE><A NAME="@default17"></A> GIF87 (Graphics Interchange Format) 8-bits per pixel, non interlaced.
This format has been developed by CompuServe Incorporated.
</LI><LI CLASS="li-enumerate"><CODE>"BMP"</CODE><A NAME="@default18"></A> Microsoft BMP 8-bits per pixel.
Output objects are created using Windows BMP format. Compression methods are not implemented.
</LI><LI CLASS="li-enumerate"><CODE>"JFIF"</CODE><A NAME="@default19"></A> JPEG/JFIF format with one 8-bits plane (unsigned char gray levels).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the Independent JPEG Group&#X2019;s software.
To use this format, you need the JPEG library (libjpeg). See the Volume One, section 
&#X201C;Installation&#X201D;. 
The compression ratio is defined by the quality factor, which is an integer between 1 (worse) and 100 (best).
Default quality factor is 100. To change this value, add it as an option to the JFIF type.
For example, JFIF:50 means JFIF file type with quality factor 50.
Whatever the quality factor, output objects are created with loosely compression.
</LI><LI CLASS="li-enumerate"><CODE>"PS"</CODE><A NAME="@default20"></A> PostScript (level 1) format, <EM>for output objects only</EM>.
This format has been developed by Adobe Systems Incorporated.
</LI><LI CLASS="li-enumerate"><CODE>"EPSF"</CODE><A NAME="@default21"></A> Encapsulated PostScript (level 1) format, <EM>for output objects only</EM>.
Same as PS format but more suitable when used with some softwares that recognize encapsulated comments, such as L<sup>A</sup>T<sub>E</sub>X.
</LI><LI CLASS="li-enumerate"><CODE>"INR"</CODE><A NAME="@default22"></A> Original format defined by the software Inrimage (from INRIA). This is a very old version, implemented for
backward-compatibility with MegaWave1, and it should not be used anymore.
</LI><LI CLASS="li-enumerate"><CODE>"MTI"</CODE><A NAME="@default23"></A> Original format defined by the software MultImage (from 2AI), and used by MegaWave1. Quite exotic now.
</LI><LI CLASS="li-enumerate"><CODE>"BIN"</CODE><A NAME="@default24"></A> This is the &#X201C;universal&#X201D; image format for 8-bits gray levels images.
It records one byte per pixel, without header.
Since it does not contain any header, the image file must be a square (i.e. the number of columns and the number of lines must be the same).
</LI></OL><H3 CLASS="subsection"><A NAME="htoc11">2.1.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="images_char-images_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Cimage</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_cimage</FONT></B> - Allocate the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cimage mw_alloc_cimage(image,nrow,ncol)</P><P>Cimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the gray plane of a <TT>Cimage </TT>structure previously
created using <CODE>mw_new_cimage</CODE>. The size of the image is given by 
<CODE>nrow</CODE> (number of rows or maximum range of <I>y</I> plus one) and <CODE>ncol</CODE>
(number of columns or maximum range of <I>x</I> plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.</P><P>Do not use this function if <CODE>image</CODE> has already an allocated plane: use
the function <CODE>mw_change_cimage</CODE> instead.</P><P>The function <CODE>mw_alloc_cimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cimage()) == NULL) ||
      (mw_alloc_cimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to white */
image-&gt;gray[256] = 255;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_cimage</FONT></B> - Change the size of the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cimage mw_change_cimage(image, nrow, ncol)</P><P>Cimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the gray plane of a <TT>Cimage </TT>structure, even if no previously memory allocation was done.
The new size of the image is given by <CODE>nrow</CODE> (number of rows or maximum 
range of <I>y</I> plus one) and <CODE>ncol</CODE> (number of columns or maximum range of 
<I>x</I> plus one). </P><P>It can also create the structure if the input <CODE>image = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_cimage</CODE> and
<CODE>mw_alloc_cimage</CODE>. It is the recommended function to set image 
dimension of input/output modules. Since the function can set the 
address of <CODE>image</CODE>, the variable must be set to the return value of 
the function (See example below).</P><P>The function <CODE>mw_change_cimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage u; 

/* Usage when &lt;u&gt; IS NOT an output of the module (and has not been
   previously allocated): the function returns a new structure's address
*/
u = mw_change_cimage(NULL, 256, 256);

/* Usage when &lt;u&gt; IS an output of the module (or has been previously
   allocated): DO NOT change the structure's address
*/
u = mw_change_cimage(u, 256, 256);

if (u == NULL) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_cimage</FONT></B> - Clear the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_cimage(image, v)</P><P>Cimage image;</P><P>unsigned char v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the cimage <CODE>image</CODE> with the gray value given by <I>v</I>:
all pixels will have the gray level <I>v</I>. </P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Output of module */

image = mw_change_cimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to white */
mw_clear_cimage(image,255);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_cimage</FONT></B> - Copy the pixel values of an image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_cimage(in, out)</P><P>Cimage in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the gray plane of the image <CODE>in</CODE> into 
the gray plane of the image <CODE>out</CODE>.
The size of the two gray planes must be the same.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cimage G; /* Needed Input */
Cimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_cimage(F, G-&gt;nrow, G-&gt;ncol)) == NULL)
 mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_cimage(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_cimage</FONT></B> - Deallocate the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_cimage(image)</P><P>Cimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the gray plane of a <TT>Cimage </TT>structure previously
allocated using <CODE>mw_alloc_cimage</CODE> or <CODE>mw_change_cimage</CODE>, and the
structure itself. </P><P>You should set <CODE>image = NULL</CODE> after this call since the address pointed
by <CODE>image</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cimage()) == NULL) ||
      (mw_alloc_cimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_cimage(image);
image = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_draw_cimage</FONT></B> - Draw a line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_draw_cimage(image, a0, b0, a1, b1, c)</P><P>Cimage image;</P><P>int a0,b0,a1,b1;
unsigned char c;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function draws in <CODE>image</CODE> a connected line of gray level <I>c</I> between the pixel (<I>a</I>0,<I>b</I>0) and the pixel (<I>a</I>1,<I>b</I>1).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Output of module */

image = mw_change_cimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to white */
mw_clear_cimage(image,255);
/* Draw a black diagonal line */
mw_draw_cimage(image,0,0,99,99,0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_getdot_cimage</FONT></B> - Return the gray level value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char mw_getdot_cimage(image, x, y)</P><P>Cimage image;</P><P>int x,y;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the gray level value (a number between 0 - black - and 255 - white -) of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>).</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value. See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to read pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
 printf("image(%d,%d) = %d\n",x,y,mw_getdot_cimage(image,x,y));
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_isitbinary_cimage</FONT></B> - Check if the image is binary</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char mw_isitbinary_cimage(image)</P><P>Cimage image;</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns 0 if <CODE>image</CODE> is not a binary image, a value &gt; 0
if it is one. In that case, the returned value corresponds to the maxima 
value that is, to the only one value &#X2260; 0.
Image with two gray levels only but with the minimal value &gt; 0 is not 
considered by this function as binary.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Needed Input of module */
unsigned char white;

if ((white=mw_isitbinary_cimage(image)) &gt; 0)
 printf("Binary image with white set to %d\n",(int) white);
else  
 printf("Not a binary image\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_newtab_gray_cimage</FONT></B> - Create a bi-dimensional tab for the pixels of a Cimage</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char ** mw_newtab_gray_cimage(image)</P><P>Cimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; gray level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the gray plane of the given image.</P><P>This function must be called after the gray plane has been allocated,
using for example one of the functions <CODE>mw_new_cimage</CODE>, 
<CODE>mw_alloc_cimage</CODE> or <CODE>mw_change_cimage</CODE>. 
After that, if the gray plane allocation is changed
(by e.g. <CODE>mw_change_cimage</CODE> or <CODE>mw_delete_cimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Needed Input of module (gray plane already allocated and filled) */
int x,y;      /* Needed Input of module */
unsigned char **tab;

tab =  mw_newtab_gray_cimage(image);
if (tab==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put white color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) tab[y][x] = 255;
else mwerror(ERROR,1,"Out of bounds !\n");

free(tab);

</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cimage mw_new_cimage();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Cimage </TT>structure with an empty gray plane.
No pixels can be addressed at this time.
The gray plane may be allocated using the function <CODE>mw_alloc_cimage</CODE> or
<CODE>mw_change_cimage</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_cimage</CODE>.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output movie.</P><P>The function <CODE>mw_new_cimage</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cimage()) == NULL) ||
      (mw_alloc_cimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_plot_cimage</FONT></B> - Set the gray level value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_plot_cimage(image, x, y, v)</P><P>Cimage image;</P><P>int x,y;</P><P>unsigned char v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function set the gray level value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>) to be <CODE>v</CODE> (a number between 0 - black - and 255 - white -).</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to write pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put white color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
        mw_plot_cimage(image,x,y,255);
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><H2 CLASS="section"><A NAME="toc5"></A><A NAME="htoc12">2.2</A>&#XA0;&#XA0;Color Char Images</H2><P><A NAME="images_color-char-images"></A></P><P>Use the <EM>Color Char Images</EM> memory type each time you want to process 
color images. As in the Char Images case, the use of this format instead of the
corresponding floating point format (<CODE>Cfimage</CODE>) is strongly recommended.</P><H3 CLASS="subsection"><A NAME="htoc13">2.2.1</A>&#XA0;&#XA0;The structure Ccimage</H3><P>
<A NAME="images_color-char-images_structure"></A></P><P>
<A NAME="@default25"></A></P><P>Beginners should focus on the first five fields only of this structure. 
You should also consider the fields <CODE>previous</CODE> and <CODE>next</CODE> if your
image is part of a movie.
Some fields are not used at this time, such <CODE>firstcol</CODE> &#X2026;<CODE>lastrow</CODE>, but future modules may access to them.</P><PRE CLASS="verbatim">typedef struct ccimage {
  int nrow;        /* Number of rows (dy) */
  int ncol;        /* Number of columns (dx) */

  unsigned char *red;     /* The red level plane (may be NULL) */
  unsigned char *green;   /* The green level plane (may be NULL) */
  unsigned char *blue;    /* The blue level plane (may be NULL) */

  float scale;     /* Scale of the picture (should be 1 for original pict.) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the picture : */
  int firstcol;    /* index of the first col not affected by left side effect*/
  int lastcol;     /* index of the last col not affected by right side effect*/
  int firstrow;    /* index of the first row not aff. by upper side effect */  
  int lastrow;     /* index of the last row not aff. by lower side effect */  

  /* For use in Movies only */
  struct ccimage *previous; /* Pointer to the previous image (may be NULL) */
  struct ccimage *next; /* Pointer to the next image (may be NULL) */

} *Ccimage;

</PRE><P>Do not change by yourself the content of <CODE>nrow</CODE> and <CODE>ncol</CODE>: the size
of the image has to be modified using functions of the library only (see section&#XA0;<A HREF="#images_color-char-images_function">2.2.3</A> page&#XA0;<A HREF="#images_color-char-images_function">??</A>).</P><P>You can put <CODE>unsigned char</CODE> values in the arrays <CODE>red</CODE>, <CODE>green</CODE>,
<CODE>blue</CODE> at the expressed condition that you do not exceed the maximum value of the index,
given by ncol &#XD7; nrow &#X2212; 1.</P><P>Actually, everything works as for the <TT>Cimage </TT>structure (see section&#XA0;<A HREF="#images_char-images_structure">2.1.1</A> page&#XA0;<A HREF="#images_char-images_structure">??</A>) but you
have to deal with three planes instead of only one.
That is the proportion between each RGB component that will give you the
color. Notice that you can get more than 16 millions of different colors
(2<SUP>3 &#XD7; 8</SUP> exactly), so you need appropriate device to see or print
such image with fidelity.</P><H3 CLASS="subsection"><A NAME="htoc14">2.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="images_color-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"TIFFC"</CODE><A NAME="@default26"></A> Tag Image Format with three 8-bits color planes (24 bits color).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object. 
It has been developed by Sam Leffler and Silicon Graphics, Inc.
To use this format, you need the TIFF library (libtiff). See the Volume One, section 
&#X201C;Installation&#X201D;.
Output objects are created without compression.
</LI><LI CLASS="li-enumerate"><CODE>"PMC_C"</CODE><A NAME="@default27"></A> 
PM format with three 8-bits planes (24 bits color).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the University of Pennsylvania, USA.
</LI><LI CLASS="li-enumerate"><CODE>"BMPC"</CODE><A NAME="@default28"></A> Microsoft BMP 24-bits per pixel.
Output objects are created using Windows BMP format. Compression methods are not implemented.
</LI><LI CLASS="li-enumerate"><CODE>"PPM"</CODE><A NAME="@default29"></A> Portable pixmap format (24 bits color).
Only the "raw" PPM format is supported, the "plain" (ascii) one
being definitely too wasteful of space to record color images.
</LI><LI CLASS="li-enumerate"><CODE>"JFIFC"</CODE><A NAME="@default30"></A><A NAME="@default31"></A>
JPEG/JFIF format with three 8-bits planes (24 bits color).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the Independent JPEG Group&#X2019;s software.
To use this format, you need the JPEG library (libjpeg). See the Volume One, section 
&#X201C;Installation&#X201D;. 
The compression ratio is defined by the quality factor, which is an integer between 1 (worse) and 100 (best).
Default quality factor is 100. To change this value, add it as an option to the JFIFC type.
For example, JFIFC:50 means JFIFC file type with quality factor 50.
Whatever the quality factor, output objects are created with loosely compression.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc15">2.2.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="images_color-char-images_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Ccimage</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_ccimage</FONT></B> - Allocate the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccimage mw_alloc_ccimage(image,nrow,ncol)</P><P>Ccimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the RGB planes of a <TT>Ccimage </TT>structure previously
created using <CODE>mw_new_ccimage</CODE>. The size of the image is given by 
<CODE>nrow</CODE> (number of rows or maximum range of <I>y</I> plus one) and <CODE>ncol</CODE>
(number of columns or maximum range of <I>x</I> plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.</P><P>Do not use this function if <CODE>image</CODE> has already an allocated plane: use
the function <CODE>mw_change_ccimage</CODE> instead.</P><P>The function <CODE>mw_alloc_ccimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the RGB planes. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_ccimage()) == NULL) ||
      (mw_alloc_ccimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to white */
image_&gt;red[256] = image-&gt;green[256] = image-&gt;blue[256] = 255;
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccimage mw_change_ccimage(image, nrow, ncol)</P><P>Ccimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the RGB planes of a <TT>Ccimage </TT>structure, even if no previously memory allocation was done.
The new size of the image is given by <CODE>nrow</CODE> (number of rows or maximum 
range of <I>y</I> plus one) and <CODE>ncol</CODE> (number of columns or maximum range of 
<I>x</I> plus one). </P><P>It can also create the structure if the input <CODE>image = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_ccimage</CODE> and
<CODE>mw_alloc_ccimage</CODE>. It is the recommended function to set image 
dimension of input/output modules. 
Since the function can set the address of <CODE>image</CODE>, the variable must be set to the return value of the function (See example below).</P><P>The function <CODE>mw_change_ccimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the RGB planes. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cimage Output; /* Output of module */

Output = mw_change_ccimage(Output, 256, 256);
if (Output == NULL) mwerror(FATAL,1,"Not enough memory.\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_ccimage</FONT></B> - Clear the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_ccimage(image, r,g,b)</P><P>Ccimage image;</P><P>unsigned char r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the ccimage <CODE>image</CODE> with the color given by 
the triplet <CODE>r,g,b</CODE>: all pixels will have this RGB value.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Output of module */

image = mw_change_ccimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to blue */
mw_clear_ccimage(image,0,0,255);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_ccimage</FONT></B> - Copy the pixel values of color image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_ccimage(in, out)</P><P>Ccimage in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the RGB planes of the image <CODE>in</CODE> into 
the RGB planes of the image <CODE>out</CODE>.
The size of the two RGB planes must be the same.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Ccimage G; /* Needed Input */
Ccimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_ccimage(F, G-&gt;nrow, G-&gt;ncol)) == NULL)
     mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_ccimage(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_ccimage</FONT></B> - Deallocate the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_ccimage(image)</P><P>Ccimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the RGB planes of a <TT>Ccimage </TT>structure previously
allocated using <CODE>mw_alloc_ccimage</CODE> or <CODE>mw_change_ccimage</CODE>, and the
structure itself. </P><P>You should set <CODE>image = NULL</CODE> after this call since the address pointed
by <CODE>image</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_ccimage()) == NULL) ||
      (mw_alloc_ccimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_ccimage(image);
image = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_draw_ccimage</FONT></B> - Draw a line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_draw_ccimage(image, a0, b0, a1, b1, r, g, b)</P><P>Ccimage image;</P><P>int a0,b0,a1,b1;</P><P>unsigned char r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function draws in <CODE>image</CODE> a connected line between the pixel (<I>a</I>0,<I>b</I>0) and the pixel (<I>a</I>1,<I>b</I>1). The color of the line is defined by the triplet <CODE>r,g,b</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Output of module */

image = mw_change_ccimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to white */
mw_clear_ccimage(image,255,255,255);
/* Draw a red diagonal line */
mw_draw_ccimage(image,0,0,99,99,255,0,0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_getdot_ccimage</FONT></B> - Return the RGB value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_getdot_ccimage(image, x, y, r, g, b)</P><P>Ccimage image;</P><P>int x,y;</P><P>unsigned char *r,*g,*b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the RGB value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>).
The RGB value consists of the triplet <CODE>*r,*g,*b</CODE>: <CODE>*r</CODE> (a number between 0 and 255) gives you the proportion of red, <CODE>*g</CODE> the proportion of green and <CODE>*b</CODE> the proportion of blue.</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to read pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module */
int x,y;       /* Needed Inputs of module */
unsigned char r,g,b;  /* Internal use */

if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
  { 
    mw_getdot_ccimage(image,x,y,&amp;r,&amp;g,&amp;b);
    printf("image(%d,%d) = %d,%d,%d\n",x,y,(int)r,(int)g,(int)b);
  }
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_newtab_blue_ccimage</FONT></B> - Create a bi-dimensional tab for the blue pixels of a Ccimage</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char ** mw_newtab_blue_ccimage(image)</P><P>Ccimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; blue level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the blue plane of the given image.</P><P>This function must be called after the blue plane has been allocated,
using for example one of the functions <CODE>mw_new_ccimage</CODE>, 
<CODE>mw_alloc_ccimage</CODE> or <CODE>mw_change_ccimage</CODE>. 
After that, if the blue plane allocation is changed
(by e.g. <CODE>mw_change_ccimage</CODE> or <CODE>mw_delete_ccimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the blue value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Red and green pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_red_ccimage</CODE> and <CODE>mw_newtab_green_ccimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
unsigned char **red,**green,**blue;

red =  mw_newtab_red_ccimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_ccimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_ccimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put gray color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 127;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char ** mw_newtab_green_ccimage(image)</P><P>Ccimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; green level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the green plane of the given image.</P><P>This function must be called after the green plane has been allocated,
using for example one of the functions <CODE>mw_new_ccimage</CODE>, 
<CODE>mw_alloc_ccimage</CODE> or <CODE>mw_change_ccimage</CODE>. 
After that, if the green plane allocation is changed
(by e.g. <CODE>mw_change_ccimage</CODE> or <CODE>mw_delete_ccimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the green value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Red and blue pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_red_ccimage</CODE> and <CODE>mw_newtab_blue_ccimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
unsigned char **red,**green,**blue;

red =  mw_newtab_red_ccimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_ccimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_ccimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put gray color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 127;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned char ** mw_newtab_red_ccimage(image)</P><P>Ccimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; red level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the red plane of the given image.</P><P>This function must be called after the red plane has been allocated,
using for example one of the functions <CODE>mw_new_ccimage</CODE>, 
<CODE>mw_alloc_ccimage</CODE> or <CODE>mw_change_ccimage</CODE>. 
After that, if the red plane allocation is changed
(by e.g. <CODE>mw_change_ccimage</CODE> or <CODE>mw_delete_ccimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the red value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Green and blue pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_green_ccimage</CODE> and <CODE>mw_newtab_blue_ccimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
unsigned char **red,**green,**blue;

red =  mw_newtab_red_ccimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_ccimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_ccimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put gray color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 127;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccimage mw_new_ccimage();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Ccimage </TT>structure with empty RGB planes.
No pixels can be addressed at this time.
The RGB planes may be allocated using the function <CODE>mw_alloc_ccimage</CODE> or
<CODE>mw_change_ccimage</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_ccimage</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_ccimage</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_ccimage()) == NULL) ||
      (mw_alloc_ccimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_plot_ccimage(image, x, y, r, g, b)</P><P>Ccimage image;</P><P>int x,y;</P><P>unsigned char r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function set the RGB value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>) to be the triplet <CODE>r,g,b</CODE>:
<CODE>r</CODE> (a number between 0 and 255) gives you the proportion of red, <CODE>g</CODE> the proportion of green and <CODE>b</CODE> the proportion of blue.</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to write pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Ccimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put green color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
        mw_plot_ccimage(image,x,y,0,255,0);
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><H2 CLASS="section"><A NAME="toc6"></A><A NAME="htoc16">2.3</A>&#XA0;&#XA0;Float Images</H2><P><A NAME="images_float-images"></A>

<A NAME="@default32"></A></P><P>You may want to use this format when your algorithm process image computations
using floating point arithmetic (continuous scheme). 
You may also use this format to represent any kind of two-dimensional real data (such as matrix).</P><P>Notice that you may lose precision when you use such format as the input
of another module which requires integer representation (<TT>Cimage </TT>type), e.g.
printing or displaying devices.
In the other side, a module which accepts <TT>Fimage </TT>type as the input will also
work without degradation if you put a <TT>Cimage </TT>type instead.
It is so better to use, if possible, <TT>Cimage </TT>type for output variables and <TT>Fimage </TT>type for input.</P><H3 CLASS="subsection"><A NAME="htoc17">2.3.1</A>&#XA0;&#XA0;The structure Fimage</H3><P>
<A NAME="images_float-images_structure"></A></P><P>This memory type is exactly the same as <TT>Cimage </TT>(See section&#XA0;<A HREF="#images_char-images_structure">2.1.1</A> page&#XA0;<A HREF="#images_char-images_structure">??</A>): the only difference is about the <CODE>gray</CODE> field which is a pointer to floating points values.</P><P>Consequently, there is no formal correspondance between a gray level value
and a visual gray level (e.g. 255.0 may not represent &#X201C;white&#X201D;).</P><PRE CLASS="verbatim">typedef struct fimage {
  int nrow;        /* Number of rows (dy) */
  int ncol;        /* Number of columns (dx) */
  float *gray;     /* The Gray level plane (may be NULL) */

  float scale;     /* Scale of the picture (should be 1 for original pict.) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the picture : */
  int firstcol;    /* index of the first col not affected by left side effect*/
  int lastcol;     /* index of the last col not affected by right side effect*/
  int firstrow;    /* index of the first row not aff. by upper side effect */  
  int lastrow;     /* index of the last row not aff. by lower side effect */  

} *Fimage;
</PRE><H3 CLASS="subsection"><A NAME="htoc18">2.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="images_float-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"RIM"</CODE><A NAME="@default33"></A> 
Original format defined by MegaWave1. 
It is close to the IMG format, but it uses a 32-bits plane in order to record floating point values.
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
</LI><LI CLASS="li-enumerate"><CODE>"PM_F"</CODE><A NAME="@default34"></A> 
PM format with one 32-bits plane (floating point gray levels).
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc19">2.3.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="images_float-images_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Fimage</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_fimage</FONT></B> - Allocate the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fimage mw_alloc_fimage(image,nrow,ncol)</P><P>Fimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the gray plane of a <TT>Fimage </TT>structure previously
created using <CODE>mw_new_fimage</CODE>. The size of the image is given by 
<CODE>nrow</CODE> (number of rows or maximum range of <I>y</I> plus one) and <CODE>ncol</CODE>
(number of columns or maximum range of <I>x</I> plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.</P><P>Do not use this function if <CODE>image</CODE> has already an allocated plane: use
the function <CODE>mw_change_fimage</CODE> instead.</P><P>The function <CODE>mw_alloc_fimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to the value -1.0 */
image-&gt;gray[256] = -1.0;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_fimage</FONT></B> - Change the size of the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fimage mw_change_fimage(image, nrow, ncol)</P><P>Fimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the gray plane of a <TT>Fimage </TT>structure, even if no previously memory allocation was done.
The new size of the image is given by <CODE>nrow</CODE> (number of rows or maximum 
range of <I>y</I> plus one) and <CODE>ncol</CODE> (number of columns or maximum range of 
<I>x</I> plus one). </P><P>It can also create the structure if the input <CODE>image = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_fimage</CODE> and
<CODE>mw_alloc_fimage</CODE>. It is the recommended function to set image 
dimension of input/output modules. Since the function can set the 
address of <CODE>image</CODE>, the variable must be set to the return value of 
the function (See example below).</P><P>The function <CODE>mw_change_fimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the gray plane. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage u; 

/* Usage when &lt;u&gt; IS NOT an output of the module (and has not been
   previously allocated): the function returns a new structure's address
*/
u = mw_change_fimage(NULL, 256, 256);

/* Usage when &lt;u&gt; IS an output of the module (or has been previously
   allocated): DO NOT change the structure's address
*/
u = mw_change_fimage(u, 256, 256);

if (u == NULL) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_fimage</FONT></B> - Clear the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_fimage(image, v)</P><P>Fimage image;</P><P>float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the fimage <CODE>image</CODE> with the gray value given by <I>v</I>:
all pixels will have the gray level <I>v</I>. </P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Output of module */

image = mw_change_fimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to 0.0 */
mw_clear_fimage(image,0.0);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_fimage</FONT></B> - Copy the pixel values of an image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_fimage(in, out)</P><P>Fimage in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the gray plane of the image <CODE>in</CODE> into 
the gray plane of the image <CODE>out</CODE>.
The size of the two gray planes must be the same.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Fimage G; /* Needed Input */
Fimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_fimage(F, G-&gt;nrow, G-&gt;ncol)) == NULL)
 mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_fimage(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_fimage</FONT></B> - Deallocate the gray plane</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_fimage(image)</P><P>Fimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the gray plane of a <TT>Fimage </TT>structure previously
allocated using <CODE>mw_alloc_fimage</CODE> or <CODE>mw_change_fimage</CODE>, and the
structure itself. </P><P>You should set <CODE>image = NULL</CODE> after this call since the address pointed
by <CODE>image</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_fimage(image);
image = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_draw_fimage</FONT></B> - Draw a line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_draw_fimage(image, a0, b0, a1, b1, c)</P><P>Fimage image;</P><P>int a0,b0,a1,b1;
float c;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function draws in <CODE>image</CODE> a connected line of gray level <I>c</I> between the pixel (<I>a</I>0,<I>b</I>0) and the pixel (<I>a</I>1,<I>b</I>1).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Output of module */

image = mw_change_fimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Clear all pixels */
mw_clear_fimage(image,0.0);
/* Draw a diagonal line of gray level 1.0 */
mw_draw_fimage(image,0,0,99,99,1.0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_getdot_fimage</FONT></B> - Return the gray level value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
float mw_getdot_fimage(image, x, y)</P><P>Fimage image;</P><P>int x,y;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the gray level value (any floating point number) of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>).</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value. See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to read pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
 printf("image(%d,%d) = %f\n",x,y,mw_getdot_fimage(image,x,y));
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_newtab_gray_fimage</FONT></B> - Create a bi-dimensional tab for the pixels of a Fimage</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
float ** mw_newtab_gray_fimage(image)</P><P>Fimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; gray level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the gray plane of the given image.</P><P>This function must be called after the gray plane has been allocated,
using for example one of the functions <CODE>mw_new_fimage</CODE>, 
<CODE>mw_alloc_fimage</CODE> or <CODE>mw_change_fimage</CODE>. 
After that, if the gray plane allocation is changed
(by e.g. <CODE>mw_change_fimage</CODE> or <CODE>mw_delete_fimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using<CODE>tab[y][x]</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Needed Input of module (gray plane already allocated and filled) */
int x,y;      /* Needed Input of module */
float **tab;

tab =  mw_newtab_gray_fimage(image);
if (tab==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put 0 in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) tab[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(tab);

</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fimage mw_new_fimage();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Fimage </TT>structure with an empty gray plane.
No pixels can be addressed at this time.
The gray plane may be allocated using the function <CODE>mw_alloc_fimage</CODE> or
<CODE>mw_change_fimage</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_fimage</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_fimage</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_fimage()) == NULL) ||
      (mw_alloc_fimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_plot_fimage</FONT></B> - Set the gray level value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_plot_fimage(image, x, y, v)</P><P>Fimage image;</P><P>int x,y;</P><P>float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function set the gray level value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>) to be <CODE>v</CODE> (any floating point number).</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to write pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Fimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put 0.0 in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
        mw_plot_fimage(image,x,y,0.0);
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><H2 CLASS="section"><A NAME="toc7"></A><A NAME="htoc20">2.4</A>&#XA0;&#XA0;Color Float Images</H2><P><A NAME="images_color-float-images"></A></P><P>You may want to use this format when you need to process color images with
floating point precision (continuous scheme). 
Please notice that this format wastes a lot of memory and computational
time. </P><H3 CLASS="subsection"><A NAME="htoc21">2.4.1</A>&#XA0;&#XA0;The structure Cfimage</H3><P>
<A NAME="images_color-float-images_structure"></A></P><P>
<A NAME="@default35"></A></P><P>This memory type is not exactly the same as <TT>Ccimage </TT>(See section&#XA0;<A HREF="#images_color-char-images_structure">2.2.1</A> page&#XA0;<A HREF="#images_color-char-images_structure">??</A>): the difference is not
only about the RGB fields which are pointers to floating points values and not to unsigned
char, but also about the <EM>color model</EM>. A color model<A NAME="@default36"></A> is a specification of a 
3D-coordinate system and a subspace within that system where each color is represented by
a single point. 
Whatever the color model, a cfimage is alway made by three planes called <CODE>red</CODE>, 
<CODE>green</CODE> and <CODE>blue</CODE>. The significance of those planes is given by the value
of the <CODE>model</CODE> field. The first plane <CODE>red</CODE> matches the first letter of
the model&#X2019;s name (e.g. R for RGB model, H for HSI model), the second plane <CODE>green</CODE> 
matches the second letter of the model&#X2019;s name (e.g. G for RGB model, S for HSI model),
and the third plane <CODE>blue</CODE> matches the third letter (e.g. B for RGB model, I for HSI 
model).</P><P>The implemented color models are 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>MODEL_RGB</TT> <A NAME="@default37"></A>Cartesian coordinate system Red, Green, Blue. 
</LI><LI CLASS="li-itemize"><TT>MODEL_YUV</TT> <A NAME="@default38"></A> YUV coordinate system (CCIR 601-1).
</LI><LI CLASS="li-itemize"><TT>MODEL_HSI</TT> <A NAME="@default39"></A> HSI coordinate system (H is Hue, S is Saturation and I is Intensity
or luminance). 
</LI><LI CLASS="li-itemize"><TT>MODEL_HSV</TT> <A NAME="@default40"></A> HSV coordinate system (H is Hue, S is Saturation and V is Value).
</LI></UL><P>Be aware that a MegaWave2 module which takes a cfimage in input performs a statement
likely to work for one color model only. One should checks the value of the <CODE>model</CODE> 
field before any statement.</P><PRE CLASS="verbatim">typedef struct cfimage {
  int nrow;        /* Number of rows (dy) */
  int ncol;        /* Number of columns (dx) */
  int model;       /* Model of the colorimetric system */

  float *red;      /* The Red plane if model=MODEL_RGB (may be NULL) or Y/H   */
  float *green;    /* The Green plane if model=MODEL_RGB (may be NULL) or U/S */
  float *blue;     /* The Blue plane if model=MODEL_RGB (may be NULL) or V/I  */

  float scale;     /* Scale of the picture (should be 1 for original pict.) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  
  /* Defines the signifiant part of the picture : */
  int firstcol;    /* index of the first col not affected by left side effect*/
  int lastcol;     /* index of the last col not affected by right side effect*/
  int firstrow;    /* index of the first row not aff. by upper side effect */  
  int lastrow;     /* index of the last row not aff. by lower side effect */  

} *Cfimage;
</PRE><H3 CLASS="subsection"><A NAME="htoc22">2.4.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="images_color-float-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<A NAME="@default41"></A> 
PM format with three 8-bits planes, each plane being of float values.
This format carries the comments field (<CODE>cmt</CODE>) of the memory object.
It has been developed by the University of Pennsylvania, USA.
An extension has been performed to record the <CODE>model</CODE> value.
In the case of RGB model, the format is exactly the same as the original.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc23">2.4.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="images_color-float-images_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Cfimage</CODE> type. The list is in alphabetical order.
Conversion between memory models are not implemented as functions of
the system library, but as modules (see volume three: &#X201C;MegaWave2 user modules library&#X201D;). </P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_cfimage</FONT></B> - Allocate the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfimage mw_alloc_cfimage(image,nrow,ncol)</P><P>Cfimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the RGB planes of a <TT>Cfimage </TT>structure previously
created using <CODE>mw_new_cfimage</CODE>. The size of the image is given by 
<CODE>nrow</CODE> (number of rows or maximum range of <I>y</I> plus one) and <CODE>ncol</CODE>
(number of columns or maximum range of <I>x</I> plus one).
Pixels can be addressed after this call, if the allocation successed. There is
no default value for the pixels.</P><P>Do not use this function if <CODE>image</CODE> has already an allocated plane: use
the function <CODE>mw_change_cfimage</CODE> instead.</P><P>The function <CODE>mw_alloc_cfimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the RGB planes. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cfimage()) == NULL) ||
      (mw_alloc_cfimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set pixel (0,1) to (0.0,0.0,0.0) */
image_&gt;red[256] = image-&gt;green[256] = image-&gt;blue[256] = 0.0;
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfimage mw_change_cfimage(image, nrow, ncol)</P><P>Cfimage image;</P><P>int nrow, ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the RGB planes of a <TT>Cfimage </TT>structure, even if no previously memory allocation was done.
The new size of the image is given by <CODE>nrow</CODE> (number of rows or maximum 
range of <I>y</I> plus one) and <CODE>ncol</CODE> (number of columns or maximum range of 
<I>x</I> plus one). </P><P>It can also create the structure if the input <CODE>image = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_cfimage</CODE> and
<CODE>mw_alloc_cfimage</CODE>. It is the recommended function to set image 
dimension of input/output modules. 
Since the function can set the address of <CODE>image</CODE>, the variable must be set to the return value of the function (See example below).</P><P>The function <CODE>mw_change_cfimage</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the RGB planes. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cimage Output; /* Output of module */

Output = mw_change_cfimage(Output, 256, 256);
if (Output == NULL) mwerror(FATAL,1,"Not enough memory.\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_cfimage</FONT></B> - Clear the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_cfimage(image, r,g,b)</P><P>Cfimage image;</P><P>float r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function fills the cfimage <CODE>image</CODE> with the color given by 
the triplet <CODE>r,g,b</CODE>: all pixels will have this RGB value.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Output of module */

image = mw_change_cfimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to (0.0,0.0,1.0) */
mw_clear_cfimage(image,0.0,0.0,1.0);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_cfimage</FONT></B> - Copy the pixel values of color image into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_cfimage(in, out)</P><P>Cfimage in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the RGB planes of the image <CODE>in</CODE> into 
the RGB planes of the image <CODE>out</CODE>.
The size of the two RGB planes must be the same.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cfimage G; /* Needed Input */
Cfimage F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_cfimage(F, G-&gt;nrow, G-&gt;ncol)) == NULL)
 mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_cfimage(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_cfimage</FONT></B> - Deallocate the RGB planes</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_cfimage(image)</P><P>Cfimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the RGB planes of a <TT>Cfimage </TT>structure previously
allocated using <CODE>mw_alloc_cfimage</CODE> or <CODE>mw_change_cfimage</CODE>, and the
structure itself. </P><P>You should set <CODE>image = NULL</CODE> after this call since the address pointed
by <CODE>image</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cfimage()) == NULL) ||
      (mw_alloc_cfimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_cfimage(image);
image = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_draw_cfimage</FONT></B> - Draw a line</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_draw_cfimage(image, a0, b0, a1, b1, r, g, b)</P><P>Cfimage image;</P><P>int a0,b0,a1,b1;</P><P>float r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function draws in <CODE>image</CODE> a connected line between the pixel (<I>a</I>0,<I>b</I>0) and the pixel (<I>a</I>1,<I>b</I>1). The color of the line is defined by the triplet <CODE>r,g,b</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Output of module */

image = mw_change_cfimage(image, 100, 100);
if (image == NULL) mwerror(FATAL,1,"Not enough memory.\n");
/* Set all pixels to (0.0,0.0,0.0) */
mw_clear_cfimage(image,0.0,0.0,0.0);
/* Draw a diagonal line with color (1.0,0.0,0.0) */
mw_draw_cfimage(image,0,0,99,99,1.0,0.0,0.0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_getdot_cfimage</FONT></B> - Return the RGB value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_getdot_cfimage(image, x, y, r, g, b)</P><P>Cfimage image;</P><P>int x,y;</P><P>float *r,*g,*b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the RGB value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>).
The RGB value consists of the triplet <CODE>*r,*g,*b</CODE>: <CODE>*r</CODE> (any floating point number) gives you the proportion of red, <CODE>*g</CODE> the proportion of green and <CODE>*b</CODE> the proportion of blue.</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
read a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to read pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module */
int x,y;       /* Needed Inputs of module */
float r,g,b;   /* Internal use */

if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
  { 
    mw_getdot_cfimage(image,x,y,&amp;r,&amp;g,&amp;b);
    printf("image(%d,%d) = %d,%d,%d\n",x,y,r,g,b);
  }
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_newtab_blue_cfimage</FONT></B> - Create a bi-dimensional tab for the blue pixels of a Cfimage</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
float ** mw_newtab_blue_cfimage(image)</P><P>Cfimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; blue level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the blue plane of the given image.</P><P>This function must be called after the blue plane has been allocated,
using for example one of the functions <CODE>mw_new_cfimage</CODE>, 
<CODE>mw_alloc_cfimage</CODE> or <CODE>mw_change_cfimage</CODE>. 
After that, if the blue plane allocation is changed
(by e.g. <CODE>mw_change_cfimage</CODE> or <CODE>mw_delete_cfimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the blue value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Red and green pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_red_cfimage</CODE> and <CODE>mw_newtab_green_cfimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
float **red,**green,**blue;

red =  mw_newtab_red_cfimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_cfimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_cfimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put black color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
float ** mw_newtab_green_cfimage(image)</P><P>Cfimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; green level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the green plane of the given image.</P><P>This function must be called after the green plane has been allocated,
using for example one of the functions <CODE>mw_new_cfimage</CODE>, 
<CODE>mw_alloc_cfimage</CODE> or <CODE>mw_change_cfimage</CODE>. 
After that, if the green plane allocation is changed
(by e.g. <CODE>mw_change_cfimage</CODE> or <CODE>mw_delete_cfimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the green value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Red and blue pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_red_cfimage</CODE> and <CODE>mw_newtab_blue_cfimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
float **red,**green,**blue;

red =  mw_newtab_red_cfimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_cfimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_cfimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put black color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
float ** mw_newtab_red_cfimage(image)</P><P>Cfimage image;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new bi-dimensional tab which allows an easy and fast
access to the pixels&#X2019; red level.
This tab is actually an one-dimensional tab of pointers, so that each pointer 
points to the beginning of a line in the red plane of the given image.</P><P>This function must be called after the red plane has been allocated,
using for example one of the functions <CODE>mw_new_cfimage</CODE>, 
<CODE>mw_alloc_cfimage</CODE> or <CODE>mw_change_cfimage</CODE>. 
After that, if the red plane allocation is changed
(by e.g. <CODE>mw_change_cfimage</CODE> or <CODE>mw_delete_cfimage</CODE>), the tab is
no longer valid and must be deleted using <CODE>free(tab)</CODE>.</P><P>Ones the tab has been correctly created, is it possible to read or to
write the red value of the pixel (<I>x</I>,<I>y</I>) (<I>x</I> being an index for column and <I>y</I>
for row) using <CODE>tab[y][x]</CODE>.</P><P>Green and blue pixels&#X2019; value can be accessed with such a tab using 
the corresponding functions<BR>
<CODE>mw_newtab_green_cfimage</CODE> and <CODE>mw_newtab_blue_cfimage</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module (RGB planes already allocated and filled) */
int x,y;      /* Needed Input of module */
float **red,**green,**blue;

red =  mw_newtab_red_cfimage(image);
if (red==NULL) mwerror(FATAL,1,"Not enough memory\n");
green =  mw_newtab_green_cfimage(image);
if (green==NULL) mwerror(FATAL,1,"Not enough memory\n");
blue =  mw_newtab_blue_cfimage(image);
if (blue==NULL) mwerror(FATAL,1,"Not enough memory\n");

/* Put black color in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow)) 
        red[y][x] = green[y][x] = blue[y][x] = 0.0;
else mwerror(ERROR,1,"Out of bounds !\n");

free(blue); free(green); free(red);
</PRE><P>
<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfimage mw_new_cfimage();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Cfimage </TT>structure with empty RGB planes.
No pixels can be addressed at this time.
The RGB planes may be allocated using the function <CODE>mw_alloc_cfimage</CODE> or
<CODE>mw_change_cfimage</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_cfimage</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_cfimage</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image=NULL; /* Internal use: no Input neither Output of module */

if  ( ((image = mw_new_cfimage()) == NULL) ||
      (mw_alloc_cfimage(image,256,256) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_plot_cfimage</FONT></B> - Set the RGB value</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_plot_cfimage(image, x, y, r, g, b)</P><P>Cfimage image;</P><P>int x,y;</P><P>float r,g,b;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function set the RGB value of the given <CODE>image</CODE> for the pixel (<I>x</I>,<I>y</I>) (column # <I>x</I> and row # <I>y</I>) to be the triplet <CODE>r,g,b</CODE>:
<CODE>r</CODE> (a floating point number) gives you the proportion of red, <CODE>g</CODE> the proportion of green and <CODE>b</CODE> the proportion of blue.</P><P>Notice that a call to this function is a slow (but easy and secure) way to 
write a pixel value.
See section&#XA0;<A HREF="#images">2</A> page&#XA0;<A HREF="#images">??</A> for how to write pixels fast.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Cfimage image; /* Needed Input of module */
int x,y;      /* Needed Inputs of module */

/* Put color (0.0,0.0,0.0) in the pixel (x,y) */
if ((x &lt; image-&gt;ncol) &amp;&amp; (y &lt; image-&gt;nrow))
        mw_plot_cfimage(image,x,y,0.0,0.0,0.0);
else mwerror(ERROR,1,"Out of bounds !\n");

</PRE><HR>
<A HREF="system_manual002.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual004.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
</BODY>
</HTML>
