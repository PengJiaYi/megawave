<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="system_manual.css">
<TITLE>Wavelets</TITLE>
</HEAD>
<BODY >
<A HREF="system_manual005.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual007.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc46">Chapter&#XA0;5</A>&#XA0;&#XA0;Wavelets</H1><UL>
<LI><A HREF="system_manual006.html#toc13">One-dimensional wavelet</A>
</LI><LI><A HREF="system_manual006.html#toc14">Two-dimensional wavelet</A>
</LI><LI><A HREF="system_manual006.html#toc15">Two-dimensional wavelet packets</A>
</LI></UL>
<P>
<A NAME="wavelets"></A>
</P><P>The wavelet<A NAME="@default54"></A> memory types are used to represent the result of a wavelet 
transform applied to some data. 
The data can be a signal, in this case the operation is called a one-dimensional wavelet tranform, or it can be an image. 
In that case, the operation is called a two-dimensional wavelet transform.
Operations on data of higher dimension are not supported at this time.</P><P>A wavelet transform<A NAME="@default55"></A> is a time-scale operator: it adds therefore one dimension 
to the data (the scale).
The meaning of the wavelet coefficients recorded into a wavelet-type variable depends to the choice of the discretization.
The finest one is known as the <EM>continuous wavelet transform</EM><A NAME="@default56"></A>: several
voices per octave can be computed for the scale. 
The <EM>orthogonal (or biorthogonal) wavelet transform</EM><A NAME="@default57"></A>
<A NAME="@default58"></A> allows to decompose
the data into an orthogonal (or biorthogonal) basis: a wavelet coefficient
corresponds to a scalar product. In this case, only one voice per octave
is computed and a decimation is achieved on the time (or space) domain.
The <EM>dyadic wavelet transform</EM><A NAME="@default59"></A> computes also only one voice per octave, but
without decimation along the time axis. It corresponds to a decomposition into wavelets
which generate a <EM>frame</EM><A NAME="@default60"></A>. It is often used to obtain a translation-invariant representation, 
from which the <EM>wavelet maxima representation</EM><A NAME="@default61"></A> can be deduced.</P><P>A natural extension to wavelet decomposition is the wavelet packet<A NAME="@default62"></A> representation,
that offers a better localization in the frequency space.
Wavelet packets are popular for at least two reasons: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
they provide a sparse representation of many texture;
</LI><LI CLASS="li-itemize">they are generally well localized in the Fourier domain. 
</LI></UL><H2 CLASS="section"><A NAME="toc13"></A><A NAME="htoc47">5.1</A>&#XA0;&#XA0;One-dimensional wavelet</H2><P><A NAME="wavelets_wtrans1d"></A></P><P>The <EM>One-dimensional wavelet</EM><A NAME="@default63"></A> memory type is used to represent the result
of a wavelet transform applied to a signal.</P><H3 CLASS="subsection"><A NAME="htoc48">5.1.1</A>&#XA0;&#XA0;The structure Wtrans1d</H3><P>
<A NAME="wavelets_wtrans1d_structure"></A></P><P>
<A NAME="@default64"></A></P><P>The C structure is the following:
</P><PRE CLASS="verbatim">typedef struct wtrans1d {
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the wtrans1d */

  int type;  /* Type of the wtrans1d performed */
  int edges; /* Type of the edges statments */
  char filter_name[mw_namesize][mw_max_nfilter_1d];   /* Filters used */
  int size; /* Size of the original signal */

  int nlevel;   /* Number of levels (octave) for this decomposition */
  int nvoice;   /* Number of voices per octave for this decomposition */
  int complex;  /* 1 if the wavelet is complex that is, if P[][] is used */
  int nfilter;  /* Number of filters used to compute the decomposition */

  Fsignal A[mw_max_nlevel+1][mw_max_nvoice]; /* Average or low-pass signals */
  Fsignal AP[mw_max_nlevel+1][mw_max_nvoice];/* Phase of the average */
  Fsignal D[mw_max_nlevel+1][mw_max_nvoice]; /* Detail or wavelet coefficients*/
  Fsignal DP[mw_max_nlevel+1][mw_max_nvoice];/* Phase of the Detail */

} *Wtrans1d;
</PRE><P>The first two fields of this structure is well known by the reader.
The field <CODE>type</CODE> records the type of the wavelet transform used.
Its value can be:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mw_orthogonal</CODE> : orthogonal wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_biorthogonal</CODE> : biorthogonal wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_dyadic</CODE> : dyadic wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_continuous</CODE> : continuous wavelet transform.
</LI></UL><P>The field <CODE>edges</CODE> gives the type of the edges statment used to compute
the transformation. Indeed, since it is implemented as a bank of convolution
products, errors occur near the borders if no special statment is performed.
This field can have the following values:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mw_edges_zeropad</CODE> : the signal is zero-padded (no special statment);
</LI><LI CLASS="li-itemize"><CODE>mw_edges_periodic</CODE> : the signal is made periodic;
</LI><LI CLASS="li-itemize"><CODE>mw_edges_mirror</CODE> : the signal is padded by mirror effect (avoid first-order discontinuities);
</LI><LI CLASS="li-itemize"><CODE>mw_edges_wadapted</CODE> : special border functions are added to the wavelets (wavelets on the interval).
</LI></UL><P>The field <CODE>filter_name</CODE> is an array of strings, where the names of the filters used for the decomposition are put. 
The number of filters is put into the field <CODE>nfilter</CODE>.
This number and the meaning of each filter depend to the wavelet type.</P><P>The field <CODE>size</CODE> contains the size of the original signal, which is put
into <CODE>average[0][0]</CODE> (see below).
The field <CODE>nlevel</CODE> is the number of levels used in this decomposition; it corresponds to the number of octaves; <CODE>nvoice</CODE> is the number of voices per octave.
The field <CODE>complex</CODE> is set to 1 when the wavelet used has complex values, 0 elsewhere.</P><P>The result of the wavelet decomposition is put into two two-dimensional arrays of signals called <CODE>A</CODE> and <CODE>D</CODE>:
<CODE>A[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT> and for
<I>v</I>=0 &#X2026; nvoice&#X2212;1 is the low-pass signal at the octave <I>l</I> and at the voice <I>v</I>, that is the signal at the scale 2<SUP>(<I>l</I>+<I>v</I>/<TT>nvoice</TT>)</SUP>.
The signal <CODE>A[0][0]</CODE> is the original signal, <CODE>A[0][1]</CODE> is the
smoothed signal at the scale 2<SUP>1/<TT>nvoice</TT></SUP>, etc.
<CODE>D[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT> and for
<I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 is the band-pass (or detail) signal at the octave <I>l</I> and at the voice <I>v</I>, that is the wavelet coefficients signal at the scale 2<SUP>(<I>l</I>+<I>v</I>/<TT>nvoice</TT>)</SUP>.
The signal <CODE>D[0][0]</CODE> is unused.</P><P>When the wavelet is complex, the fields <CODE>A</CODE> and <CODE>D</CODE> represent the
modulus values only; the phase values is put in the fields <CODE>AP</CODE> and
<CODE>DP</CODE>.</P><H3 CLASS="subsection"><A NAME="htoc49">5.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="wavelets_wtrans1d-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_WTRANS1D"</CODE><A NAME="@default65"></A> MegaWave2 Data Ascii format with a <CODE>def Wtrans1d</CODE> area.
This area includes the value of the different fields of the object, as
<CODE>comments, type, edges, ...</CODE>. 
The values of the wavelet coefficients are not recorded in this file, but in 
a set of <CODE>Fimage</CODE> objects.
Let be <CODE>wavelet</CODE> the name of the object. 
The names of these image files are, for <CODE>&lt;j&gt;</CODE> the level number (octave)
and <CODE>&lt;v&gt;</CODE> the voice number,
<UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>wavelet_&lt;j&gt;_A.wtrans1d</CODE> Average field of the object (voice 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;.&lt;v&gt;_A.wtrans1d</CODE> Average field of the object (voice &gt; 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;_AP.wtrans1d</CODE> Phase of the Average field of the object (voice 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;.&lt;v&gt;_AP.wtrans1d</CODE> Phase of the Average field of the object (voice &gt; 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;_D.wtrans1d</CODE> Detail field of the object (voice 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;.&lt;v&gt;_D.wtrans1d</CODE> Detail field of the object (voice &gt; 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;_DP.wtrans1d</CODE> Phase of the Detail field of the object (voice 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;.&lt;v&gt;_DP.wtrans1d</CODE> Phase of the Detail field of the object (voice &gt; 0).
</LI></UL>
Notice that, regarding to the type of the wavelet transform, only a subset of those files may be generated.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc50">5.1.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="wavelets_wtrans1d_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Wtrans1d</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_biortho_wtrans1d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_biortho_wtrans1d(wtrans,level,size)</P><P>Wtrans1d wtrans;</P><P>int level; </P><P>int size; </P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the arrays <CODE>A</CODE> and <CODE>D</CODE> of a <TT>Wtrans1d </TT>structure previously created using <CODE>mw_new_wtrans1d</CODE>, in order to receive
an biorthonormal wavelet representation (one voice per octave, decimation along the time axis).
Each signal <CODE>A[l][v]</CODE> and <CODE>D[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT>, <I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 ((<I>l</I>,<I>v</I>) &#X2260; (0,0)) is created and
allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original signal is given by <CODE>size</CODE>.</P><P>The arrays <CODE>A</CODE> and <CODE>D</CODE> can be addressed after this call, if the allocation successed. There is no default values for the signals.
The <CODE>type</CODE> field of the <TT>Wtrans1d </TT>structure is set to <CODE>mw_biorthogonal</CODE>.</P><P>The function <CODE>mw_alloc_biortho_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the signals. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans1d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d Output; /* optional Output of the module */
Fsignal Signal;  /* needed Input of the module: original signal */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_biortho_wtrans1d(Output, 8, Signal-&gt;size)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;A[0][0] = Signal;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_continuous_wtrans1d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_continuous_wtrans1d(wtrans,level,voice,size,complex)</P><P>Wtrans1d wtrans;</P><P>int level; </P><P>int voice;</P><P>int size; </P><P>int complex;</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the arrays <CODE>D</CODE> of a <TT>Wtrans1d </TT>structure previously created using <CODE>mw_new_wtrans1d</CODE>, in order to receive
an continuous wavelet representation (several voices per octave, no decimation along the time axis, wavelet with complex or real values).
The arrays <CODE>DP</CODE> are allocated if <CODE>complex</CODE> is set to 1.
Each signal <CODE>D[l][v]</CODE> (and <CODE>DP[l][v]</CODE> in the complex case) for <I>l</I>=0 &#X2026; <TT>nlevel</TT>, <I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 ((<I>l</I>,<I>v</I>) &#X2260; (0,0)) is created and
allocated to the right size.
Previously allocations are deleted, if any.
Notice that, at this time, there is no function to allocate a continuous wavelet transform recording the low-pass signals (<CODE>A</CODE> and <CODE>AP</CODE>).</P><P>The number of levels for the decomposition is given by <CODE>level</CODE>, the number of voice per octave is given by <CODE>voice</CODE> and the size of the original signal is given by <CODE>size</CODE>.</P><P>The arrays <CODE>D</CODE> and <CODE>DP</CODE> can be addressed after this call, if the allocation successed. There is no default values for the signals.
The <CODE>type</CODE> field of the <TT>Wtrans1d </TT>structure is set to <CODE>mw_continuous</CODE>.</P><P>The function <CODE>mw_alloc_continuous_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the signals. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans1d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d Output; /* optional Output of the module */
Fsignal Signal;  /* needed Input of the module: original signal */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition
                        and 10 voices per octave, complex wavelet.
   */
  if(mw_alloc_continuous_wtrans1d(Output, 8, 10, Signal-&gt;size,1)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_dyadic_wtrans1d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_dyadic_wtrans1d(wtrans,level,size)</P><P>Wtrans1d wtrans;</P><P>int level; </P><P>int size; </P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the arrays <CODE>A</CODE> and <CODE>D</CODE> of a <TT>Wtrans1d </TT>structure previously created using <CODE>mw_new_wtrans1d</CODE>, in order to receive
an dyadic wavelet representation (one voice per octave, no decimation along the time axis).
Each signal <CODE>A[l][v]</CODE> and <CODE>D[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT>, <I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 ((<I>l</I>,<I>v</I>) &#X2260; (0,0)) is created and
allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original signal is given by <CODE>size</CODE>.</P><P>The arrays <CODE>A</CODE> and <CODE>D</CODE> can be addressed after this call, if the allocation successed. There is no default values for the signals.
The <CODE>type</CODE> field of the <TT>Wtrans1d </TT>structure is set to <CODE>mw_dyadic</CODE>.</P><P>The function <CODE>mw_alloc_dyadic_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the signals. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans1d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d Output; /* optional Output of the module */
Fsignal Signal;  /* needed Input of the module: original signal */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_dyadic_wtrans1d(Output, 8, Signal-&gt;size)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;A[0][0] = Signal;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_ortho_wtrans1d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_ortho_wtrans1d(wtrans,level,size)</P><P>Wtrans1d wtrans;</P><P>int level; </P><P>int size; </P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the arrays <CODE>A</CODE> and <CODE>D</CODE> of a <TT>Wtrans1d </TT>structure previously created using <CODE>mw_new_wtrans1d</CODE>, in order to receive
an orthonormal wavelet representation (one voice per octave, decimation along the time axis).
Each signal <CODE>A[l][v]</CODE> and <CODE>D[l][v]</CODE> for <I>l</I>=0 &#X2026; <TT>nlevel</TT>, <I>v</I>=0 &#X2026; <TT>nvoice</TT>&#X2212;1 ((<I>l</I>,<I>v</I>) &#X2260; (0,0)) is created and
allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original signal is given by <CODE>size</CODE>.</P><P>The arrays <CODE>A</CODE> and <CODE>D</CODE> can be addressed after this call, if the allocation successed. There is no default values for the signals.
The <CODE>type</CODE> field of the <TT>Wtrans1d </TT>structure is set to <CODE>mw_orthogonal</CODE>.</P><P>The function <CODE>mw_alloc_ortho_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the signals. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans1d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d Output; /* optional Output of the module */
Fsignal Signal;  /* needed Input of the module: original signal */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_ortho_wtrans1d(Output, 8, Signal-&gt;size)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;A[0][0] = Signal;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_wtrans1d</FONT></B> - Deallocate the wavelet transform space</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_wtrans1d(wtrans)</P><P>Wtrans1d wtrans;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the memory used by the wavelet transform space <CODE>wtrans</CODE> that is, all the memory used by the arrays of signals <CODE>A</CODE>, <CODE>AP</CODE>, <CODE>D</CODE>, <CODE>DP</CODE> (if any), and the structure itself. </P><P>You should set <CODE>wtrans = NULL</CODE> after this call since the address pointed
by <CODE>wtrans</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d wtrans=NULL; /* Internal use: no Input neither Output of module */

if  ( ((wtrans = mw_new_wtrans1d()) == NULL) ||  
       (mw_alloc_ortho_wtrans1d(wtrans, 8, 1024)==NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_wtrans1d(wtrans);
wtrans = NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_wtrans1d</FONT></B> - Create a new Wtrans1d</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wtrans1d mw_new_wtrans1d();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Wtrans1d </TT>structure with empty arrays of signals <CODE>A</CODE>, <CODE>AP</CODE>, <CODE>D</CODE>, <CODE>DP</CODE>.
No signal can be addressed at this time.
The arrays of signals should be allocated using one of the functions <CODE>mw_alloc_X_wtrans1d</CODE> where <CODE>X</CODE> depends of the type of the transformation.</P><P>You don&#X2019;t need this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). 
This function is used to create internal variables.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_wtrans1d</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans1d wtrans=NULL; /* Internal use: no Input neither Output of module */

if  ( ((wtrans = mw_new_wtrans1d()) == NULL) ||  
       (mw_alloc_continuous_wtrans1d(wtrans, 8, 10, 1024)) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><H2 CLASS="section"><A NAME="toc14"></A><A NAME="htoc51">5.2</A>&#XA0;&#XA0;Two-dimensional wavelet</H2><P><A NAME="wavelets_wtrans2d"></A></P><P>The <EM>Two-dimensional wavelet</EM><A NAME="@default66"></A> memory type is used to represent the result
of a wavelet transform applied to an image.
Notice that, at this time, the structure does not allow to record more than
one voice per octave for the decomposition.
Consequently, the continuous wavelet transform is not available in the 2D case.
The wavelet is also assumed to be of real values (complex case not supported).</P><H3 CLASS="subsection"><A NAME="htoc52">5.2.1</A>&#XA0;&#XA0;The structure Wtrans2d</H3><P>
<A NAME="wavelets_wtrans2d_structure"></A></P><P>
<A NAME="@default67"></A></P><P>The C structure is the following:
</P><PRE CLASS="verbatim">typedef struct wtrans2d {
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the wtrans2d */

  int type;  /* Type of the wtrans2d performed */
  int edges; /* Type of the edges statments */
  char filter_name[mw_namesize][mw_max_nfilter_2d];   /* Filters used */

  int nrow;
  int ncol;     /* Size of the original image */
  int nlevel;   /* Number of levels (octave) for this decomposition */
  int norient;  /* Number of orientations for this decomposition */
  int nfilter;  /* Number of filters used to compute the decomposition */

  Fimage images[mw_max_nlevel+1][mw_max_norient+1]; /* Wavelet decomposition space */

} *Wtrans2d;
</PRE><P>The first two fields of this structure is well known by the reader.
The field <CODE>type</CODE> records the type of the wavelet transform used.
Its value can be:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mw_orthogonal</CODE> : orthogonal wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_biorthogonal</CODE> : biorthogonal wavelet transform;
</LI><LI CLASS="li-itemize"><CODE>mw_dyadic</CODE> : dyadic wavelet transform.
</LI></UL><P>The field <CODE>edges</CODE> gives the type of the edges statment used to compute
the transformation. Indeed, since it is implemented as a bank of convolution
products, errors occur near the borders if no special statment is performed.
This field can have the following values:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mw_edges_zeropad</CODE> : the image is zero-padded (no special statment);
</LI><LI CLASS="li-itemize"><CODE>mw_edges_periodic</CODE> : the image is made periodic;
</LI><LI CLASS="li-itemize"><CODE>mw_edges_mirror</CODE> : the image is padded by mirror effect (avoid first-order discontinuities);
</LI><LI CLASS="li-itemize"><CODE>mw_edges_wadapted</CODE> : special border functions are added to the wavelets (wavelets on the rectangle).
</LI></UL><P>The field <CODE>filter_name</CODE> is an array of strings, where the names of the filters used for the decomposition are put. 
The number of filters is put into the field <CODE>nfilter</CODE>.
This number and the meaning of each filter depend to the wavelet type.</P><P>The fields <CODE>nrow</CODE> (number of rows) and <CODE>ncol</CODE> (number of columns) contain the size of the original image, which is put into <CODE>images[0][0]</CODE> (see below).
The field <CODE>nlevel</CODE> is the number of levels used in this decomposition; it corresponds to the number of octaves.</P><P>The field <CODE>norient</CODE> gives the number of orientations used for the decomposition;
usually (but the user may modify that) the first orientation (index <I>r</I>=0 in the array <CODE>images[][r]</CODE>) corresponds to the coarse image at the given resolution (low-pass image or smooth image);
the second orientation (index <I>r</I>=1) corresponds to the detail image (wavelet coefficients) along the y direction (horizontal details);
the third orientation (index <I>r</I>=2) corresponds to the detail image (wavelet coefficients) along the x direction (vertical details);
in the orthonormal and biorthonormal cases, there is another direction (index <I>r</I>=3) which corresponds to the detail image (wavelet coefficients) along the diagonal direction (cross details).</P><P>The result of the wavelet decomposition is put into one two-dimensional arrays of images called <CODE>images</CODE>:
<CODE>images[l][r]</CODE> for <I>l</I>=1 &#X2026; <TT>nlevel</TT> and for
<I>r</I>=0 &#X2026; <TT>norient</TT> is the coarse or the detail image at the octave <I>l</I> and at the orientation <I>r</I>.</P><P>Notice that the images <CODE>images[0][r]</CODE> are unused except for <I>r</I>=0.</P><H3 CLASS="subsection"><A NAME="htoc53">5.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="wavelets_wtrans2d-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_WTRANS2D"</CODE><A NAME="@default68"></A> MegaWave2 Data Ascii format with a <CODE>def Wtrans2d</CODE> area.
This area includes the value of the different fields of the object, as
<CODE>comments, type, edges, ...</CODE>. 
The values of the wavelet coefficients are not recorded in this file, but in 
a set of <CODE>Fimage</CODE> objects.
Let be <CODE>wavelet</CODE> the name of the object. 
The names of these image files are, for <CODE>&lt;j&gt;</CODE> the level number (octave)
and <CODE>&lt;r&gt;</CODE> the orientation number,
<UL CLASS="itemize"><LI CLASS="li-itemize"> 
<CODE>wavelet_&lt;j&gt;_S.wtrans2d</CODE> Average image of the object (<CODE>&lt;r&gt;</CODE> = 0);
</LI><LI CLASS="li-itemize"><CODE>wavelet_&lt;j&gt;_D&lt;r&gt;.wtrans2d</CODE> Detail image of the object (<CODE>&lt;r&gt;</CODE> &gt; 0).
</LI></UL>
</LI></OL><H3 CLASS="subsection"><A NAME="htoc54">5.2.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="wavelets_wtrans2d_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Wtrans2d</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_biortho_wtrans2d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_biortho_wtrans2d(wtrans,level,nrow,ncol)</P><P>Wtrans2d wtrans;</P><P>int level; </P><P>int nrow,ncol; 
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the array <CODE>images</CODE> of a <TT>Wtrans2d </TT>structure previously created using <CODE>mw_new_wtrans2d</CODE>, in order to receive
an biorthonormal wavelet representation (spatial decimation, <CODE>norient</CODE> =3).
Each image <CODE>images[l][r]</CODE> for <I>l</I>=1 &#X2026; <TT>nlevel</TT>, <I>r</I>=0 &#X2026; <TT>norient</TT> is created and allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original image is given by <CODE>nrow</CODE> (number of rows), <CODE>ncol</CODE> (number of columns).</P><P>The array <CODE>images</CODE> can be addressed after this call, if the allocation successed. There is no default values for the images.
The <CODE>type</CODE> field of the <TT>Wtrans2d </TT>structure is set to <CODE>mw_biorthogonal</CODE>.</P><P>The function <CODE>mw_alloc_biortho_wtrans2d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the images. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans2d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d Output; /* optional Output of the module */
Fimage Image;    /* needed Input of the module: original image */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_biortho_wtrans2d(Output, 8, Image-&gt;nrow, Image-&gt;ncol)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;images[0][0] = Image;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_dyadic_wtrans2d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_dyadic_wtrans2d(wtrans,level,nrow,ncol)</P><P>Wtrans2d wtrans;</P><P>int level; </P><P>int nrow,ncol; 
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the array <CODE>images</CODE> of a <TT>Wtrans2d </TT>structure previously created using <CODE>mw_new_wtrans2d</CODE>, in order to receive
an dyadic wavelet representation (no spatial decimation, <CODE>norient</CODE> =2).
Each image <CODE>images[l][r]</CODE> for <I>l</I>=1 &#X2026; <TT>nlevel</TT>, <I>r</I>=0 &#X2026; <TT>norient</TT> is created and allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original image is given by <CODE>nrow</CODE> (number of rows), <CODE>ncol</CODE> (number of columns).</P><P>The array <CODE>images</CODE> can be addressed after this call, if the allocation successed. There is no default values for the images.
The <CODE>type</CODE> field of the <TT>Wtrans2d </TT>structure is set to <CODE>mw_dyadic</CODE>.</P><P>The function <CODE>mw_alloc_dyadic_wtrans2d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the images. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans2d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d Output; /* optional Output of the module */
Fimage Image;    /* needed Input of the module: original image */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_dyadic_wtrans2d(Output, 8, Image-&gt;nrow, Image-&gt;ncol)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;images[0][0] = Image;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_ortho_wtrans2d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void *mw_alloc_ortho_wtrans2d(wtrans,level,nrow,ncol)</P><P>Wtrans2d wtrans;</P><P>int level; </P><P>int nrow,ncol; 
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the array <CODE>images</CODE> of a <TT>Wtrans2d </TT>structure previously created using <CODE>mw_new_wtrans2d</CODE>, in order to receive
an orthonormal wavelet representation (spatial decimation, <CODE>norient</CODE> =3).
Each image <CODE>images[l][r]</CODE> for <I>l</I>=1 &#X2026; <TT>nlevel</TT>, <I>r</I>=0 &#X2026; <TT>norient</TT> is created and allocated to the right size.
Previously allocations are deleted, if any.</P><P>The number of levels for the decomposition is given by <CODE>level</CODE> and the
size of the original image is given by <CODE>nrow</CODE> (number of rows), <CODE>ncol</CODE> (number of columns).</P><P>The array <CODE>images</CODE> can be addressed after this call, if the allocation successed. There is no default values for the images.
The <CODE>type</CODE> field of the <TT>Wtrans2d </TT>structure is set to <CODE>mw_orthogonal</CODE>.</P><P>The function <CODE>mw_alloc_ortho_wtrans2d</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate one of the images. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Notice that, if the wavelet transform is an output of a MegaWave2 module, the structure has been already created by the compiler if needed (see volume one: &#X201C;MegaWave2 user manual&#X201D;): do not perform additional call to <CODE>mw_new_wtrans2d</CODE> (see example below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d Output; /* optional Output of the module */
Fimage Image;    /* needed Input of the module: original image */
int J;           /* internal use */

if (Output) 
{
  /* Output requested : allocate Output for 8 levels of decomposition */
  if(mw_alloc_ortho_wtrans2d(Output, 8, Image-&gt;nrow, Image-&gt;ncol)==NULL)
    mwerror(FATAL,1,"Not enough memory.\n");
  
  Output-&gt;images[0][0] = Image;
  for (J = 1; J &lt;= 8; J++)
  {
     .
     . (Computation of the voice #J)
     .
  }
}
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_wtrans2d</FONT></B> - Deallocate the wavelet transform space</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_wtrans2d(wtrans)</P><P>Wtrans2d wtrans;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the memory used by the wavelet transform space <CODE>wtrans</CODE> that is, all the memory used by the array of images <CODE>images</CODE> (if any), and the structure itself. </P><P>You should set <CODE>wtrans = NULL</CODE> after this call since the address pointed
by <CODE>wtrans</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d wtrans=NULL; /* Internal use: no Input neither Output of module */

if  ( ((wtrans = mw_new_wtrans2d()) == NULL) ||  
       (mw_alloc_ortho_wtrans2d(wtrans, 6, 512, 512)==NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_wtrans2d(wtrans);
wtrans = NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_wtrans2d</FONT></B> - Create a new Wtrans2d</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wtrans2d mw_new_wtrans2d();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Wtrans2d </TT>structure with empty array of images <CODE>images</CODE>.
No image can be addressed at this time.
The array of images should be allocated using one of the functions <CODE>mw_alloc_X_wtrans2d</CODE> where <CODE>X</CODE> depends of the type of the transformation.</P><P>You don&#X2019;t need this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). 
This function is used to create internal variables.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_wtrans2d</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wtrans2d wtrans=NULL; /* Internal use: no Input neither Output of module */

if  ( ((wtrans = mw_new_wtrans2d()) == NULL) ||  
       (mw_alloc_dyadic_wtrans2d(wtrans, 6, 512, 512)) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><H2 CLASS="section"><A NAME="toc15"></A><A NAME="htoc55">5.3</A>&#XA0;&#XA0;Two-dimensional wavelet packets</H2><P><A NAME="wavelets_wpack2d"></A></P><P>The <EM>Two-dimensional wavelet packages</EM><A NAME="@default69"></A> memory type is used to represent the result
of a wavelet packets transform applied to a gray-levels image.
The wavelet packet basis is described by a quad-tree<A NAME="@default70"></A>
(for simplicity, we will just say a tree<A NAME="@default71"></A>) and a signal (or a pair of signals for biorthogonal wavelet packets). 
The wavelet packet transform of a <CODE>Fimage</CODE> contains the coordinates of the image in the wavelet packet basis
(if the size of this image is not a power of 2, some redundancy might be introduced).</P><H3 CLASS="subsection"><A NAME="htoc56">5.3.1</A>&#XA0;&#XA0;The structure Wpack2d</H3><P>
<A NAME="wavelets_wpack2d_structure"></A></P><P>
<A NAME="@default72"></A></P><P>The C structure is the following:
</P><PRE CLASS="verbatim">typedef struct wpack2d {
  char cmt[mw_cmtsize];    /* Comments */
  char name[mw_namesize]; /* Name of the wpack2d */

  Fsignal signal1;    /* Impulse response of the filter 'h'*/
  Fsignal signal2;    /* Imp. resp. of the dual filter, for biortho. wavelet packet*/
  int level;          /* Decomposition level (calculated) */
  Cimage tree;        /* Decomposition tree */
  Fimage *images;     /* Array for output images (containing the wavelet packet coefficients) */
 
  int img_array_size; /* Number of elements in *images */
   
  int img_ncol; /*number of colums in the image before the decomposition*/
  int img_nrow; /*number of rows in the image before the decomposition*/

  struct wpack2d *previous; /* Pointer to the previous wpack2d (may be NULL) */ 
  struct wpack2d *next;     /* Pointer to the previous wpack2d (may be NULL) */
} *Wpack2d;
</PRE><P>The fields of this structure should not be modified manually, but trough
functions of the system library only.</P><H3 CLASS="subsection"><A NAME="htoc57">5.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="wavelets_wpack2d-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_WPACK2D"</CODE><A NAME="@default73"></A> MegaWave2 Data Ascii format with a <CODE>def Wpack2d</CODE> area.
This area contains the following lines
<PRE CLASS="verbatim">    name
    comments
    signal1 file name
    signal2 file name
    tree file name
    original image number of columns
    original image number of rows
    previous Fpack file name
    next Fpack file name

    image 1 file name
    image 2 file name
    (...)
    image n file name
</PRE>Let us detail an example. We have a <CODE>Wpack2d</CODE>
named <EM>my_pack</EM> with a description &#X201D;this is my comment&#X201D;. 
It uses a signal saved in a file named <EM>da04.ir</EM> and a tree saved in a file named
<EM>wavelet1</EM>. There are 4 images in the decomposition. We have neither
previous <CODE>Wpack2d</CODE> nor next <CODE>Wpack2d</CODE>. 
The content of the corresponding <CODE>A_WPACK2D</CODE> file will be
<PRE CLASS="verbatim">%
MegaWave2 - DATA ASCII file -
%
def Wpack2d

name : my_pack
comment : this is my comment
signal1 : da04.ir
signal2 : da04.ir
tree : wavelet1
img_ncol : 512
img_nrow : 512
previous : null
next : null

my_pack0_0
my_pack1_0
my_pack0_1
my_pack1_1
</PRE></LI></OL><H3 CLASS="subsection"><A NAME="htoc58">5.3.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="wavelets_wpack2d_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Wpack2d</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_wpack2d</FONT></B> - Allocate the arrays of the decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wpack2d mw_alloc_wpack2d(pack, tree, signal1, signal2, start_nrow, start_ncol)</P><P>Wpack2d pack;</P><P>Cimage tree;</P><P>Fsignal signal1;</P><P>Fsignal signal2;</P><P>int start_nrow;</P><P>int start_ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates images array and fills fields of <CODE>pack</CODE> to fit inputs 
(tree and the signals), assuming the <CODE>pack</CODE> structure has been created with <CODE>mw_new_wpack2d</CODE> first. 
It creates images in cells that will receive wavelet packet coefficients. Other cells are filled with <TT>NULL</TT>
pointers. When modifying wavelet packet coefficients, you should check if a
cell is <TT>NULL</TT> or not before you try to use it because a <TT>NULL</TT> cell means there
should be no image there. To get an example, see module <CODE>wp2doperate.c</CODE>.</P><P>Here is the description of the different arguments :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>pack</CODE> : It provides the address of the output
<CODE>Wpack2d</CODE>, its fields <CODE>name</CODE> and <CODE>cmt</CODE> are not modified.
</LI><LI CLASS="li-itemize"><CODE>tree</CODE> : It provides the tree of the <CODE>Wpack2d</CODE>.
</LI><LI CLASS="li-itemize"><CODE>signal1</CODE> : It provides the impulse response of h filter.
</LI><LI CLASS="li-itemize"><CODE>signal2</CODE> : If not <TT>NULL</TT>, it provides the impulse response of
h filter (for bi-orthogonal wavelet packets). If <TT>NULL</TT>, <CODE>signal1</CODE> plays the role of 
h filter (this corresponds to orthogonal wavelet packets). 
</LI><LI CLASS="li-itemize"><CODE>start_nrow</CODE> : Number of columns of the image on which wavelet packet transform is computed.
</LI><LI CLASS="li-itemize"><CODE>start_ncol</CODE> : Number of rows of the image on which wavelet packet transform is computed.
</LI></UL><P>The function returns <TT>NULL</TT> if not enough memory is available to allocate one of the fields. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack=NULL; /* Internal use: no Input neither Output of module */

if (!(pack=mw_new_wpack2d()) ||
!(mw_alloc_wpack2d(pack, tree, Ri, Ri_biortho, A-&gt;nrow, A-&gt;ncol)))
   mwerror(FATAL,-1,"Not enough memory\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_wpack2d</FONT></B> - Changes the memory allocation of a Wpack2d</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wpack2d mw_change_wpack2d(pack, tree, signal1, signal2, start_nrow, start_ncol)</P><P>Wpack2d pack;</P><P>Cimage tree;</P><P>Fsignal signal1;</P><P>Fsignal signal2;</P><P>int start_nrow;</P><P>int start_ncol;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
</P><P>This function is made to change the memory allocation of a <EM>Wpack2d</EM>.
It changes the tree, the impulse responses and the allocation of 
images fields according to the input values. </P><P>The structure address is not changed (if not <TT>NULL</TT>) and both name and
comments are kept. Any pointer on the structure will still be usable.</P><P>Here is the description of the different arguments :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>pack</CODE> : If not <TT>NULL</TT>, it provides the address of the output
<CODE>Wpack2d</CODE>, its fields <CODE>name</CODE> and <CODE>cmt</CODE> are not modified. 
If <TT>NULL</TT> a new <CODE>Wpack2d</CODE> is created and memory is allocated.
</LI><LI CLASS="li-itemize"><CODE>tree</CODE> : It provides the tree of the <CODE>Wpack2d</CODE>.
</LI><LI CLASS="li-itemize"><CODE>signal1</CODE> : It provides the impulse response of the h filter.
</LI><LI CLASS="li-itemize"><CODE>signal2</CODE> : If not <TT>NULL</TT>, it provides the impulse response of
h filter (for bi-orthogonal wavelet packets). If <TT>NULL</TT>, <CODE>signal1</CODE>
plays the role of h (this corresponds to orthogonal wavelet packets). 
</LI><LI CLASS="li-itemize"><CODE>start_nrow</CODE> : Number of columns of the image on which wavelet packet transform is computed.
</LI><LI CLASS="li-itemize"><CODE>start_ncol</CODE> : Number of rows of the image on which wavelet packet transform is computed.
</LI></UL><P>The function returns <TT>NULL</TT> if not enough memory is available to allocate one of the fields. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack;
Cimage tree;
Fsignal h,htilde;
Fimage A;

/* Usage when &lt;pack&gt; IS NOT an output of the module(and has not been
   previously allocated): the function returns a new structure's address
*/
pack=mw_change_wpack2d(NULL, tree, h, htilde, A-&gt;nrow,A-&gt;ncol);

/* Usage when &lt;pack&gt; IS an output of the module (or has been previously
   allocated): DO NOT change the structure's address
*/
pack=mw_change_wpack2d(pack, tree, h, htilde, A-&gt;nrow,A-&gt;ncol);

if(!pack) mwerror(FATAL, 1, "Not enough memory.\n")

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_checktree_wpack2d</FONT></B> - Check a quad-tree</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
int mw_checktree_wpack2d(tree)</P><P>Cimage tree;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
</P><P>This function checks if the input image <CODE>tree</CODE> can be considered
as a tree (quad-tree) for a wavelet packet decomposition.
If the image is a tree, the function returns its maximum level of decomposition.
If not, a fatal error is generated and a corresponding error message is issued.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack;
Cimage tree; /* input image (must be previously filled) */

pack= mw_new_wpack2d();
if (!pack) mwerror(FATAL,1,"Not enough memory.\n");
  
/* Checks tree and computes the maximum decomposition level */   
pack-&gt;level = mw_checktree_wpack2d(tree);

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_wpack2d</FONT></B> - Clear all wavelet packet coefficients</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_wpack2d(pack,v)</P><P>Wpack2d pack;</P><P>float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function clears all wavelet packet coefficients of <CODE>pack</CODE>
by uniformly setting the value <CODE>v</CODE> in all images (most of time you will 
use <I>v</I>=0).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack; /* Input pack (previously filled) */

 /* Clear all wavelet packet coefficients in &lt;pack&gt; */
 mw_clear_wpack2d(pack, 0.0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_wpack2d</FONT></B> - Copy a wavelet packet decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_wpack2d(in,out,new_tree_size)</P><P>Wpack2d in;</P><P>Wpack2d out;</P><P>int new_tree_size;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the wavelet packet <CODE>in</CODE> into another <CODE>out</CODE>,
by copying wavelet packet coefficients and other fields so that <CODE>out</CODE> contains
a valid wavelet packet decomposition which corresponds to the decomposition of
the same image in the same basis.</P><P>The structure <CODE>out</CODE> must have been created using <CODE>mw_new_wpack2d</CODE> before
the copy, but <CODE>mw_copy_wpack2d</CODE> will make any required size modification or allocation.</P><P>Here is the description of the different arguments :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>in</CODE> : Input <CODE>Wpack2d</CODE>. It must contain a wavelet packet decomposition. 
</LI><LI CLASS="li-itemize"><CODE>out</CODE> : Ouput <CODE>Wpack2d</CODE>, with a valid address.
</LI><LI CLASS="li-itemize"><CODE>new_tree_size</CODE> : 
<UL CLASS="itemize"><LI CLASS="li-itemize">
If <CODE>new_tree_size</CODE> is smaller than <CODE>in-&gt;tree-&gt;ncol</CODE>, <CODE>in</CODE> is
just copied into <CODE>out</CODE>.
</LI><LI CLASS="li-itemize">if <CODE>new_tree_size</CODE> is larger than <CODE>in-&gt;tree-&gt;ncol</CODE>, <CODE>new_tree_size</CODE>
must be a power of 2. In this case, <CODE>out</CODE> corresponds to
the same wavelet packet decomposition as <CODE>in</CODE>, BUT <CODE>out-&gt;tree-&gt;ncol</CODE>
equals <CODE>new_tree_size</CODE>. Of course, <CODE>out</CODE> is correct : all the modifications
requested by this size change are performed. For an exemple, see 
module <CODE>wp2dchangepack</CODE>.
</LI></UL>
</LI></UL><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d old_pack; /* Input pack (previously filled) */
Wpack2d pack;

 pack=mw_new_wpack2d();
 if (!pack) mwerror(FATAL,-1,"Not enough memory\n");
 mw_copy_wpack2d(old_pack,pack,0);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_wpack2d</FONT></B> - Delete a wavelet packet decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_wpack2d(pack)</P><P>Wpack2d pack;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
<CODE>mw_delete_wpack2d</CODE> releases all the memory previously
allocated for the <CODE>Wpack2d</CODE>. Notice that all substructures
like images and signals are also freed.</P><P>The behavior of <CODE>previous</CODE> and <CODE>next</CODE> fields needs to be
explained. To help user to manage <CODE>Wpack2d</CODE> movies,
<CODE>mw_delete_wpack2d</CODE> keeps consistency in the <CODE>Wpack2d</CODE> movie.
If four <CODE>Wpack2d</CODE> are linked this way 
</P><PRE CLASS="verbatim">  A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D
</PRE><P>and if <CODE>mw_delete_wpack2d</CODE> is used to delete C, one obtains : 
</P><PRE CLASS="verbatim">  A &lt;-&gt; B &lt;-&gt; D
</PRE><P>After a call to <CODE>mw_delete_wpack2d</CODE> any access to the deleted
<CODE>Wpack2d</CODE> will cause unpredictable errors. You should set the
deleted <CODE>Wpack2d</CODE> to <TT>NULL</TT>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack; /* Previously allocated wavelet packet */

mw_delete_wpack2d(pack);
pack=NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_wpack2d</FONT></B> - Create a new Wpack2d</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Wpack2d mw_new_wpack2d();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Wpack2d </TT>structure with empty image array
(every fields are set to default). Image array and other fields directly
related to decomposition still need to be allocated using
<CODE>mw_alloc_wpack2d</CODE>, before they can be used.</P><P>You don&#X2019;t need this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). 
This function is used to create internal variables.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_wpack2d</CODE> returns <TT>NULL</TT> if not enough memory is available 
to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack=NULL; /* Internal use: no Input neither Output of module */

if (!(pack=mw_new_wpack2d()) ||
!(mw_alloc_wpack2d(pack, tree, Ri, Ri_biortho, A-&gt;nrow, A-&gt;ncol)))
   mwerror(FATAL,-1,"Not enough memory\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_prune_wpack2d</FONT></B> - Prune the tree of a wavelet packet decomposition</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_prune_wpack2d(in, out, tree)</P><P>Wpack2d in;</P><P>Wpack2d out;</P><P>Cimage tree;
</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function should only be called when the wavelet packet decomposition
contained in <CODE>in</CODE> corresponds to the tree defined by <CODE>tree</CODE>, but is coded
by a <CODE>Cimage</CODE> whose size is larger than the size of <CODE>tree</CODE>, 
such as in the case where the <CODE>Cimage</CODE> <CODE>in-&gt;tree</CODE> describes the same quad-tree 
than <CODE>tree</CODE>.</P><P>In such a case, if <CODE>tree-&gt;ncol</CODE> is smaller than <CODE>in-&gt;tree-&gt;ncol</CODE>, the
output corresponds to the same wavelet packet decomposition as <CODE>in</CODE> but
<CODE>out-&gt;tree</CODE> contains <CODE>tree</CODE>. The <CODE>Wpack2d</CODE> <CODE>out</CODE> is correct :
all the modifications requested by this size change are performed. 
For an example, see module <CODE>wp2dchangepack</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Wpack2d pack1;
Wpack2d pack2;
Cimage tree1;
Cimage tree2;

mw_copy_wpack2d(pack1,pack2,tree2-&gt;ncol);
mw_prune_wpack2d(pack2,pack1,tree1);
</PRE><HR>
<A HREF="system_manual005.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual007.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
</BODY>
</HTML>
