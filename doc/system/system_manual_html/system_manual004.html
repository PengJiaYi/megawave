<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="system_manual.css">
<TITLE>Movies</TITLE>
</HEAD>
<BODY >
<A HREF="system_manual003.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual005.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc24">Chapter&#XA0;3</A>&#XA0;&#XA0;Movies</H1><UL>
<LI><A HREF="system_manual004.html#toc8">Char movies</A>
</LI><LI><A HREF="system_manual004.html#toc9">Color Char movies</A>
</LI><LI><A HREF="system_manual004.html#toc10">Float movies</A>
</LI><LI><A HREF="system_manual004.html#toc11">Color Float movies</A>
</LI></UL>
<P>
<A NAME="movies"></A>
</P><P>A movie<A NAME="@default42"></A> is a succession of images. In MegaWave2, it is implemented as a
chain of images: you may notice that all types of images have the 
fields <CODE>previous</CODE> and <CODE>next</CODE>(see section&#XA0;<A HREF="system_manual003.html#images">2</A>). 
Normally set to <TT>NULL</TT>, these fields point to the previous image and
to the next image respectively, when the image is part of a movie.
The first image of the movie has a <TT>NULL</TT><CODE>previous</CODE> field and the
last image of the movie has a <TT>NULL</TT><CODE>next</CODE> field.</P><P>A movie structure is basically a pointer to the first image.
For each image structure corresponds a movie structure.</P><H2 CLASS="section"><A NAME="toc8"></A><A NAME="htoc25">3.1</A>&#XA0;&#XA0;Char movies</H2><P><A NAME="movies_char-movies"></A>

<A NAME="@default43"></A></P><P>The <EM>Char Movie</EM> memory type corresponds to movies where each images
are of the <TT>Cimage </TT>memory type. 
The use of this memory type is strongly recommended, since other movies types
waste a lot of memory and computational time.</P><H3 CLASS="subsection"><A NAME="htoc26">3.1.1</A>&#XA0;&#XA0;The structure Cmovie</H3><P>
<A NAME="movies_char-movies_structure"></A></P><P>Beginners should only focus on the field <CODE>first</CODE> of this structure:
if <CODE>movie</CODE> is of <TT>Cmovie </TT>type, then <CODE>movie-&gt;first</CODE> is of <TT>Cimage </TT>type and it is the first image of the movie; <CODE>movie-&gt;first-&gt;next</CODE> is
the second image, etc.</P><PRE CLASS="verbatim">typedef struct cmovie {
  float scale;     /* Scale (time-domain) of the movie (should be 1) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  Cimage first;    /* Pointer to the first image */
} *Cmovie;
</PRE><H3 CLASS="subsection"><A NAME="htoc27">3.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="movies_char-file_type"></A></P><P>The way MegaWave2 records movies is the following:
each image is recorded in a separate file, using one of the external types available for the corresponding type Cimage (see section&#XA0;<A HREF="system_manual003.html#images_char-file_type">2.1.2</A> for more information).
Let suppose that the external name of the movie object is <CODE>movie</CODE>.
Then, MegaWave2 creates a MegaWave2 Data Ascii file named <CODE>movie</CODE> with a <CODE>def Cmovie</CODE> area.
In this area is listed the name of the image files, following the order given by the sequence of images.
By changing the order of two file names, you change the order of the images in the sequence (i.e. the name of
the file is not meaningful by itself, for example the image file name <CODE>movie_002</CODE> may not be the second
image of the sequence).
There is no limitation for the number of images, up to the available memory.</P><P>Note: there is an old format, which is still recognized for backward compatibility. 
Is this old format, the file name <CODE>movie</CODE> is empty and the name of each image file is meaningful
(e.g. <CODE>movie_002</CODE> is always the second image of the sequence).
In that case, no more than 999 images per movie can be recorded.</P><H3 CLASS="subsection"><A NAME="htoc28">3.1.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="movies_char-movies_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Cmovie</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_cmovie</FONT></B> - Define the movie structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cmovie mw_change_cmovie(movie)</P><P>Cmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a movie structure if the input <CODE>movie = NULL</CODE>.
It is provided despite the <CODE>mw_new_cmovie</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_cmovie</CODE> returns <TT>NULL</TT> if not enough memory is available to define the structure. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cmovie movie=NULL; /* Internal use: no Input neither Output of module */

movie = mw_change_cmovie(movie);
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_cmovie</CODE> function).
</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_cmovie</FONT></B> - Deallocate all the movie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_cmovie(movie)</P><P>Cmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory used by a <TT>Cmovie </TT>structure:
it deallocates the gray plane of all images, the image structures and
the movie structure itself.</P><P>You should set <CODE>movie = NULL</CODE> after this call since the address pointed
by <CODE>movie</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the <CODE>mw_new_cmovie</CODE> function: when a memory allocation
fails for <CODE>mw_change_cimage</CODE>, all the previously memory allocations are
freed by the call to <CODE>mw_delete_cmovie(movie)</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_cmovie</FONT></B> - Create a new Cmovie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cmovie mw_new_cmovie();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Cmovie </TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Create a movie with 10 images of size (100,100) */

Cmovie movie;  /* Internal use: no Input neither Output of module */
Cimage image,image_prev; /* Internal use */

movie = mw_new_cmovie();
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
for (l=1;l&lt;=10;l++)
 {
   if ((image = mw_change_cimage(NULL,100,100)) == NULL)
    {
      mw_delete_cmovie(movie);
      mwerror(FATAL,1,"Not enough memory.");
    }
    if (l == 1) movie-&gt;first = image;
    else
      {
        image_prev-&gt;next = image;
        image-&gt;previous = image_prev;
       }
     image_prev = image;
 }
</PRE><H2 CLASS="section"><A NAME="toc9"></A><A NAME="htoc29">3.2</A>&#XA0;&#XA0;Color Char movies</H2><P><A NAME="movies_color-char-movies"></A>

<A NAME="@default44"></A></P><P>The <EM>Color Char Movie</EM> memory type corresponds to movies where each images
are of the <TT>Ccimage </TT>memory type. 
Use this memory type each time you have to process color movies.
As in the Char Movies case, the use of this format instead of the corresponding floating point format (<CODE>Cfmovie</CODE>) is strongly recommended.</P><H3 CLASS="subsection"><A NAME="htoc30">3.2.1</A>&#XA0;&#XA0;The structure Ccmovie</H3><P>
<A NAME="movies_color-char-movies_structure"></A></P><P>Beginners should focus on the field <CODE>first</CODE> only of this structure:
if <CODE>movie</CODE> is of <TT>Ccmovie </TT>type, then <CODE>movie-&gt;first</CODE> is of <TT>Ccimage </TT>type and it is the first image of the movie; <CODE>movie-&gt;first-&gt;next</CODE> is
the second image, etc.</P><PRE CLASS="verbatim">typedef struct ccmovie {
  float scale;     /* Scale (time-domain) of the movie (should be 1) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  Ccimage first;    /* Pointer to the first image */
} *Ccmovie;
</PRE><H3 CLASS="subsection"><A NAME="htoc31">3.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="movies_color-char-file_type"></A></P><P>The way MegaWave2 records movies is the following:
each image is recorded in a separate file, using one of the external types available for the corresponding type Ccimage (see section&#XA0;<A HREF="system_manual003.html#images_color-file_type">2.2.2</A> for more information).
Let suppose that the external name of the movie object is <CODE>movie</CODE>.
Then, MegaWave2 creates a MegaWave2 Data Ascii file named <CODE>movie</CODE> with a <CODE>def CCmovie</CODE> area.
In this area is listed the name of the image files, following the order given by the sequence of images.
By changing the order of two file names, you change the order of the images in the sequence (i.e. the name of
the file is not meaningful by itself, for example the image file name <CODE>movie_002</CODE> may not be the second
image of the sequence).
There is no limitation for the number of images, up to the available memory.</P><P>Note: there is an old format, which is still recognized for backward compatibility. 
Is this old format, the file name <CODE>movie</CODE> is empty and the name of each image file is meaningful
(e.g. <CODE>movie_002</CODE> is always the second image of the sequence).
In that case, no more than 999 images per movie can be recorded.</P><H3 CLASS="subsection"><A NAME="htoc32">3.2.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="movies_color-char-movies_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Ccmovie</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_ccmovie</FONT></B> - Define the movie structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccmovie mw_change_ccmovie(movie)</P><P>Ccmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a movie structure if the input <CODE>movie = NULL</CODE>.
It is provided despite the <CODE>mw_new_ccmovie</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_ccmovie</CODE> returns <TT>NULL</TT> if not enough memory is available to define the structure. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Ccmovie movie=NULL; /* Internal use: no Input neither Output of module */

movie = mw_change_ccmovie(movie);
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_ccmovie</CODE> function).
</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_ccmovie</FONT></B> - Deallocate all the movie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_ccmovie(movie)</P><P>Ccmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory used by a <TT>Ccmovie </TT>structure:
it deallocates the color planes of all images, the image structures and
the movie structure itself.</P><P>You should set <CODE>movie = NULL</CODE> after this call since the address pointed
by <CODE>movie</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the <CODE>mw_new_ccmovie</CODE> function: when a memory allocation
fails for <CODE>mw_change_ccimage</CODE>, all the previously memory allocations are
freed by the call to <CODE>mw_delete_ccmovie(movie)</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_ccmovie</FONT></B> - Create a new Ccmovie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Ccmovie mw_new_ccmovie();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Ccmovie </TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Create a movie with 10 images of size (100,100) */

Ccmovie movie;  /* Internal use: no Input neither Output of module */
Ccimage image,image_prev; /* Internal use */

movie = mw_new_ccmovie();
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
for (l=1;l&lt;=10;l++)
 {
   if ((image = mw_change_ccimage(NULL,100,100)) == NULL)
    {
      mw_delete_ccmovie(movie);
      mwerror(FATAL,1,"Not enough memory.");
    }
    if (l == 1) movie-&gt;first = image;
    else
      {
        image_prev-&gt;next = image;
        image-&gt;previous = image_prev;
       }
     image_prev = image;
 }
</PRE><H2 CLASS="section"><A NAME="toc10"></A><A NAME="htoc33">3.3</A>&#XA0;&#XA0;Float movies</H2><P><A NAME="movies_float-movies"></A>

<A NAME="@default45"></A></P><P>The <EM>Float Movie</EM> memory type corresponds to movies where each images
are of the <TT>Fimage </TT>memory type. 
The use of this memory type is discouraged, since it wastes a lot of memory and computational time.
Use it when you must process data using floating point arithmetic, and when 
you cannot lose precision by converting the output to integer values.</P><H3 CLASS="subsection"><A NAME="htoc34">3.3.1</A>&#XA0;&#XA0;The structure Fmovie</H3><P>
<A NAME="movies_float-movies_structure"></A></P><P>Beginners should focus on the field <CODE>first</CODE> only of this structure:
if <CODE>movie</CODE> is of <TT>Fmovie </TT>type, then <CODE>movie-&gt;first</CODE> is of <TT>Fimage </TT>type and it is the first image of the movie; <CODE>movie-&gt;first-&gt;next</CODE> is
the second image, etc.</P><PRE CLASS="verbatim">typedef struct fmovie {
  float scale;     /* Scale (time-domain) of the movie (should be 1) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  Fimage first;    /* Pointer to the first image */
} *Fmovie;
</PRE><H3 CLASS="subsection"><A NAME="htoc35">3.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="movies_float-file_type"></A></P><P>The way MegaWave2 records movies is the following:
each image is recorded in a separate file, using one of the external types available for the corresponding type Fimage (see section&#XA0;<A HREF="system_manual003.html#images_float-file_type">2.3.2</A> for more information).
Let suppose that the external name of the movie object is <CODE>movie</CODE>.
Then, MegaWave2 creates a MegaWave2 Data Ascii file named <CODE>movie</CODE> with a <CODE>def Fmovie</CODE> area.
In this area is listed the name of the image files, following the order given by the sequence of images.
By changing the order of two file names, you change the order of the images in the sequence (i.e. the name of
the file is not meaningful by itself, for example the image file name <CODE>movie_002</CODE> may not be the second
image of the sequence).
There is no limitation for the number of images, up to the available memory.</P><P>Note: there is an old format, which is still recognized for backward compatibility. 
Is this old format, the file name <CODE>movie</CODE> is empty and the name of each image file is meaningful
(e.g. <CODE>movie_002</CODE> is always the second image of the sequence).
In that case, no more than 999 images per movie can be recorded.</P><H3 CLASS="subsection"><A NAME="htoc36">3.3.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="movies_float-movies_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Fmovie</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_fmovie</FONT></B> - Define the movie structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fmovie mw_change_fmovie(movie)</P><P>Fmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a movie structure if the input <CODE>movie = NULL</CODE>.
It is provided despite the <CODE>mw_new_fmovie</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_fmovie</CODE> returns <TT>NULL</TT> if not enough memory is available to define the structure. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Fmovie movie=NULL; /* Internal use: no Input neither Output of module */

movie = mw_change_fmovie(movie);
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_fmovie</CODE> function).
</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_fmovie</FONT></B> - Deallocate all the movie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_fmovie(movie)</P><P>Fmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory used by a <TT>Fmovie </TT>structure:
it deallocates the gray plane of all images, the image structures and
the movie structure itself.</P><P>You should set <CODE>movie = NULL</CODE> after this call since the address pointed
by <CODE>movie</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the <CODE>mw_new_fmovie</CODE> function: when a memory allocation
fails for <CODE>mw_change_fimage</CODE>, all the previously memory allocations are
freed by the call to <CODE>mw_delete_fmovie(movie)</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_fmovie</FONT></B> - Create a new Fmovie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Fmovie mw_new_fmovie();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Fmovie </TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Create a movie with 10 images of size (100,100) */

Fmovie movie;  /* Internal use: no Input neither Output of module */
Fimage image,image_prev; /* Internal use */

movie = mw_new_fmovie();
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
for (l=1;l&lt;=10;l++)
 {
   if ((image = mw_change_fimage(NULL,100,100)) == NULL)
    {
      mw_delete_fmovie(movie);
      mwerror(FATAL,1,"Not enough memory.");
    }
    if (l == 1) movie-&gt;first = image;
    else
      {
        image_prev-&gt;next = image;
        image-&gt;previous = image_prev;
       }
     image_prev = image;
 }
</PRE><H2 CLASS="section"><A NAME="toc11"></A><A NAME="htoc37">3.4</A>&#XA0;&#XA0;Color Float movies</H2><P><A NAME="movies_color-float-movies"></A>

<A NAME="@default46"></A></P><P>The <EM>Color Float Movie</EM> memory type corresponds to movies where each images are of the <TT>Cfimage </TT>memory type. 
The use of this memory type is discouraged, since it wastes a lot of memory and computational time.
Use it when you must process data using floating point arithmetic, and when 
you cannot lose precision by converting the output to integer values.</P><H3 CLASS="subsection"><A NAME="htoc38">3.4.1</A>&#XA0;&#XA0;The structure Cfmovie</H3><P>
<A NAME="movies_color-float-movies_structure"></A></P><P>Beginners should focus on the field <CODE>first</CODE> only of this structure:
if <CODE>movie</CODE> is of <TT>Cfmovie </TT>type, then <CODE>movie-&gt;first</CODE> is of <TT>Cfimage </TT>type and it is the first image of the movie; <CODE>movie-&gt;first-&gt;next</CODE> is
the second image, etc.</P><PRE CLASS="verbatim">typedef struct cfmovie {
  float scale;     /* Scale (time-domain) of the movie (should be 1) */
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the image */
  Cfimage first;    /* Pointer to the first image */
} *Cfmovie;
</PRE><H3 CLASS="subsection"><A NAME="htoc39">3.4.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="movies_color-float-file_type"></A></P><P>The way MegaWave2 records movies is the following:
each image is recorded in a separate file, using one of the external types available for the corresponding type Cfimage (see section&#XA0;<A HREF="system_manual003.html#images_color-float-file_type">2.4.2</A> for more information).
Let suppose that the external name of the movie object is <CODE>movie</CODE>.
Then, MegaWave2 creates a MegaWave2 Data Ascii file named <CODE>movie</CODE> with a <CODE>def Cfmovie</CODE> area.
In this area is listed the name of the image files, following the order given by the sequence of images.
By changing the order of two file names, you change the order of the images in the sequence (i.e. the name of
the file is not meaningful by itself, for example the image file name <CODE>movie_002</CODE> may not be the second
image of the sequence).
There is no limitation for the number of images, up to the available memory.</P><P>Note: there is an old format, which is still recognized for backward compatibility. 
Is this old format, the file name <CODE>movie</CODE> is empty and the name of each image file is meaningful
(e.g. <CODE>movie_002</CODE> is always the second image of the sequence).
In that case, no more than 999 images per movie can be recorded.</P><H3 CLASS="subsection"><A NAME="htoc40">3.4.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="movies_color-float-movies_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Cfmovie</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_cfmovie</FONT></B> - Define the movie structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfmovie mw_change_cfmovie(movie)</P><P>Cfmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a movie structure if the input <CODE>movie = NULL</CODE>.
It is provided despite the <CODE>mw_new_cfmovie</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_cfmovie</CODE> returns <TT>NULL</TT> if not enough memory is available to define the structure. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Cfmovie movie=NULL; /* Internal use: no Input neither Output of module */

movie = mw_change_cfmovie(movie);
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_cfmovie</CODE> function).
</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_cfmovie</FONT></B> - Deallocate all the movie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_cfmovie(movie)</P><P>Cfmovie movie;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory used by a <TT>Cfmovie </TT>structure:
it deallocates the color planes of all images, the image structures and
the movie structure itself.</P><P>You should set <CODE>movie = NULL</CODE> after this call since the address pointed
by <CODE>movie</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the <CODE>mw_new_cfmovie</CODE> function: when a memory allocation
fails for <CODE>mw_change_cfimage</CODE>, all the previously memory allocations are
freed by the call to <CODE>mw_delete_cfmovie(movie)</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_cfmovie</FONT></B> - Create a new Cfmovie</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Cfmovie mw_new_cfmovie();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Cfmovie </TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>Images have to be allocated using the appropriate functions (See the example
below).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Create a movie with 10 images of size (100,100) */

Cfmovie movie;  /* Internal use: no Input neither Output of module */
Cfimage image,image_prev; /* Internal use */

movie = mw_new_cfmovie();
if (movie == NULL) mwerror(FATAL,1,"Not enough memory.\n");
for (l=1;l&lt;=10;l++)
 {
   if ((image = mw_change_cfimage(NULL,100,100)) == NULL)
    {
      mw_delete_cfmovie(movie);
      mwerror(FATAL,1,"Not enough memory.");
    }
    if (l == 1) movie-&gt;first = image;
    else
      {
        image_prev-&gt;next = image;
        image-&gt;previous = image_prev;
       }
     image_prev = image;
 }
</PRE><HR>
<A HREF="system_manual003.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual005.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
</BODY>
</HTML>
