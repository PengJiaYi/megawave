<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="system_manual.css">
<TITLE>Unstructured material or raw data</TITLE>
</HEAD>
<BODY >
<A HREF="system_manual008.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual010.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc127">Chapter&#XA0;8</A>&#XA0;&#XA0;Unstructured material or raw data</H1><UL>
<LI><A HREF="system_manual009.html#toc32">The structure Rawdata</A>
</LI><LI><A HREF="system_manual009.html#toc33">Related file (external) types</A>
</LI><LI><A HREF="system_manual009.html#toc34">Functions Summary</A>
</LI></UL>
<P>
<A NAME="rawdata"></A>
</P><P>When none of the previous structures matches your need, or when you want to
write or to read files in a format which is not recognized by MegaWave2, use
the raw data<A NAME="@default143"></A> type : this internal type allows you to load/save 
any kind of data from/to disk.</P><H2 CLASS="section"><A NAME="toc32"></A><A NAME="htoc128">8.1</A>&#XA0;&#XA0;The structure Rawdata</H2><P>
<A NAME="@default144"></A>
<A NAME="rawdata_structure"></A></P><P>The <TT>Rawdata</TT> structure is nothing else than an array of bytes (<CODE>data</CODE> field). The
size of the array is set in the <CODE>size</CODE> field.</P><PRE CLASS="verbatim">typedef struct rawdata {
  int size;               /* Number of samples */
  unsigned char *data;    /* data field */
} *Rawdata;
</PRE><H2 CLASS="section"><A NAME="toc33"></A><A NAME="htoc129">8.2</A>&#XA0;&#XA0;Related file (external) types</H2><P>
<A NAME="rawdata-file_type"></A></P><P>There is no file types associated to the <TT>Rawdata</TT> structure : when the content of a <TT>Rawdata</TT> 
variable is written into a file, the content of the file is exactly the content of the <CODE>data</CODE>
field. There is no header added. Consequently, file of any format can be loaded into a <TT>Rawdata</TT>
variable. If this file contains a header (as most of MegaWave2 file formats), the header will
be loaded into the <CODE>data</CODE> field together with the data themselves.
Of course, there cannot be any conversion format associated to <TT>Rawdata</TT>.</P><H2 CLASS="section"><A NAME="toc34"></A><A NAME="htoc130">8.3</A>&#XA0;&#XA0;Functions Summary</H2><P>
<A NAME="rawdata_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Rawdata</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_rawdata</FONT></B> - Allocate the data array of a <TT>Rawdata</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Rawdata mw_alloc_rawdata(rd,size)</P><P>Rawdata rd;</P><P>int size;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the <CODE>data</CODE> array of a <TT>Rawdata</TT>structure previously created using <CODE>mw_new_rawdata</CODE>. The size of the data is given by 
<CODE>size</CODE>, it corresponds to the number of bytes.</P><P>Values can be addressed after this call, if the allocation successed. There is
no default values.</P><P>Do not use this function if <CODE>rd</CODE> has already an allocated array: use
the function <CODE>mw_change_rawdata</CODE> instead.</P><P>The function <CODE>mw_alloc_rawdata</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the array. Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Rawdata rd=NULL; /* Internal use: no Input neither Output of module */
int i;

/* Create a rawdata of 1000 bytes */
if  ( ((rd = mw_new_rawdata()) == NULL) ||
      (mw_alloc_rawdata(rd,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");

/* Set the byte #i to the value i mod 256 */
for (i=0;i&lt;rd-&gt;size;i++) rd-&gt;data[i] = i % 256;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_rawdata</FONT></B> - Change the size of the data array of a <TT>Rawdata</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Rawdata mw_change_rawdata(rd, newsize)</P><P>Rawdata rd;</P><P>int newsize;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the <CODE>data</CODE> array of a <TT>Rawdata</TT> structure, even if no previously memory allocation was done.
The new size of the array is given by <CODE>newsize</CODE>, it corresponds to the number 
of allocated bytes.</P><P>The function <CODE>mw_change_rawdata</CODE> can also create the structure if the input <CODE>rd = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_rawdata</CODE> and
<CODE>mw_alloc_rawdata</CODE>. It is the recommended function to allocate <TT>Rawdata</TT> variables
used as input/output of modules. Since the function can set the 
address of <CODE>rd</CODE>, the variable must be set to the return value of 
the function (See example below).</P><P>The function <CODE>mw_change_rawdata</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the array. 
Your code should check this return value to 
send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Rawdata Output; /* Output of module */

/* Set the size of the array to be 1000 bytes */
Output = mw_change_rawdata(Output, 1000);
if (Output == NULL) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_rawdata</FONT></B> - Copy the data of a <TT>Rawdata</TT>+ structure into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_copy_rawdata(in, out)</P><P>Rawdata in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the content of the array <CODE>data</CODE> of the <TT>Rawdata</TT>+ structure <CODE>in</CODE> into the array <CODE>data</CODE> of <CODE>out</CODE>.
The variable <CODE>out</CODE> must be an allocated <TT>Rawdata</TT> structure of same
size than <CODE>in</CODE>.</P><P>The speed of this function depends to the C library implementation, but it is
usually very fast (trying to do faster is a waste of time).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Rawdata G; /* Needed Input */
Rawdata F; /* Optional Output */

  if (F) {
    printf("F option is active: copy G in F\n");
    if ((F = mw_change_rawdata(F, G-&gt;size)) == NULL)
        mwerror(FATAL,1,"Not enough memory.\n");
    else mw_copy_rawdata(G, F);
   }
  else  printf("F option is not active\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_rawdata</FONT></B> - Deallocate the data array of a <TT>Rawdata</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_rawdata(rd)</P><P>Rawdata rd;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the array <CODE>values</CODE> of a <TT>Rawdata</TT> structure previously allocated using<BR>
 <CODE>mw_alloc_rawdata</CODE> or <CODE>mw_change_rawdata</CODE>, and the structure itself. </P><P>You should set <CODE>rd = NULL</CODE> after this call since the address pointed
by <CODE>rd</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Rawdata rd=NULL; /* Internal use: no Input neither Output of module */

if  ( ((rd = mw_new_rawdata()) == NULL) ||
      (mw_alloc_rawdata(rd,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
/* .
   .
   (statement)
   .
   .
*/
mw_delete_rawdata(rd);
rd = NULL;

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_rawdata</FONT></B> - Create a new <TT>Rawdata</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Rawdata mw_new_rawdata();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Rawdata</TT> structure with an empty <CODE>data</CODE> array and
<CODE>size</CODE> field set to 0.
No data can be addressed at this time.
The <CODE>data</CODE> should be allocated using the function <CODE>mw_alloc_rawdata</CODE> or <CODE>mw_change_rawdata</CODE>.</P><P>Do not use this function for input/output of modules, since the MegaWave2
Compiler already created the structure for you if you need it (see volume one: &#X201C;MegaWave2 user manual&#X201D;). Use instead the function <CODE>mw_change_rawdata</CODE>.
Do not forget to deallocate the internal structures before the end
of the module.</P><P>The function <CODE>mw_new_rawdata</CODE> returns <TT>NULL</TT> if not enough memory is available to create the structure. Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Rawdata rd=NULL; /* Internal use: no Input neither Output of module */

if  ( ((rd = mw_new_rawdata()) == NULL) ||
      (mw_alloc_rawdata(rd,1000) == NULL) )
    mwerror(FATAL,1,"Not enough memory.\n");
</PRE><HR>
<A HREF="system_manual008.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual010.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
</BODY>
</HTML>
