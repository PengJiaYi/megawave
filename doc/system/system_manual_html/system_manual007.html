<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="system_manual.css">
<TITLE>Geometrical structures : Point, Curves, Polygons and Lists</TITLE>
</HEAD>
<BODY >
<A HREF="system_manual006.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual008.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc59">Chapter&#XA0;6</A>&#XA0;&#XA0;Geometrical structures : Point, Curves, Polygons and Lists</H1><UL>
<LI><A HREF="system_manual007.html#toc16">Point of a planar curve</A>
</LI><LI><A HREF="system_manual007.html#toc17">Planar curve</A>
</LI><LI><A HREF="system_manual007.html#toc18">Set of planar curves</A>
</LI><LI><A HREF="system_manual007.html#toc19">Polygon, a variant of curve</A>
</LI><LI><A HREF="system_manual007.html#toc20">Set of polygons</A>
</LI><LI><A HREF="system_manual007.html#toc21">Points, Curves and Polygons with real coordinates</A>
</LI><LI><A HREF="system_manual007.html#toc22">Lists of <I>n</I>-tuple reals</A>
</LI></UL>
<P>
<A NAME="curves-polygons"></A>
</P><P>The family of curves, polygons and lists objects are mainly used to handle geometrical
processes, as mathematical morphology algorithms, shape analysis, snakes, &#X2026;</P><P>In MegaWave2, a <EM>curve</EM><A NAME="@default74"></A> (section&#XA0;<A HREF="#curves-polygons_curve">6.2</A>) is a set of 
points<A NAME="@default75"></A> in the plane that is, a set of (<I>x</I>,<I>y</I>) coordinates. 
Although there is no such explicit condition in the system library, most modules assume that 
this set is really a curve, meaning that points are adjacent for the 4 or 8-connectivity,
and that the dimension of the set is less than 2. For a two-dimensional set of points,
to avoid memory blowup, consider the segment structure (Section&#XA0;<A HREF="system_manual008.html#hsegment">7.4</A>).
A curve is implemented as a chain of points:
the curve begins with a first point, from which we can go to the next 
point, and so one up to the last point. 
There is no condition set about the geometry of the curve (e.g. the curve can
cut itself) but your algorithm may want to put some. 
There is no an a priori rule to interpolate the curve between two adjacent points
in the chain, in the case where they are not adjacent in the plane. Your algorithm may
have to process such interpolation.</P><P>You may want to handle a <EM>set of curves</EM> (it can be for example the result of an edge detector applied to an image). 
Such object is also provided in MegaWave2 (section&#XA0;<A HREF="#curves-polygons_curves">6.3</A>) and it is implemented as a chain of curves.</P><P>What we call <EM>polygon</EM><A NAME="@default76"></A> (section&#XA0;<A HREF="#curves-polygons_polygon">6.4</A>) is basically a closed curve that is, a chain of (<I>x</I>,<I>y</I>) coordinates where the point next the last point is assumed to be the first point. 
But one can associate to a polygon a list of real parameters.
It can be, for example, only one value which gives the gray level of the
constant region delimited by the closed curve. 
The meaning of the parameters is not pre-defined, so you can used it freely
in your algorithms. </P><P>You may also want to handle a <EM>set of polygons</EM> (it can be for example the result of a region-segmentation algorithm applied to an image).
This object, explained in section&#XA0;<A HREF="#curves-polygons_polygons">6.5</A>, is of course
implemented as a chain of polygons.</P><P>All of the objects we have enumerated can record integer or real coordinates 
(for some 
applications, you may need real coordinates - e.g. when you compute a P.D.E. 
to evolve a curve -). 
In the following, we give a full description of the objects for which 
coordinates are integers.
By putting a <CODE>F</CODE> (floating-point precision) or <CODE>D</CODE> (double) at the beginning
of the <EM>curve</EM> and <EM>polygon</EM> object&#X2019;s name, you get the corresponding 
object with real coordinates 
fields (see section&#XA0;<A HREF="#curves-polygons_real">6.6</A> for a short description).</P><P>We shall begin our description by the basic object used by curves and polygons: the point.</P><H2 CLASS="section"><A NAME="toc16"></A><A NAME="htoc60">6.1</A>&#XA0;&#XA0;Point of a planar curve</H2><P><A NAME="curves-polygons_point"></A>

<A NAME="@default77"></A></P><P>A <TT>Point_curve</TT><A NAME="@default78"></A> is nothing more than two coordinates (<I>x</I>,<I>y</I>) which can be linked
to a previous and to a next <TT>Point_curve</TT>, in order to constitute a curve.</P><H3 CLASS="subsection"><A NAME="htoc61">6.1.1</A>&#XA0;&#XA0;The structure Point_curve</H3><P>
<A NAME="curves-polygons_point_structure"></A></P><P>This is the C definition of the structure:
</P><PRE CLASS="verbatim">typedef struct point_curve {
  int x,y; /* Coordinates of the point */

  /* For use in Curve only */
  struct point_curve *previous; /*Pointer to the previous point (may be NULL)*/
  struct point_curve *next; /* Pointer to the next point (may be NULL) */
} *Point_curve;
</PRE><P>The first two fields <CODE>x</CODE> and <CODE>y</CODE> are the coordinates (<I>x</I>,<I>y</I>) of
the point in the plane. 
Since the <CODE>Curve</CODE> and the <CODE>Polygon</CODE> structures are defined as
a chain of <TT>Point_curve</TT>, there are two pointers <CODE>previous</CODE> and <CODE>next</CODE> associated to each point.</P><H3 CLASS="subsection"><A NAME="htoc62">6.1.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="curves-polygons_point-file_type"></A></P><P>Not available: at this time, the <TT>Point_curve</TT> object cannot be used as input/output variables of modules.</P><H3 CLASS="subsection"><A NAME="htoc63">6.1.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="curves-polygons_point_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Point_curve</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_point_curve</FONT></B> - Define the point_curve structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_curve mw_change_point_curve(point)</P><P>Point_curve point;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a Point_curve structure if the input <CODE>point = NULL</CODE>.
It is provided despite the <CODE>mw_new_point_curve</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_point_curve</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Point_curve point=NULL; /* Internal use: no Input neither Output of module */

/* Define the point (5,1) of the plane */

point = mw_change_point_curve(point);
if (point == NULL) mwerror(FATAL,1,"Not enough memory.\n");
point-&gt;x = 5;
point-&gt;y = 1;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_point_curve</FONT></B> - Copy all points starting from the given one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_curve mw_copy_point_curve(in,out)</P><P>Point_curve in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the current point and the next points contained in the chain 
defined at the starting point <CODE>in</CODE>. The result is put in <CODE>out</CODE>, which
may not be a predefined structure : in case of <CODE>out=NULL</CODE>, the <CODE>out</CODE>
structure is allocated.</P><P>The function <CODE>mw_copy_point_curve</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Point_curve in; /* Predefined point */
Point_curve out=NULL; 

out=mw_copy_point_curve(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_point_curve</FONT></B> - Deallocate the point_curve structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_point_curve(point)</P><P>Point_curve point;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates the <TT>Point_curve</TT> structures starting from
the given <CODE>point</CODE>, including this point itself.
You should set <CODE>point = NULL</CODE> after this call since the address pointed
by <CODE>point</CODE> is no longer valid.
Warning : to deallocate only a point and not all the next points of a 
chain, just use <CODE>free(point)</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Remove the first point of an existing curve */

Curve curve;  /* Existing curve (e.g. Input of module) */
Point_curve point;  /* Internal use */

point = curve-&gt;first;
curve-&gt;first=point-&gt;next;
point-&gt;next-&gt;previous = NULL;
free(point);
point = NULL;

/* Remove all points of an existing curve */

mw_delete_point_curve(curve-&gt;first);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_point_curve</FONT></B> - Create a new point_curve structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Point_curve mw_new_point_curve();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Point_curve</TT> structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal point structures before the end
of the module, except if they are part of an input or output curve.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Insert the point (0,0) at the end of an existing curve */

Curve curve;  /* Existing curve (e.g. Input of module) */
Point_curve point,p;  /* Internal use: no Input neither Output of module */

/* Define the point (0,0) */
point = mw_new_point_curve();
if (point == NULL) mwerror(FATAL,1,"Not enough memory.\n");
point-&gt;x = point-&gt;y = 0;
point-&gt;next = NULL;

/* Find the last point of the curve */
p = curve-&gt;first; while (p-&gt;next) p=p-&gt;next;

/* Insert the point */
p-&gt;next = point;
point-&gt;previous = p;

/* Do not deallocate point or curve will become inconsistent */ 
</PRE><H2 CLASS="section"><A NAME="toc17"></A><A NAME="htoc64">6.2</A>&#XA0;&#XA0;Planar curve</H2><P><A NAME="curves-polygons_curve"></A>

<A NAME="@default79"></A></P><P>You may want to use the <TT>Curve</TT> memory type each type you need to 
constitute a chain of (<I>x</I>,<I>y</I>) coordinates.</P><H3 CLASS="subsection"><A NAME="htoc65">6.2.1</A>&#XA0;&#XA0;The structure Curve</H3><P>
<A NAME="curves-polygons_curve_structure"></A></P><P>If <CODE>curve</CODE> is of <TT>Curve</TT> memory type, then <CODE>curve-&gt;first</CODE> is
of <TT>Point_curve</TT>memory type and it is the first point of the curve; 
<CODE>curve-&gt;first-&gt;next</CODE> is the second point, etc.
The end of the curve occurs when the <CODE>next</CODE> field of a point is
<TT>NULL</TT>.</P><PRE CLASS="verbatim">typedef struct curve {
  Point_curve first; /* Pointer to the first point of the curve */

  /* For use in Curves only */
  struct curve *previous; /* Pointer to the previous curve (may be NULL) */
  struct curve *next; /* Pointer to the next curve (may be NULL) */
} *Curve;
</PRE><P>You may notice that the <TT>Curve</TT>type includes also the fields
<CODE>previous</CODE> and <CODE>next</CODE>, as the <TT>Point_curve</TT>type. This is because
curves can be linked together to define a set of curves (See&#XA0;<A HREF="#curves-polygons_curve_function">6.2.3</A> page&#XA0;<A HREF="#curves-polygons_curve_function">??</A>).
If the curve is not part of a set, those pointers must be <TT>NULL</TT>.</P><H3 CLASS="subsection"><A NAME="htoc66">6.2.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="curves-polygons_curve-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_CURVE"</CODE><A NAME="@default80"></A> MegaWave2 binary format.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc67">6.2.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="curves-polygons_curve_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Curve</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_curve</FONT></B> - Define the curve structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curve mw_change_curve(curve)</P><P>Curve curve;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a Curve structure if the input <CODE>curve = NULL</CODE>.
It is provided despite the <CODE>mw_new_curve</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_curve</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal curve structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curve with 10 points which is the straight line (0,0)-(9,9) */

Curve curve=NULL; /* Internal use: no Input neither Output of module */
Point_curve newp,oldp=NULL;
int i;

curve = mw_change_curve(curve);
if (curve == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_curve</CODE> function).</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_curve</FONT></B> - Copy a curve into another one</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curve mw_copy_curve(in,out)</P><P>Curve in, out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function duplicates the points contained in <CODE>in</CODE>.
The result is put in <CODE>out</CODE>, which may not be a predefined structure : in case 
of <CODE>out=NULL</CODE>, the <CODE>out</CODE> structure is allocated.</P><P>The function <CODE>mw_copy_curve</CODE> returns <TT>NULL</TT> if not enough memory is available to perform
the copy, or <CODE>out</CODE> elsewhere.
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Curve in; /* Predefined curve */
Curve out=NULL; 

out=mw_copy_curve(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory.\n");
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_curve</FONT></B> - Deallocate a curve</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_curve(curve)</P><P>Curve curve;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory allocated by the curve variable that is, all the points belonging to this chain and the <TT>Curve</TT>structure itself.
You should set <CODE>curve = NULL</CODE> after this call since the address pointed
by <CODE>curve</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Remove the first curve of an existing curve set (curves) */

Curves curves;/* Existing curve set (e.g. Input of module) */
Curve curve;  /* Internal use */

curve = curves-&gt;first;
curves-&gt;first=curves-&gt;next;
curves-&gt;next-&gt;previous = NULL;
mw_delete_curve(curve);
curve = NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_curve</FONT></B> - Return the number of points of a curve</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_curve(cv);</P><P>Curve cv;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function return the number of points contained in the given
curve <CODE>cv</CODE>. It returns 0 if the structure is empty.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Curve curve; /* Internal use: no Input neither Output of module */
Point_curve newp,oldp=NULL;
int i;

curve = mw_new_curve();
if (curve == NULL) mwerror(FATAL,1,"Not enough memory.\n");

/* Define a curve with 5 points */
for (i=1;i&lt;=5;i++)
{
 newp = mw_new_point_curve();
 if (newp == NULL) mwerror(FATAL,1,"Not enough memory.\n");
 if (i=0) curve-&gt;first = newp;
 newp-&gt;x = newp-&gt;y = i;
 newp-&gt;previous = oldp;
 if (oldp) oldp-&gt;next = newp;
 oldp=newp;
} 

/* The length is 5 */
printf("Length=%d\n",mw_length_curve(curve));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_curve</FONT></B> - Create a new curve</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curve mw_new_curve();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Curve</TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output chain.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curve with 10 points which is the straight line (0,0)-(9,9) */

Curve curve; /* Internal use: no Input neither Output of module */
Point_curve newp,oldp=NULL;
int i;

curve = mw_new_curve();
if (curve == NULL) mwerror(FATAL,1,"Not enough memory.\n");

for (i=0;i&lt;10;i++)
{
 newp = mw_new_point_curve();
 if (newp == NULL) mwerror(FATAL,1,"Not enough memory.\n");
 if (i=0) curve-&gt;first = newp;
 newp-&gt;x = newp-&gt;y = i;
 newp-&gt;previous = oldp;
 if (oldp) oldp-&gt;next = newp;
 oldp=newp;
} 
</PRE><H2 CLASS="section"><A NAME="toc18"></A><A NAME="htoc68">6.3</A>&#XA0;&#XA0;Set of planar curves</H2><P><A NAME="curves-polygons_curves"></A>

<A NAME="@default81"></A></P><P>The <TT>Curves</TT> memory type is used when you want to handle several curves
into only one variable. </P><H3 CLASS="subsection"><A NAME="htoc69">6.3.1</A>&#XA0;&#XA0;The structure Curves</H3><P>
<A NAME="curves-polygons_curves_structure"></A></P><P>This is the C definition of the structure:
</P><PRE CLASS="verbatim">typedef struct curves {
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the set */
  Curve first;    /* Pointer to the first curve */
} *Curves;
</PRE><P>If <CODE>curves</CODE> is of <TT>Curves</TT> memory type, then <CODE>curves-&gt;first</CODE> is
of <TT>Curve</TT> memory type and it is the first curve of the set; 
therefore, <CODE>curves-&gt;first-&gt;first</CODE> is the first point of the first
curve.
<CODE>curves-&gt;first-&gt;next</CODE> is the second curve, etc.
The end of the set occurs when the <CODE>next</CODE> field of a curve is
<TT>NULL</TT>.</P><H3 CLASS="subsection"><A NAME="htoc70">6.3.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="curves-polygons_curves-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_CURVES"</CODE><A NAME="@default82"></A> MegaWave2 binary format.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc71">6.3.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="curves-polygons_curves_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Curves</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_curves</FONT></B> - Define the curves structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curves mw_change_curves(curves)</P><P>Curves curves;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a Curves structure if the input <CODE>curves = NULL</CODE>.
It is provided despite the <CODE>mw_new_curves</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_curves</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal curves structures before the end
of the module.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curves set to be two pre-defined curves  */

Curves curves=NULL;   /* Internal use: no Input neither Output of module */
Curve curve1,curve2;  /* Pre-defined curves (e.g. inputs of module) */

curves = mw_change_curves(curves);
if (curves == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_curves</CODE> function).</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_curves</FONT></B> - Deallocate a curves set</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_curves(curves)</P><P>Curves curves;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory allocated by the curves variable
that is, all the points belonging to all curves into this set, all <TT>Curve</TT>structures and the <TT>Curves</TT>structure itself.
You should set <CODE>curves = NULL</CODE> after this call since the address pointed
by <CODE>curves</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Curves curves=NULL;   /* Internal use: no Input neither Output of module */

curves = mw_new_curves();
if (curves == NULL) mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_curves(curves);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_curves</FONT></B> - Return the number of curves into a curves structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_curves(cvs);</P><P>Curves cvs;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of curves contained in the given
<CODE>cvs</CODE>. It returns 0 if the structure is empty.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curves set to be two pre-defined curves  */

Curves curves=NULL;   /* Internal use: no Input neither Output of module */
Curve curve1,curve2;  /* Pre-defined curves (e.g. inputs of module) */

curves = mw_new_curves();
if (curves == NULL) mwerror(FATAL,1,"Not enough memory.\n");

curves-&gt;first=curve1;
curve1-&gt;previous = curve2-&gt;next = NULL;
curve1-&gt;next = curve2;
curve2-&gt;previous = curve1;

/* The length would be 2 */
printf("Length=%d\n",mw_length_curves(curves));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_curves</FONT></B> - Create a new curves</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Curves mw_new_curves();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Curves</TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a curves set to be two pre-defined curves  */

Curves curves=NULL;   /* Internal use: no Input neither Output of module */
Curve curve1,curve2;  /* Pre-defined curves (e.g. inputs of module) */

curves = mw_new_curves();
if (curves == NULL) mwerror(FATAL,1,"Not enough memory.\n");

curves-&gt;first=curve1;
curve1-&gt;previous = curve2-&gt;next = NULL;
curve1-&gt;next = curve2;
curve2-&gt;previous = curve1;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_npoints_curves</FONT></B> - Return the total number of points a curves structure contains</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_npoints_curves(cvs);</P><P>Curves cvs;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the total number of points contained in the given
<CODE>cvs</CODE>, that is the sum of <CODE>mw_length_curve(cv)</CODE> for all
curves <CODE>cv</CODE> contained in <CODE>cvs</CODE>.
The function returns 0 if the structure is empty.</P><H2 CLASS="section"><A NAME="toc19"></A><A NAME="htoc72">6.4</A>&#XA0;&#XA0;Polygon, a variant of curve</H2><P><A NAME="curves-polygons_polygon"></A></P><P>
<A NAME="@default83"></A></P><P>You should use the <TT>Polygon</TT> memory type when you need to constitute a 
chain of (<I>x</I>,<I>y</I>) coordinates with some global properties.</P><H3 CLASS="subsection"><A NAME="htoc73">6.4.1</A>&#XA0;&#XA0;The structure Polygon</H3><P>
<A NAME="curves-polygons_polygon_structure"></A></P><P>The first two fields of the structure register the global properties,
assumed to be represented as an array of channels; each channel is
a real number. 
The meaning of each channel has to be defined by the user; the number
of channels can be selected using the function <CODE>mw_alloc_polygon</CODE>
or <CODE>mw_change_polygon</CODE> (see below).</P><P>The next fields of the structure are similar to those in the <TT>Curve</TT>memory 
type.</P><PRE CLASS="verbatim">typedef struct polygon {
  int nb_channels;  /* Number of channels */
  float *channel;  /* Tab to the channel */
                   /* The number of elements is given by nb_channels */
  Point_curve first; /* Pointer to the first point of the curve */

  /* For use in Polygons only */
  struct polygon *previous; /* Pointer to the previous poly. (may be NULL) */
  struct polygon *next; /* Pointer to the next poly. (may be NULL) */
} *Polygon;
</PRE><H3 CLASS="subsection"><A NAME="htoc74">6.4.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="curves-polygons_polygon-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_POLY"</CODE><A NAME="@default84"></A> MegaWave2 Data Ascii format with a <CODE>def Polygon</CODE> 
area. 
If a file of this format has several <CODE>def Polygon</CODE> areas, only the first one is meaningful for the <TT>Polygon</TT> object.
Since this format uses Ascii coding, you may read or modify the file just by
editing it using a text editor.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc75">6.4.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="curves-polygons_polygon_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Polygon</TT> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_alloc_polygon</FONT></B> - Allocate the channels array</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygon mw_alloc_polygon(polygon,nc)</P><P>Polygon polygon;</P><P>int nc;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function allocates the channels array of a <TT>Polygon</TT>structure previously
created using <CODE>mw_new_polygon</CODE>. The size of the array is given by 
<CODE>nc</CODE>, it is the number of different channels.
A channel corresponds to a real parameter associated to the polygon. 
The meaning of such channel has to be defined by the user. 
For example, <CODE>polygon-&gt;channel[0]</CODE> may be the gray level of the polygon.</P><P>Do not use this function if <CODE>polygon</CODE> has already an allocated channels array: use the function <CODE>mw_change_polygon</CODE> instead.</P><P>The function <CODE>mw_alloc_polygon</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure or the channels array. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
See the example of the function <CODE>mw_new_polygon</CODE>.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_polygon</FONT></B> - Change the number of channels</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygon mw_change_polygon(polygon,nc)</P><P>Polygon polygon;</P><P>int nc;
</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation for the channels array of
a <TT>Polygon</TT>structure, even if no previously memory allocation was done. </P><P>The number of channels is given by <CODE>nc</CODE>; a channel corresponds to
a real parameter associated to the polygon. The meaning of such channel
has to be defined by the user. For example, <CODE>polygon-&gt;channel[0]</CODE> may be the gray level of the polygon.</P><P>This function can also create the structure if the input <CODE>polygon = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_polygon</CODE> and
<CODE>mw_alloc_polygon</CODE>. 
It is the recommended function to set the number of channels for polygons which are input/output of a module.
Since the function can set the address of <CODE>polygon</CODE>, the variable must be set to the return value of the function (See example below).</P><P>The function <CODE>mw_change_polygon</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure or the channels array. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Polygon polygon; /* Input of module */

polygon = mw_change_polygon(polygon,1);
if (polygon == NULL) mwerror(FATAL,1,"Not enough memory.\n");
polygon-&gt;channel[0] = 255.0;
...
</PRE><P>(End of this example as for the <CODE>mw_new_polygon</CODE> function).</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_polygon</FONT></B> - Deallocate a polygon</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_polygon(polygon)</P><P>Polygon polygon;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory allocated by the polygon variable that is, all the points belonging to this chain, the channels array (if needed) and the <TT>Polygon</TT>structure itself.
You should set <CODE>polygon = NULL</CODE> after this call since the address pointed
by <CODE>polygon</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Remove the first polygon of an existing polygon set (polygons) */

Polygons polygons;/* Existing polygons set (e.g. Input of module) */
Polygon polygon;  /* Internal use */

polygon = polygons-&gt;first;
polygons-&gt;first=polygons-&gt;next;
polygons-&gt;next-&gt;previous = NULL;
mw_delete_polygon(polygon);
polygon = NULL;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_polygon</FONT></B> - Return the number of points of a polygon</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_polygon(poly);</P><P>Polygon poly;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function return the number of points contained in the given
polygon <CODE>poly</CODE>. It returns 0 if the structure is empty.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Polygon polygon; /* Internal use: no Input neither Output of module */
point_curve newp,oldp=NULL;
int i;

polygon = mw_new_polygon();
if (polygon == NULL) mwerror(FATAL,1,"Not enough memory.\n");

/* Define a polygon with 5 points */
for (i=1;i&lt;=5;i++)
{
 newp = mw_new_point_curve();
 if (newp == NULL) mwerror(FATAL,1,"Not enough memory.\n");
 if (i=0) polygon-&gt;first = newp;
 newp-&gt;x = newp-&gt;y = i;
 newp-&gt;previous = oldp;
 if (oldp) oldp-&gt;next = newp;
 oldp=newp;
} 

/* The length is 5 */
printf("Length=%d\n",mw_length_polygon(polygon));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_polygon</FONT></B> - Create a new polygon</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygon mw_new_polygon();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Polygon</TT>structure with an empty channels array.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module, except if they are part of an input or output polygons set.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a polygon with 10 points which is the straight line (0,0)-(9,9) */

Polygon polygon; /* Internal use: no Input neither Output of module */
Point_curve newp,oldp=NULL;
int i;

polygon = mw_new_polygon();
if ((polygon == NULL) || (mw_alloc_polygon(polygon,1) == NULL))
    mwerror(FATAL,1,"Not enough memory.\n");
polygon-&gt;channel[0] = 255.0;

for (i=0;i&lt;10;i++)
{
 newp = mw_new_point_curve();
 if (newp == NULL) mwerror(FATAL,1,"Not enough memory.\n");
 if (i=0) polygon-&gt;first = newp;
 newp-&gt;x = newp-&gt;y = i;
 newp-&gt;previous = oldp;
 if (oldp) oldp-&gt;next = newp;
 oldp=newp;
} 
</PRE><H2 CLASS="section"><A NAME="toc20"></A><A NAME="htoc76">6.5</A>&#XA0;&#XA0;Set of polygons</H2><P><A NAME="curves-polygons_polygons"></A>

<A NAME="@default85"></A></P><P>The <TT>Polygons</TT> memory type is used when you want to handle several polygons
into only one variable. </P><H3 CLASS="subsection"><A NAME="htoc77">6.5.1</A>&#XA0;&#XA0;The structure Polygons</H3><P>
<A NAME="curves-polygons_polygons_structure"></A></P><P>This is the C definition of the structure:
</P><PRE CLASS="verbatim">typedef struct polygons {
  char cmt[mw_cmtsize]; /* Comments */
  char name[mw_namesize]; /* Name of the set */
  Polygon first;    /* Pointer to the first polygon */
} *Polygons;
</PRE><P>If <CODE>polygons</CODE> is of <TT>Polygons</TT> memory type, then <CODE>polygons-&gt;first</CODE> is
of <TT>Polygon</TT> memory type and it is the first polygon of the set; 
therefore, <CODE>polygons-&gt;first-&gt;first</CODE> is the first point of the first
polygon.
<CODE>polygons-&gt;first-&gt;next</CODE> is the second polygon, etc.
The end of the set occurs when the <CODE>next</CODE> field of a polygon is
<TT>NULL</TT>.</P><H3 CLASS="subsection"><A NAME="htoc78">6.5.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="curves-polygons_polygons-file_type"></A></P><P>The list of the available formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"A_POLY"</CODE><A NAME="@default86"></A> 
MegaWave2 Data Ascii format with as many <CODE>def Polygon</CODE> areas as the number of polygons recorded.
Since this format uses Ascii coding, you may read or modify the file just by
editing it using a text editor.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc79">6.5.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="curves-polygons_polygons_function"></A></P><P>The following is a description of all the functions related to 
the <CODE>Polygons</CODE> type. The list is in alphabetical order.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_polygons</FONT></B> - Define the polygons structure, if not defined</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygons mw_change_polygons(polygons)</P><P>Polygons polygons;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns a Polygons structure if the input <CODE>polygons = NULL</CODE>.
It is provided despite the <CODE>mw_new_polygons</CODE> function for
global coherence with other memory types.</P><P>The function <CODE>mw_change_polygons</CODE> returns <TT>NULL</TT> if not enough memory is available to allocate the structure. 
Your code should check this return value to send an error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal polygons structures before the end
of the module.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a polygons set to be two pre-defined polygons  */

Polygons polygons=NULL;   /* Internal use: no Input neither Output of module */
Polygon polygon1,polygon2;  /* Pre-defined polygons (e.g. inputs of module) */

polygons = mw_change_polygons(polygons);
if (polygons == NULL) mwerror(FATAL,1,"Not enough memory.\n");
...
</PRE><P>(End of this example as for the <CODE>mw_new_polygons</CODE> function).</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_polygons</FONT></B> - Deallocate a polygons set</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_polygons(polygons)</P><P>Polygons polygons;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deallocates all the memory allocated by the polygons variable
that is, all the points belonging to all polygons into this set, all channels arrays (if any), all <TT>Polygon</TT>structures and the <TT>Polygons</TT>structure itself.
You should set <CODE>polygons = NULL</CODE> after this call since the address pointed
by <CODE>polygons</CODE> is no longer valid.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Polygons polygons=NULL;   /* Internal use: no Input neither Output of module */

polygons = mw_new_polygons();
if (polygons == NULL) mwerror(FATAL,1,"Not enough memory.\n");
.
.
.
mw_delete_polygons(polygons);
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_length_polygons</FONT></B> - Return the number of polygons into a polygons structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
unsigned int mw_length_polygons(polys);</P><P>Polygons polys;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function returns the number of polygons contained in the given
<CODE>polys</CODE>. It returns 0 if the structure is empty.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a polygons set to be two pre-defined polygons  */

Polygons polygons=NULL;   /* Internal use: no Input neither Output of module */
Polygon polygon1,polygon2;  /* Pre-defined polygons (e.g. inputs of module) */

polygons = mw_new_polygons();
if (polygons == NULL) mwerror(FATAL,1,"Not enough memory.\n");

polygons-&gt;first=polygon1;
polygon1-&gt;previous = polygon2-&gt;next = NULL;
polygon1-&gt;next = polygon2;
polygon2-&gt;previous = polygon1;

/* The length would be 2 */
printf("Length=%d\n",mw_length_polygons(polygons));

</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_polygons</FONT></B> - Create a new polygons</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Polygons mw_new_polygons();
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Polygons</TT>structure.
It returns <TT>NULL</TT> if not enough memory is available to create the structure.
Your code should check this value to send an
error message in the <TT>NULL</TT> case, and do appropriate statement.</P><P>Since the MegaWave2 compiler allocates structures for input and output 
objects (see volume one: &#X201C;MegaWave2 user manual&#X201D;), this function is normally used only for internal objects.
Do not forget to deallocate the internal structures before the end
of the module.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">/* Define a polygons set to be two pre-defined polygons  */

Polygons polygons=NULL;   /* Internal use: no Input neither Output of module */
Polygon polygon1,polygon2;  /* Pre-defined polygons (e.g. inputs of module) */

polygons = mw_new_polygons();
if (polygons == NULL) mwerror(FATAL,1,"Not enough memory.\n");

polygons-&gt;first=polygon1;
polygon1-&gt;previous = polygon2-&gt;next = NULL;
polygon1-&gt;next = polygon2;
polygon2-&gt;previous = polygon1;
</PRE><H2 CLASS="section"><A NAME="toc21"></A><A NAME="htoc80">6.6</A>&#XA0;&#XA0;Points, Curves and Polygons with real coordinates</H2><P><A NAME="curves-polygons_real"></A></P><P>Until now, all of the objects we have described in the
section&#XA0;<A HREF="#curves-polygons">6</A> record the coordinates as integers.
Use the following objects if you need coordinates of floating point
values:
<TT>Point_fcurve</TT><A NAME="@default87"></A>, <TT>Fcurve</TT><A NAME="@default88"></A>, <TT>Fcurves</TT><A NAME="@default89"></A>,
<TT>Fpolygon</TT><A NAME="@default90"></A>, <TT>Fpolygons</TT><A NAME="@default91"></A>.
If you need higher precision, use the following objects (coordinates
are recorded as double): <TT>Point_dcurve</TT><A NAME="@default92"></A>, <TT>Dcurve</TT><A NAME="@default93"></A>, 
<TT>Dcurves</TT><A NAME="@default94"></A>.</P><P>We will not give the full description of these objects and of their related
functions since it is equivalent to the former description, just keep in
mind to translate the words <EM>curve</EM> to <EM>fcurve</EM> or <EM>dcurve</EM> and <EM>polygon</EM>
to <EM>fpolygon</EM>, both in the type names (the first letter being upper-case) and in the function 
names.</P><P>And, of course, do not forget that the coordinates are now real.
The C definition of the structure <TT>Point_fcurve</TT> is the following:
</P><PRE CLASS="verbatim">typedef struct point_fcurve {
  float x,y; /* Coordinates of the point */

  /* For use in Fcurve only */
  struct point_fcurve *previous; /*Pointer to the previous point (may be NULL)*/
  struct point_fcurve *next; /* Pointer to the next point (may be NULL) */
} *Point_fcurve;
</PRE><P>
The C definition of the structure <TT>Point_dcurve</TT> is the following:
</P><PRE CLASS="verbatim">typedef struct point_dcurve {
  double x,y; /* Coordinates of the point */

  /* For use in Dcurve only */
  struct point_dcurve *previous; /*Pointer to the previous point (may be NULL)*/
  struct point_dcurve *next; /* Pointer to the next point (may be NULL) */
} *Point_dcurve;
</PRE><H2 CLASS="section"><A NAME="toc22"></A><A NAME="htoc81">6.7</A>&#XA0;&#XA0;Lists of <I>n</I>-tuple reals</H2><P>Some algorithms dealing with curves can be made more efficient if image coordinates
are not recorded as a chain of points (<I>x</I>,<I>y</I>), but as part of an array<A NAME="@default95"></A>.
In such case, use one of the <TT>Flist</TT>, <TT>Flists</TT>, <TT>Dlist</TT>, <TT>Dlists</TT> objects above.
These types can more generally be used to handle any list<A NAME="@default96"></A> of <I>n</I>-tuple reals, the
case of points in the plane corresponding to <I>n</I>=2.
As for curves, <TT>Dlist</TT> and <TT>Dlists</TT> are the counterpart of <TT>Flist</TT> and <TT>Flists</TT> :
the only difference between them is that values are of type double instead of float.</P><H3 CLASS="subsection"><A NAME="htoc82">6.7.1</A>&#XA0;&#XA0;The structure Flist</H3><P>
<A NAME="curves-polygons_flist"></A></P><P>In a variable of <TT>Flist</TT><A NAME="@default97"></A> memory type, data such as coordinates are
recorded in the array named <CODE>values</CODE>.
We call <EM>dimension</EM> (field named <CODE>dim</CODE>) the number of
components per elements the array is composed, while the field
named <CODE>size</CODE> gives the number of elements.
When a <TT>Flist</TT> is used as a <TT>Fcurve</TT>, the dimension is 2 (number of coordinates
in the plane) and the size is the number of points.</P><P>The field <CODE>data</CODE> can be used to record any additional information
(when no information is available, it is set to <CODE>NULL</CODE>).
The size of the space pointed by <CODE>data</CODE> is set in <CODE>data_size</CODE>.</P><PRE CLASS="verbatim">typedef struct flist {
  int size;          /* size (number of elements) */
  int max_size;      /* currently allocated size (maximum number of elements) */ 
  int dim;           /* dimension (number of components per element) */
  float *values;     /* values = size * dim array
                          nth element = values[n*dim+i], i=0..dim-1 */
  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */
} *Flist;
</PRE><H3 CLASS="subsection"><A NAME="htoc83">6.7.2</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="curves-polygons_flist-file_type"></A></P><P>The list of the available native formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_FLIST"</CODE><A NAME="@default98"></A> MegaWave2 binary format.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc84">6.7.3</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="curves-polygons_flist_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Flist</TT> type. The list is in alphabetical order.
Notice that these functions do not manage the <CODE>data</CODE> field.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_flist</FONT></B> - Define and allocate a <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_change_flist(l,max_size,size,dim)</P><P>Flist l;
int max_size,size,dim;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the <CODE>values</CODE> array
of a <TT>Flist</TT> structure, even if no previously memory allocation was done.
The new size (number of elements) of the structure is given by <CODE>size</CODE>,
the size to allocate (maximal number of elements) by <CODE>max_size</CODE>,
and the dimension by <CODE>dim</CODE>.</P><P>It can also create the structure if the input <CODE>l = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_flist</CODE> and
<CODE>mw_realloc_flist</CODE>. 
Since the function can set the address of <CODE>l</CODE>, the variable must be set 
to the return value of the function (See example below).</P><P>The function <CODE>mw_change_flist</CODE> returns <TT>NULL</TT> if not enough memory is 
available to allocate the structure or the <CODE>values</CODE> array, and an error 
message is issued. 
Your code should check this return value to eventually send a fatal error 
message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist l;

/* 
   Allocate l to handle at most 10 samples of couples (2) of 
   floating point values, the default number of samples being 0. 
*/
l = mw_change_flist(NULL,10,0,2);
if (!l) mwerror(FATAL,1,"Not enough memory to continue !\n");


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_clear_flist</FONT></B> - Clear the array of a <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_clear_flist(l,v)</P><P>Flist l;
float v;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function clears the <CODE>values</CODE> array by filling it
with the value <CODE>v</CODE> (up to the current number of samples).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist l;

/* 
   Allocate l to handle at most 10 samples of couples (2) of 
   floating point values, the default number of samples being 5. 
*/
l = mw_change_flist(NULL,10,5,2);
if (!l) mwerror(FATAL,1,"Not enough memory to continue !\n");

/* 
  Clear the 5 current samples with 0.
*/
mw_clear_flist(l,0.0);


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_flist</FONT></B> - Copy a the array <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_copy_flist(in,out)</P><P>Flist in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the <CODE>values</CODE> array and <CODE>data</CODE> field 
of the <TT>Flist</TT> structure <CODE>in</CODE> into <CODE>out</CODE>. 
The duplicated <TT>Flist</TT> <CODE>out</CODE> is allocated to
at least the current size of <CODE>in</CODE>.</P><P>Since the function can set the address of <CODE>out</CODE>, the variable must be set 
to the return value of the function (See example below).</P><P>The function <CODE>mw_copy_flist</CODE> returns <TT>NULL</TT> if not enough memory is 
available to allocate the structure or the <CODE>values</CODE> array, and an error 
message is issued. 
Your code should check this return value to eventually send a fatal error 
message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist in,out=NULL;

/* 
   Allocate in to handle at most 10 samples of couples (2) of 
   floating point values, the current number of samples being 5. 
*/
in = mw_change_flist(NULL,10,5,2);
if (!in) mwerror(FATAL,1,"Not enough memory to continue !\n");

/* 
  Clear the 5 current samples with 1.
*/
mw_clear_flist(in,1.0);

/*
 Copy in into out. Allocated size for out is 5 samples.
*/
out=mw_copy_flist(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory to copy flist !\n");


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_flist</FONT></B> - Delete the array and the <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_flist(l)</P><P>Flist l;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deletes the <CODE>values</CODE> array and the structure itself.
Warning : the memory of the user-defined field <CODE>data</CODE> is not freed.
If this field has been allocated, you should free it before calling
<CODE>mw_delete_flist</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist l;

/* 
   Allocate l to handle at most 10 samples of couples (2) of 
   floating point values, the default number of samples being 5. 
*/
l = mw_change_flist(NULL,10,5,2);
if (!l) mwerror(FATAL,1,"Not enough memory to continue !\n");

/* 
  Allocate the data field for 20 integers.
*/
l-&gt;data_size=20*sizeof(int);
l-&gt;data= (int *)malloc(l-&gt;data_size);
if (!l-&gt;data) mwerror(FATAL,1,"Not enough memory to continue !\n");


/*
    ... (statement)...
*/

/* 
  Free the list, including data field. 
*/
free(l-&gt;data);
mw_delete_flist(l);


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_enlarge_flist</FONT></B> - Enlarge the array of a <TT>Flist</TT></P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_enlarge_flist(l)</P><P>Flist l;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function performs a memory reallocation on the array
<CODE>l-&gt;values</CODE> to increase the number of elements that can be recorded.
The enlargement factor is fixed by the constant <CODE>MW_LIST_ENLARGE_FACTOR</CODE>
defined in the include file <CODE>list.h</CODE>.
This function is useful when one does not know by advance the size of
the list, and when one wish to avoid multiple reallocations.</P><P>If not enough memory is available to perform the reallocation, an error
message is issued and the function returns <CODE>NULL</CODE>.
Otherwise, the function returns <CODE>l</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">

/* Fill a flist with diagonal points using mw_enlarge_flist 
   up to a random size, unknown by advance.
*/

Flist l; 

l = mw_change_flist(NULL,2,0,2);
if (l==NULL) mwerror(FATAL,1,"Not enough memory to continue !\n");
i=0;
do
  {
   if ((2*i == l-&gt;max_size) &amp;&amp; (!mw_enlarge_flist(l)))
       mwerror(FATAL,1,"Not enough memory to continue !\n");
   l-&gt;values[i++] = l-&gt;values[i++] = i;
  }  while (rand() != 0);
l-&gt;size=(i+1)/2;
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_flist</FONT></B> - Create a <TT>Flist</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_new_flist()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Flist</TT> structure. The fields are initialized
to 0 or <TT>NULL</TT>value.
The function returns the address of the new structure, or
<TT>NULL</TT> if not enough memory is available.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist l;

/*
  Define the structure
*/
l = mw_new_flist();
if (!l) mwerror(FATAL,1,"Not enough memory to define the list !\n");

/* 
  At that time, the FList is empty.
*/
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_realloc_flist</FONT></B> - Realloc the array of a <TT>Flist</TT></P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flist mw_realloc_flist(l,n)</P><P>Flist l;</P><P>int n;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function performs a memory reallocation on the array
<CODE>l-&gt;values</CODE> so that at most <I>n</I> elements can be recorded.</P><P>If not enough memory is available to perform the reallocation, an error
message is issued and the function returns <TT>NULL</TT>.
Otherwise, the function returns <CODE>l</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Flist l;

/* 
   Allocate l to handle at most 1000 samples of 500-tuple of 
   floating point values, the default number of samples being 1000. 
*/
l = mw_change_flist(NULL,1000,1000,500);
if (!l) mwerror(FATAL,1,"Not enough memory to continue !\n");

/*
    ... (statement)...
*/

/*
   Now we need space for 20 samples only : by doing reallocation,
   we allow to free some memory.
*/
l = mw_realloc_flist(l,20);
if (!l) mwerror(FATAL,1,"Couldn't realloc flist !\n");


</PRE><H3 CLASS="subsection"><A NAME="htoc85">6.7.4</A>&#XA0;&#XA0;The structure Flists</H3><P>
<A NAME="curves-polygons_flists"></A></P><P>A <TT>Flists</TT><A NAME="@default99"></A> structure is an array of <TT>Flist</TT> not necessary of the same size.
As for the <TT>Flist</TT> structure, the <TT>Flists</TT> structure contains a <CODE>data</CODE> 
field that can be used to record any additional information
(when no information is available, it is set to <CODE>NULL</CODE>).
The size of the space pointed by <CODE>data</CODE> is set in <CODE>data_size</CODE>.</P><PRE CLASS="verbatim">typedef struct flists {
  char cmt[mw_cmtsize];     /* Comments */
  char name[mw_namesize];   /* Name */
  int size;          /* size (number of lists) */
  int max_size;      /* currently allocated size (maximum number of lists) */
  Flist *list;       /* array of Flist */
  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */
} *Flists;

</PRE><H3 CLASS="subsection"><A NAME="htoc86">6.7.5</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="curves-polygons_flists-file_type"></A></P><P>The list of the available native formats is the following:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_FLISTS"</CODE><A NAME="@default100"></A> MegaWave2 binary format.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc87">6.7.6</A>&#XA0;&#XA0;Functions Summary</H3><P>
<A NAME="curves-polygons_flists_function"></A></P><P>The following is a description of all the functions related to 
the <TT>Flists</TT> type. The list is in alphabetical order.
Notice that these functions do not manage the <CODE>data</CODE> field.</P><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_change_flists</FONT></B> - Define and allocate a <TT>Flists</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_change_flists(ls,max_size,size)</P><P>Flist ls;</P><P>int max_size,size;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function changes the memory allocation of the <CODE>list</CODE> array
of a <TT>Flists</TT> structure, even if no previously memory allocation was done.
The new size (number of lists) of the structure is given by <CODE>size</CODE>,
and the size to allocate (maximal number of lists) by <CODE>max_size</CODE>.</P><P>It can also create the structure if the input <CODE>ls = NULL</CODE>.
Therefore, this function can replace both <CODE>mw_new_flists</CODE> and
<CODE>mw_realloc_flists</CODE>. 
Since the function can set the address of <CODE>ls</CODE>, the variable must be set 
to the return value of the function (See example below).</P><P>The function <CODE>mw_change_flists</CODE> returns <TT>NULL</TT> if not enough memory is 
available to allocate the structure or the <CODE>list</CODE> array, and an error 
message is issued. 
Your code should check this return value to eventually send a fatal error 
message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flists ls;

/* 
   Allocate ls to handle at most 10 lists, the current number of
   lists being 0 (no list).
*/
ls = mw_change_flists(NULL,10,0);
if (!ls) mwerror(FATAL,1,"Not enough memory to continue !\n");


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_copy_flists</FONT></B> - Copy the lists contained in a <TT>Flists</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_copy_flists(in,out)</P><P>Flists in,out;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function copies the <CODE>list</CODE> array and <CODE>data</CODE> field 
of the <TT>Flists</TT> structure <CODE>in</CODE> into <CODE>out</CODE> : 
each list contained in <CODE>in</CODE> are duplicated. 
The duplicated <TT>Flists</TT> <CODE>out</CODE> is allocated to at least
the current size of <CODE>in</CODE>. </P><P>Since the function can set the address of <CODE>out</CODE>, the variable must be set 
to the return value of the function (See example below).</P><P>The function <CODE>mw_copy_flists</CODE> returns <TT>NULL</TT> if not enough memory is 
available to allocate the structure or the <CODE>list</CODE> array, and an error 
message is issued. 
Your code should check this return value to eventually send a fatal error 
message in the <TT>NULL</TT> case, and do appropriate statement.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flists in,out=NULL;

/* 
   Allocate ls to handle at most 10 lists, the current number of
   lists being 3.
*/
ls = mw_change_flists(NULL,10,3);
if (!ls) mwerror(FATAL,1,"Not enough memory to continue !\n");


/* ... (Here fill the lists) ... */

/*
 Copy in into out. Allocated size for out is 3 lists.
*/
out=mw_copy_flists(in,out);
if (!out) mwerror(FATAL,1,"Not enough memory to copy the lists !\n");


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_delete_flists</FONT></B> - Delete the lists and the <TT>Flists</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
void mw_delete_flists(ls)</P><P>Flist ls;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function deletes the lists contained in the <CODE>list</CODE> array,
and the structure <TT>Flists</TT> itself.
Warning : the memory of the user-defined field <CODE>data</CODE> is not freed.
If this field has been allocated, you should free it before calling
<CODE>mw_delete_flists</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flist ls;
int i;

/*
    ... (Assume ls has been previoulsy allocated)...
*/

/* 
  Free the lists, including data field. 
*/
for (i=ls-&gt;size;i--;) if (ls-&gt;list[i]-&gt;data) free(ls-&gt;list[i]-&gt;data);
if (ls-&gt;data) free(ls-&gt;data);
mw_delete_flists(ls);


</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_enlarge_flists</FONT></B> - Enlarge the number of lists a <TT>Flists</TT> may contain</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_enlarge_flist(ls)</P><P>Flist ls;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function performs a memory reallocation on the array
<CODE>ls-&gt;list</CODE> to increase the number of lists that can be recorded.
The enlargement factor is fixed by the constant <CODE>MW_LIST_ENLARGE_FACTOR</CODE>
defined in the include file <CODE>list.h</CODE>.
This function is useful when one does not know by advance the number
of lists, and when one wish to avoid multiple reallocations.</P><P>If not enough memory is available to perform the reallocation, an error
message is issued and the function returns <CODE>NULL</CODE>.
Otherwise, the function returns <CODE>ls</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">

/* Fill a flists with lists until the user enters 'Q'.
*/

Flist ls; 
Flist l;
char c;

ls = mw_change_flists(NULL,10,0);
if (ls==NULL) mwerror(FATAL,1,"Not enough memory to continue !\n");
do {
  if (ls-&gt;size == ls-&gt;max_size) 
    if (mw_enlarge_flists(ls)==NULL)
      mwerror(FATAL,1,"Not enough memory to continue !\n");
  l = mw_change_flist(NULL,10,10,2);
  if (l==NULL) mwerror(FATAL,1,"Not enough memory to continue !\n");
  mw_clear_flist(l,1.0)
  ls-&gt;list[ls-&gt;size++] = l;
  scanf("%c",&amp;c);
    } while (c!='Q');
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_new_flists</FONT></B> - Create a <TT>Flists</TT> structure</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_new_flists()</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function creates a new <TT>Flists</TT> structure. The fields are initialized
to 0 or <TT>NULL</TT>value.
The function returns the address of the new structure, or
<TT>NULL</TT> if not enough memory is available.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">
Flists ls;

/*
  Define the structure
*/
ls = mw_new_flists();
if (!ls) mwerror(FATAL,1,"Not enough memory to define the lists !\n");

/* 
  At that time, the FLists is empty (no lists).
*/
</PRE><P>
<B><FONT SIZE=5>Name</FONT> <BR>
<BR>
<FONT SIZE=4>mw_realloc_flists</FONT></B> - Realloc the list array of the <TT>Flists</TT></P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Summary</B></FONT></P><P>
Flists mw_realloc_flists(ls,n)</P><P>Flists ls;</P><P>int n;
</P><P><BR>
<BR>
<BR>


<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This function performs a memory reallocation on the array
<CODE>ls-&gt;list</CODE> so that at most <I>n</I> lists can be recorded.</P><P>If not enough memory is available to perform the reallocation, an error
message is issued and the function returns <TT>NULL</TT>.
Otherwise, the function returns <CODE>ls</CODE>.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Example</B></FONT></P><P><BR>
<BR>
<BR>
</P><PRE CLASS="verbatim">Flists ls;

/*
   Allocate ls to handle 10 lists.
*/

ls = mw_new_flists();
if (!ls) mwerror(FATAL,1,"Not enough memory to continue !\n");
ls = mw_realloc_flists(ls,10);
if (!ls) mwerror(FATAL,1,"Not enough memory to continue !\n");

</PRE><H3 CLASS="subsection"><A NAME="htoc88">6.7.7</A>&#XA0;&#XA0;The structures Dlist and Dlists</H3><P>
<A NAME="curves-polygons_dlist-dlists"></A></P><P>As for curves, <TT>Dlist</TT><A NAME="@default101"></A> and <TT>Dlists</TT><A NAME="@default102"></A> are the counterpart 
of <TT>Flist</TT> and <TT>Flists</TT> :
the only difference between them is that values are of type double instead of float.
Since you can easily imagine how it works, we will not document the functions
associated to <TT>Dlist</TT> and <TT>Dlists</TT>. Just change the letter <CODE>f</CODE> to <CODE>d</CODE>.</P><PRE CLASS="verbatim">typedef struct dlist {

  int size;          /* size (number of elements) */
  int max_size;      /* currently allocated size (number of ELEMENTS) */
  int dim;           /* dimension (number of components per element) */

  double *values;    /* values = size * dim array
                          nth element = values[n*dim+i], i=0..dim-1 */

  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */

} *Dlist;
</PRE><PRE CLASS="verbatim">typedef struct dlists {

  char cmt[mw_cmtsize];     /* Comments */
  char name[mw_namesize];   /* Name */

  int size;          /* size (number of elements) */
  int max_size;      /* currently allocated size (number of ELEMENTS) */

  Dlist *list;       /* array of Dlist */

  int data_size;     /* size of data[] in bytes */
  void* data;        /* User defined field (saved). A pointer to something */

} *Dlists;

</PRE><H3 CLASS="subsection"><A NAME="htoc89">6.7.8</A>&#XA0;&#XA0;Related file (external) types</H3><P>
<A NAME="curves-polygons_dlist-dlists-file_type"></A></P><P>Here is the list of available native formats associated to <TT>Dlist</TT> internal type :
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_DLIST"</CODE><A NAME="@default103"></A> MegaWave2 binary format.
</LI></OL><P>The list of available native formats associated to <TT>Dlists</TT> internal type is
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>"MW2_DLISTS"</CODE><A NAME="@default104"></A> MegaWave2 binary format.
</LI></OL><HR>
<A HREF="system_manual006.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="system_manual008.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
</BODY>
</HTML>
