<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="user_manual.css">
<TITLE>Getting started</TITLE>
</HEAD>
<BODY >
<A HREF="user_manual003.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="user_manual005.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc22">Chapter&#XA0;3</A>&#XA0;&#XA0;Getting started</H1><UL>
<LI><A HREF="user_manual004.html#toc12">A simple module</A>
</LI><LI><A HREF="user_manual004.html#toc13">Some optimizations</A>
</LI><LI><A HREF="user_manual004.html#toc14">A little more complex extension</A>
</LI></UL>
<P>
<A NAME="start"></A>
</P><P>This section shows you how to write a MegaWave2 module, by explaining several examples.
If you want to run existing modules only, please refer to the Volume three: &#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D; to learn more about the different modules.</P><H2 CLASS="section"><A NAME="toc12"></A><A NAME="htoc23">3.1</A>&#XA0;&#XA0;A simple module</H2><P>
<A NAME="start_simple"></A></P><P><A NAME="@default105"></A>
Let us suppose that you want to write an algorithm which adds the content of
two monochrome images<A NAME="@default106"></A>, that is to say it adds pixel by pixel the gray level values.</P><P>The first question you should ask yourself is &#X201C;what should be the input and the output of this algorithm ?&#X201D;.
Obviously you need two images for the input and the output will be another image, which will support the result of the addition.
If you refer to the Volume two: &#X201C;MegaWave2 System Library&#X201D;, you will see
that monochrome images may be implemented by two MegaWave2 objects: the
memory type <CODE>Cimage</CODE><A NAME="@default107"></A> and the memory type <CODE>Fimage</CODE><A NAME="@default108"></A>.
The first one uses small integers for the gray levels (unsigned char) while the second one uses floating point representation.
Let us say that your algorithm will make additions using the floating point representation: this is the less restrictive choice since integers are reals (and reals are not integers !) and the addition of two integers may exceed the capacity of the unsigned char representation (255).</P><P>Other important questions are &#X201C;what name should I give to the module ?&#X201D;, &#X201C;what group should it belong to?&#X201D;.
Due to the limitation of some standard link editors and archives, we recommend
you choose short names (with no more than 11 characters).
One uses to begin the name with a letter which recalls the memory type of the input: here it will be <CODE>f</CODE> since we use <CODE>Fimage</CODE>.
The remainder should be chosen in order to recall the algorithm, here <CODE>add1</CODE> for example (the letter <CODE>1</CODE> means that variants will be presented).
You may also want to put the module in a group, let us say <CODE>demo</CODE>.</P><P>At this point, we have all the information to write the MegaWave2 header<A NAME="@default109"></A> (please
have a look at the listing page&#XA0;<A HREF="#listing_fadd1">??</A>):
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the line <CODE>/* mwcommand</CODE><A NAME="@default110"></A> tells the MegaWave2 compiler that you begin the header. 
It is enclosed by comments (<CODE>/*</CODE> &#X2026;<CODE>*/</CODE>) since standard C compilers must be able to compile a module.
</LI><LI CLASS="li-itemize">the line <CODE>name = {fadd1};</CODE><A NAME="@default111"></A> defines the name of the module to be <CODE>fadd1</CODE>.
Although this event is not reported as an error, this name must coincide with the name of the module file and with the name of the main function of the module.
</LI><LI CLASS="li-itemize">the line <CODE>author = {"My name"};</CODE><A NAME="@default112"></A> gives the name of the author(s). It will be used for copyrights.
</LI><LI CLASS="li-itemize">the line <CODE>labo = {"My labo with the address"}</CODE><A NAME="@default113"></A> reports the laboratory(ies) where the author(s) belong(s). It will be used for copyrights (this definition is optional. If not set, native laboratory is assumed).
</LI><LI CLASS="li-itemize">the line <CODE>version = {"1.0"};</CODE><A NAME="@default114"></A> indicates the version number of the algorithm (this definition is optional).
</LI><LI CLASS="li-itemize">the line <CODE>function = {"Adds the ... "};</CODE><A NAME="@default115"></A> explains (very) shortly the algorithm.
</LI><LI CLASS="li-itemize">Last, the more important field is the usage. Here,
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>fimage1-&gt;A</CODE> means that <CODE>A</CODE> is an input parameter of the function <CODE>fadd1</CODE> (whose type &#X2014;here <CODE>Fimage</CODE>&#X2014; is given by the C declaration). 
The word <CODE>fimage1</CODE> is the one which will appear in the help and in the documentation (instead of the C word <CODE>A</CODE>).
The string following this declaration explains shortly the meaning of this argument.
</LI><LI CLASS="li-itemize"><CODE>fimage2-&gt;B</CODE> means that <CODE>B</CODE> is also an input parameter of the function.
</LI><LI CLASS="li-itemize"><CODE>result&lt;-C</CODE> means that <CODE>C</CODE> is an output parameter of the function.
</LI></UL>
</LI></UL><P>
To be in concordance with this header, you must edit the module in a file
called <CODE>fadd1.c</CODE> into the directory <CODE>$MY_MEGAWAVE2/src/examples</CODE>.
This module is actually given with the standard distribution and it is located in
<CODE>$MEGAWAVE2/src/examples</CODE>. 
So you can avoid editing it by copying it on your home location <CODE>$MY_MEGAWAVE2/src/examples</CODE>.</P><P>After the MegaWave2 header comes the regular C body.
You must first include the needed standard C files (here <CODE>stdio.h</CODE>)
followed by the MegaWave2 include file (<CODE>mw.h</CODE>).</P><P>The declaration of the main function<A NAME="@default116"></A> (<CODE>fadd1</CODE>) must list all the parameters (and no others) put in the <CODE>usage</CODE> part of the header:
you recognize the three parameters <CODE>A,B,C</CODE>.
The body of this function uses several functions of the system library (all functions of the system library begin with the prefix <CODE>mw</CODE>).
Please see the Volume two: &#X201C;MegaWave2 System Library&#X201D; to get explanations about all these functions.</P><P>The instructions
</P><PRE CLASS="verbatim"> if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");
</PRE><P><A NAME="@default117"></A>
check that the sizes of the two input images <CODE>A</CODE> and <CODE>B</CODE> are the same,
that is, that they have the same number of rows and columns.
If not, a fatal error is sent<A NAME="@default118"></A>, which terminates the module.</P><P>The line
</P><PRE CLASS="verbatim">  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  
</PRE><P><A NAME="@default119"></A>
allocates memory for the output image <CODE>C</CODE>, if <CODE>C</CODE> does not have enough
memory to record a size of (<CODE>A-&gt;nrow,A-&gt;ncol</CODE>).
Indeed, when you write a module, you don&#X2019;t know in which context the module may be executed:
It can be run in the command mode, in which case no memory is allocated for <CODE>C</CODE> (but the C structure by itself) or it can be run as a function in memory
(e.g. call from another module, from an interpreter, &#X2026;) in which case 
<CODE>C</CODE> may have been previously allocated.</P><P>The loop
</P><PRE CLASS="verbatim"> for (x=0;x&lt;A-&gt;ncol;x++) for (y=0;y&lt;A-&gt;nrow;y++)
    {
      a = mw_getdot_fimage(A,x,y);
      b = mw_getdot_fimage(B,x,y);
      mw_plot_fimage(C,x,y,a+b);
    }
</PRE><P>is the main part of the algorithm: 
for each pixel (<I>x</I>,<I>y</I>), we get in <CODE>a</CODE> the gray level of the image <CODE>A</CODE>
and in <CODE>b</CODE> the gray level of the image <CODE>B</CODE><A NAME="@default120"></A>
<A NAME="@default121"></A>.
The last instruction makes the addition <CODE>a+b</CODE> and put the result in the
image <CODE>C</CODE><A NAME="@default122"></A>.</P><P>We show in the following the whole listing of the simple module called <CODE>fadd1</CODE>:
<A NAME="listing_fadd1"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fadd1};
 author = {"My name"};
 labo = {"My labo with the address"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages (for demo #1)"};
 usage = {
   fimage1-&gt;A 
      "Input fimage #1", 
   fimage2-&gt;B
      "Input fimage #2", 
   result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

void fadd1(A,B,C)

Fimage  A,B,C;

{ int x,y;
  float a,b;

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (x=0;x&lt;A-&gt;ncol;x++) for (y=0;y&lt;A-&gt;nrow;y++)
    {
      a = mw_getdot_fimage(A,x,y);
      b = mw_getdot_fimage(B,x,y);
      mw_plot_fimage(C,x,y,a+b);
    }
}

</PRE><P>You are now ready to compile<A NAME="@default123"></A> the module: type under your favorite shell the command:<BR>
<CODE>cmw2 fadd1</CODE><BR>
<A NAME="@default124"></A>
This assumes that you have a standard C compiler called <CODE>cc</CODE>.
If your prefer to use the GNU C compiler, type the command:<BR>
<CODE>cmw2 -gnu fadd1</CODE><BR>
You should get something like the following prints:
</P><PRE CLASS="verbatim">cmw2 fadd1 
 
&gt;&gt;&gt; Welcome on the MegaWave2 Compiler V1.18 &lt;&lt;&lt;
 
  Phase 1 : MegaWave2 preprocessor
fadd1.c :
done.
  Phase 2 : production of sources and objects
          production of document squeleton (doc/demo/fadd1.doc)
          production of arguments analyser object
          production of module object
          add objects to MegaWave2 user library
          production of interface with MegaWave2 interpretor source
          production of interface with MegaWave2 library object
  Phase 3 : production of MegaWave command
          linking MegaWave2 command "fadd1" on hp
     (New command added... Type rehash)

</PRE><P>A lot of errors may occur during this compilation if your installation is not ready.
In that case, please check the installation (see section&#XA0;<A HREF="user_manual003.html#install">2</A>).</P><P>If you didn&#X2019;t get any errors, type <CODE>rehash</CODE> if you are using a C-shell and execute the module in
the command mode by typing <CODE>fadd1</CODE> first without parameters.
You should get something like:

</P><PRE CLASS="verbatim">-------------------------------------------------------------------------------
\\     //  Adds the pixel's gray-levels of two fimages (for demo #1).
 \\   //   
  fadd1    Copyright (C)1998 Jacques Froment. 
 //   \\   MegaWave2 : J.Froment (C)1988-98 CEREMADE, Univ. Paris-Dauphine
//V 1.0\\  and (C)1998-2002 CMLA, ENS Cachan, 94235 Cachan cedex, France.
-------------------------------------------------------------------------------

error : missing 'fimage1'

usage : fadd1 fimage1 fimage2 result

        fimage1 :       Input fimage #1
        fimage2 :       Input fimage #2
        result :        Output image

</PRE><P>
This print recalls you the syntax of the command.
Since you run the module in the command mode, the parameters associated to a MegaWave2 type (<CODE>fimage1 fimage2 result</CODE>) refer to file names.
If you have some favorite image files available, use them for the two requested inputs
<CODE>fimage1 fimage2</CODE>.
If not (or if MegaWave2 cannot read those file formats), type the line:<BR>
<CODE>fadd1 fimage cimage result</CODE><BR>
How MegaWave2 does access to the files <CODE>fimage</CODE> and <CODE>cimage</CODE> ?
If a file is not found in the given path and name (here <CODE>./fimage</CODE> and <CODE>./cimage</CODE>), MegaWave2 tries to resolve the name by reading the directories <CODE>$MY_MEGAWAVE2/data</CODE>
and <CODE>$MEGAWAVE2/data</CODE> and their subdirectories.
For each MegaWave2 internal type, we put in those directories examples of external types.
The name of the file corresponds to the name of the internal type: for example, the file<BR>
<CODE>$MEGAWAVE2/data/PUBLIC/cimage</CODE> contains a monochrome image where the gray levels were recorded using the unsigned char representation, that is the representation of the <CODE>Cimage</CODE> internal type.
You can display this image on your screen by calling the following public module:<BR>
<CODE>cview cimage</CODE><BR>

You may have noticed that we called <CODE>fadd1</CODE> with a parameter (<CODE>cimage</CODE>) which does not match the requested internal type for the C variable <CODE>B</CODE> (a <CODE>Fimage</CODE>).
It doesn&#X2019;t matter since the MegaWave2 library makes the right conversion<A NAME="@default125"></A>.
It is also possible to convert a Fimage into a Cimage although is this case information may
be lost.
Of course some conversions are not supported (e.g. you cannot call <CODE>fadd1</CODE> with a signal as parameter).
Please refer to Volume two: &#X201C;MegaWave2 System Library&#X201D; to learn more about that.</P><P>After the command <CODE>fadd1 fimage cimage result</CODE> has been run, you should get on disk
the new file <CODE>./result</CODE> which records the contents of the C variable <CODE>C</CODE>.
You can display it on the screen by typing:<BR>
<CODE>cview result</CODE><BR>
You may get a warning message like<BR>
<CODE>MegaWave warning (cview) : 27757 Gray levels were out of [0,255].</CODE><BR>
This is because <CODE>cview</CODE> takes a <CODE>Cimage</CODE> as the input, so the gray levels of
<CODE>result</CODE> out of 255 have been thresholded.</P><P>Because <CODE>C</CODE> is a <CODE>Fimage</CODE>, the file <CODE>./result</CODE> has a compatible format 
with the floating point representation.
By default, MegaWave2 uses the same format as the format of the input <CODE>fimage</CODE>
but you can choice the format you want by using the option <CODE>-ftype</CODE><A NAME="@default126"></A>.
Indeed, there are some options in addition to the options you can define in the usage.
Such options are called <B>system&#X2019;s options</B><A NAME="@default127"></A> and one can distinguish them from
<B>user&#X2019;s options</B><A NAME="@default128"></A> since they use more than one letter
(see section&#XA0;<A HREF="user_manual005.html#header_optsys">4.8</A> page&#XA0;<A HREF="user_manual005.html#header_optsys">??</A> for more details).
For example, <CODE>fadd1 -ftype IMG fimage cimage result2</CODE> creates a file
<CODE>result2</CODE> which has the external format <CODE>IMG</CODE>.
This file format uses the unsigned char representation, therefore you get this warning
during the execution of <CODE>fadd1</CODE>:<BR>
<CODE>MegaWave warning (fadd1) : 27757 Gray levels were out of [0,255].</CODE><BR>
But now if you call <CODE>cview result2</CODE>, no more warning appears since thresholding has
been done by <CODE>fadd1</CODE>.</P><P>If you want to print the output image on a PostScript printer<A NAME="@default129"></A>, you should use
the external format <CODE>PS</CODE> instead of <CODE>IMG</CODE>: the file <CODE>result2</CODE>
will contain the image following PostScript format, so you can print it 
using the command <CODE>lp result2</CODE> (on most Unix systems). 
If you don&#X2019;t want to print <CODE>result2</CODE> alone, e.g. if you want to include this
file as an image in a L<sup>A</sup>T<sub>E</sub>X<A NAME="@default130"></A> document, you should use the <CODE>EPSF</CODE> format 
instead of <CODE>PS</CODE>.</P><H2 CLASS="section"><A NAME="toc13"></A><A NAME="htoc24">3.2</A>&#XA0;&#XA0;Some optimizations</H2><P>
<A NAME="start_optim"></A></P><P><A NAME="@default131"></A>
<A NAME="@default132"></A>
The main part of the algorithm in <CODE>fadd1</CODE> uses standard MegaWave2 functions
to access to the pixels<A NAME="@default133"></A>.
Since fast pixel access is critical for image processing, we give in this section two alternatives to speed the execution of the module.
You may find more tips in the Volume two: &#X201C;MegaWave2 System Library&#X201D;, 
at this time keep just in mind that this kind of optimization can be adapted 
to other memory types such signals or movies.</P><P>The first alternative is given by the module <CODE>fadd2</CODE>.
Here is the listing:
<A NAME="listing_fadd2"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fadd2};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages (for demo #2)"};
 usage = {
   fimage1-&gt;A 
      "Input fimage #1", 
   fimage2-&gt;B
      "Input fimage #2", 
   result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

#define _(a,i,j) ((a)-&gt;gray[(j)*(a)-&gt;ncol+(i)])

void fadd2(A,B,C)

Fimage  A,B,C;

{ int x,y;

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (x=0;x&lt;A-&gt;ncol;x++) for (y=0;y&lt;A-&gt;nrow;y++)
    _(C,x,y) = _(A,x,y) + _(B,x,y);
}
</PRE><P>
This module does not really optimize the speed of the execution (the saving is small) but it makes the listing more readable for people:
once you have defined the C macro <CODE>_(a,i,j)</CODE>, you can access to the pixel
(<I>x</I>,<I>y</I>) on an image <CODE>I</CODE> by writing <CODE>_(I,x,y)</CODE> only<A NAME="@default134"></A>.
But be aware that some checking are deconnected in this way: do not exceed the
maximum range for (<I>x</I>,<I>y</I>).</P><P><BR>
</P><P><A NAME="@default135"></A>
The second alternative is given by the module <CODE>fadd3</CODE>.
This one really improves the speed of the execution.
But and unlike the former example, it cannot be used in all algorithms: the
pixel cannot be addressed in random order.
The image has to be read (or written) in the &#X201C;natural&#X201D; order that is,
from up to down and left to right.
Here is the listing:<A NAME="@default136"></A>
<A NAME="listing_fadd3"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fadd3};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages (demo #3)"};
 usage = {
   fimage1-&gt;A 
      "Input fimage #1", 
   fimage2-&gt;B
      "Input fimage #2", 
   result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

void fadd3(A,B,C)

Fimage  A,B,C;

{
  register float *ptr1,*ptr2,*ptr3;
  register int i;

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (ptr1=A-&gt;gray, ptr2=B-&gt;gray, ptr3=C-&gt;gray, i=0;
       i &lt; A-&gt;nrow*A-&gt;ncol; ptr1++, ptr2++, ptr3++, i++)
    *ptr3 = *ptr1 + *ptr2;
}
</PRE><P><BR>
</P><P><A NAME="@default137"></A>
The third alternative is given by the module <CODE>fadd4</CODE>.
The speed of the execution for this module is not so fast that the
one for the previous module <CODE>fadd3</CODE>, but this last method can
be used in any algorithms, even if the pixels are not scanned
in the &#X201C;natural&#X201D; order.
This method consists to allocate, using a MegaWave2 function, a
bi-dimensional tab which is actually an one-dimensional tab of 
pointers, and each pointer points to the beginning of a image&#X2019;s
line<A NAME="@default138"></A>. 
Here is the listing:
<A NAME="listing_fadd4"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fadd4};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages (for demo #4)"};
 usage = {
   fimage1-&gt;A 
      "Input fimage #1", 
   fimage2-&gt;B
      "Input fimage #2", 
   result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

void fadd4(A,B,C)

Fimage  A,B,C;

{ int x,y;
  float **TA,**TB,**TC;

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  if ( ((TA = mw_newtab_gray_fimage(A)) == NULL) ||
       ((TB = mw_newtab_gray_fimage(B)) == NULL) ||
       ((TC = mw_newtab_gray_fimage(C)) == NULL) )
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (x=0;x&lt;A-&gt;ncol;x++) for (y=0;y&lt;A-&gt;nrow;y++)
    TC[y][x] = TA[y][x] + TB[y][x];

  free(TC);
  free(TB);
  free(TA); 
}
</PRE><H2 CLASS="section"><A NAME="toc14"></A><A NAME="htoc25">3.3</A>&#XA0;&#XA0;A little more complex extension</H2><P>
<A NAME="start_ext"></A></P><P><A NAME="@default139"></A>
We give in this section a little more complex extension to our algorithm,
in order to show the easy way in which two modules can communicate.
This will also gives examples of the use of options in the usage.</P><P>You have seen in section&#XA0;<A HREF="#start_simple">3.1</A> that the addition of two floating point images 
may be source of errors when the resulting image has to be converted to the unsigned char 
representation (which may be necessary, for example, when the image has to be displayed).
You may want to control the conversion into the addition module<A NAME="@default140"></A>.
Let us suppose that you want to put an optional thresholding of the output image, which may be preceded by a normalization of the gray levels into a given interval [min,max].</P><P>You have to add in the new module inputs for the boundaries of the interval, and input
for a flag to say whether or not you want the normalization. 
You have therefore to familiarize yourself with the options.</P><P>There is a general rule about the input/output optional parameters<A NAME="@default141"></A> of the module function:
they have to be pointers<A NAME="@default142"></A>. 
If the pointer is <CODE>NULL</CODE> it means that the parameter has not been selected,
if the address is not equal to <CODE>NULL</CODE> it points to an allocated space which may be a scalar or a C structure (in case of MegaWave2 memory type).
Because all MegaWave2 memory types<A NAME="@default143"></A> (e.g. <CODE>Cimage</CODE>, <CODE>Fimage</CODE>, &#X2026;) are pointers to a structure, there is no difference in the type between an optional parameter and a needed parameter.
On the contrary, if the input/output optional parameter is a scalar, say a <CODE>float</CODE>,
it has to be defined has a pointer to a float (<CODE>float *</CODE>).</P><P>A flag<A NAME="@default144"></A> is nothing more than a pointer to any scalar, e.g. a <CODE>char *</CODE>.
In the following version of our module, called <CODE>fadd</CODE>, the flag <CODE>norm</CODE> 
indicates if the normalization has to be computed (see the listing page&#XA0;<A HREF="#listing_fadd">??</A>) : 
</P><PRE CLASS="verbatim">'n'-&gt;norm "Normalize pixel values into [min,max]"+
</PRE><P>The letter <CODE>'n'</CODE> means that, in the command mode, the flag is set when the module
is called with the user option <CODE>-n</CODE>.</P><P>The other options are about the boundaries, let have a look to the first one:
</P><PRE CLASS="verbatim">'m':min-&gt;m0 "Force minimal pixel value",
</PRE><P>There is here an additional term, <CODE>min</CODE>, which says that the option needs a value
when it is selected. 
This value is put into the C variable addressed by <CODE>m0</CODE>.
The word <CODE>min</CODE> is the one which will appear in the help and in the documentation,
instead of the name of the C variable (you can choice the same name).
The string following this declaration explains the meaning of the option.
Everything is similar for the second boundary option:
</P><PRE CLASS="verbatim">'M':max-&gt;m1  "Force maximal pixel value",
</PRE><P>You have of course to update the declaration of the module function, in order to
add the options:
</P><PRE CLASS="verbatim">void fadd(A,B,C,norm,m0,m1)

Fimage  A,B,C;
char *norm;
float *m0,*m1;
</PRE><P>When the <CODE>-n</CODE> option is not selected, it should be possible to give only one boundary of the interval [min,max].
Indeed, the threshold may be done only in one side.
But when the user ask for the normalization, both <CODE>-m</CODE> and <CODE>-M</CODE> options must
be selected.
So you need to check that somewhere.
It is not possible to put this information in the header (we could do that but the header&#X2019;s grammar would be horrible), but you can add the verification in the beginning of the function:
</P><PRE CLASS="verbatim">  if (norm &amp;&amp; (!m0 || !m1)) mwerror(USAGE,0,
            "Normalization needs selection of [min,max] values\n");
</PRE><P>We call the function <CODE>mwerror</CODE><A NAME="@default145"></A> with the argument 
<CODE>USAGE</CODE><A NAME="@default146"></A> 
to tell MegaWave2 that this error is about the usage.</P><P>The normalization and thresholding process is called by the last line:
</P><PRE CLASS="verbatim">  if (m0 || m1) fthre(C,C,norm,m0,m1);
</PRE><P>Where is the function <CODE>fthre</CODE> defined ?
Since it is not a function of the system library (it doesn&#X2019;t begin with <CODE>mw</CODE>),
and because this function is not defined in the module, it should be the main function
of another module.
We could have put the computations into <CODE>fadd</CODE>, but by creating another module we
offer the possibility to directly use the command <CODE>fthre</CODE> in other contexts.
In addition, other modules may want to make normalization or thresholding so the code
will not be duplicated.
Such a (well-known) &#X201C;philosophy of overlapped black boxes&#X201D; saves space and time, it is
one of the important aspect of MegaWave2:
if your mathematical algorithm may be decomposed into several independant algorithms, write one module per algorithm.</P><P>Now we rapidly study the module <CODE>fthre</CODE>.
You should refer to the listing page&#XA0;<A HREF="#listing_fthre">??</A>.
The header of <CODE>fthre</CODE> is copied from the one of <CODE>fadd</CODE>, but there is
only one input image instead of two.
Please notice that the output image (the C variable <CODE>B</CODE>) is a priori not the same
as the input image <CODE>A</CODE>.
This allows to call <CODE>fthre</CODE> from a module which needs to keep the original image.
But you can force <CODE>fthre</CODE> to use the same variable for the input and the output,
by calling it with twice the same variable: that is what we do in <CODE>fadd</CODE>.
In this way, you save memory since the instruction<A NAME="@default147"></A>
</P><PRE CLASS="verbatim">  if ((B = mw_change_fimage(B,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  
</PRE><P>won&#X2019;t allocate any memory (<CODE>A</CODE> = <CODE>B</CODE> and therefore <CODE>B</CODE> has the gray
plane already allocated for the requested size).</P><P>Here is the listing of the addition module <CODE>fadd</CODE>.
It is a public module put into the group <CODE>common/float_image</CODE>:
<A NAME="listing_fadd"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module  -----------------------------*/
/* mwcommand
 name = {fadd};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages"};
 usage = {
 'n'-&gt;norm "Normalize pixel values into [min,max]",
 'm':min-&gt;m0 "Force minimal pixel value",
 'M':max-&gt;m1  "Force maximal pixel value",
 fimage1-&gt;A 
   "Input fimage #1", 
 fimage2-&gt;B
   "Input fimage #2", 
 result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

void fadd(A,B,C,norm,m0,m1)

Fimage  A,B,C;
char *norm;
float *m0,*m1;

{
  register float *ptr1,*ptr2,*ptr3;
  register int i;

  if (norm &amp;&amp; (!m0 || !m1)) mwerror(USAGE,0,
            "Normalization needs selection of [min,max] values\n");

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (ptr1=A-&gt;gray, ptr2=B-&gt;gray, ptr3=C-&gt;gray, i=0;
       i &lt; A-&gt;nrow*A-&gt;ncol; ptr1++, ptr2++, ptr3++, i++)
    *ptr3 = *ptr1 + *ptr2;

  if (m0 || m1) fthre(C,C,norm,m0,m1);
}

</PRE><P>Here is the listing of the threshold module <CODE>fthre</CODE>.
It is a public module put into the group <CODE>common/float_image</CODE>:
<A NAME="listing_fthre"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fthre};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Threshold the pixel's gray-levels of a fimage"};
 usage = {
 'n'-&gt;norm    "Normalize pixel values into [min,max]",
 'm':min-&gt;m0  "Force minimal pixel value",
 'M':max-&gt;m1  "Force maximal pixel value",
 fimage-&gt;A    "Input fimage", 
 result&lt;-B    "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include  "mw.h"

void fthre(A,B,norm,m0,m1)

Fimage  A,B;
char *norm;
float *m0,*m1;

{
  register float *ptr;
  register int i;
  float min,max,a,b;
  
  if (!m0 &amp;&amp; !m1) mwerror(USAGE,0,"At least min or max pixel value requested\n");
  if (norm &amp;&amp; (!m0 || !m1)) mwerror(USAGE,0,"Normalization needs selection of [min,max] values\n");
  if (m0 &amp;&amp; m1 &amp;&amp; (*m1 &lt;= *m0)) mwerror(USAGE,0,"Illegal values of [min,max]\n");

  if ((B = mw_change_fimage(B,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  
  
  mw_copy_fimage(A,B);  /* Copy pixel values of A into B */

  if (norm)  /* Normalization */
    {
      min=1e20; max=-min;
      for (ptr=B-&gt;gray, i=0;  i &lt; B-&gt;nrow*B-&gt;ncol; ptr++, i++) 
        {
          if (*ptr &lt; min) min=*ptr;
          if (*ptr &gt; max) max=*ptr;
        }
      if (fabs((double) max-min) &lt;= 1e-20)
        mwerror(FATAL,1,"Cannot normalize: constant input image\n");
      a = (*m1-*m0)/(max-min);
      b = *m0 - a * min;
      for (ptr=B-&gt;gray, i=0;  i &lt; B-&gt;nrow*B-&gt;ncol; ptr++, i++) 
        *ptr = a * *ptr + b;
    }

  /* Thresholding */
  if (m0) for (ptr=B-&gt;gray, i=0;  i &lt; B-&gt;nrow*B-&gt;ncol; ptr++, i++)
    if (*ptr &lt; *m0) *ptr=*m0;
  if (m1) for (ptr=B-&gt;gray, i=0;  i &lt; B-&gt;nrow*B-&gt;ncol; ptr++, i++)
    if (*ptr &gt; *m1) *ptr=*m1;
}

</PRE><P>In order to make a run-time executable for the module <CODE>fadd</CODE>, you have
to take the following precaution:
when you want to compile<A NAME="@default148"></A> a module <CODE>X</CODE> (here <CODE>fadd</CODE>) which call the function of 
another module 
<CODE>Y</CODE> (here <CODE>fthre</CODE>), be sure to compile <CODE>Y</CODE> before <CODE>X</CODE>.
If you don&#X2019;t, you may get this kind of message during the compilation of <CODE>X</CODE>:
</P><PRE CLASS="verbatim">  Phase 3 : production of MegaWave command
          linking MegaWave2 command "X" on hp
/bin/ld: Unsatisfied symbols:
   Y (code)
          Error : exit.
</PRE><P>There is an eviler possibility: if you change the content of the module <CODE>Y</CODE>, think
to recompile <CODE>X</CODE> after <CODE>Y</CODE> (no message will be displayed if you forget that).
Therefore, a good habit is to recompile all your modules from time to time
(use the macro <CODE>cmw2_all</CODE><A NAME="@default149"></A> for that).
You may also use the Unix <EM>make</EM> utility.
</P><HR>
<A HREF="user_manual003.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="user_manual005.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
</BODY>
</HTML>
