<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="user_manual.css">
<TITLE>Module&#X2019;s header</TITLE>
</HEAD>
<BODY >
<A HREF="user_manual004.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="user_manual006.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc26">Chapter&#XA0;4</A>&#XA0;&#XA0;Module&#X2019;s header</H1><UL>
<LI><A HREF="user_manual005.html#toc15">Syntax</A>
</LI><LI><A HREF="user_manual005.html#toc16">Options</A>
</LI><LI><A HREF="user_manual005.html#toc17">Needed arguments</A>
</LI><LI><A HREF="user_manual005.html#toc18">Optional arguments</A>
</LI><LI><A HREF="user_manual005.html#toc19">Variable arguments</A>
</LI><LI><A HREF="user_manual005.html#toc20">Unused arguments</A>
</LI><LI><A HREF="user_manual005.html#toc21">Examples of headers</A>
</LI><LI><A HREF="user_manual005.html#toc22">System&#X2019;s options</A>
</LI></UL>
<P>
<A NAME="header"></A>
</P><H2 CLASS="section"><A NAME="toc15"></A><A NAME="htoc27">4.1</A>&#XA0;&#XA0;Syntax</H2><P>
<A NAME="header_syntax"></A></P><P>Any module begins with a MegaWave2 header<A NAME="@default150"></A>.
Such header is a set of statements enclosed between 
<CODE>/* mwcommand</CODE><A NAME="@default151"></A> and <CODE>*/</CODE>.</P><P>There are some restrictions :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
no C code nor C preprocessor instructions (<CODE>#include</CODE>, 
<CODE>#define</CODE>, &#X2026;) must be present before the MegaWave2 header,
</LI><LI CLASS="li-itemize">no C comments inside the MegaWave2 header.
</LI></UL><P>The following sections describes the statements which are used in 
the MegaWave2 header.</P><P>Needed statements<A NAME="@default152"></A> are :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>name</CODE>,
</LI><LI CLASS="li-itemize"><CODE>author</CODE>,
</LI><LI CLASS="li-itemize"><CODE>function</CODE>,
</LI><LI CLASS="li-itemize"><CODE>usage</CODE>,
</LI><LI CLASS="li-itemize"><CODE>version</CODE>.</LI></UL><P>Optional statements<A NAME="@default153"></A> are :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>labo</CODE>,
</LI><LI CLASS="li-itemize"><CODE>group</CODE>.
</LI></UL><H3 CLASS="subsection"><A NAME="htoc28">4.1.1</A>&#XA0;&#XA0;Name Statement</H3><P>
<A NAME="@default154"></A></P><P><B>Syntax :</B> <CODE>name = {</CODE><EM>C_name</EM><CODE>};</CODE></P><P><B>Description :</B> gives the name of the C module and the name of the 
run-time command; <EM>C_name</EM> must follow the C identifier syntax.
The file name of the module must be the same, but it is followed by the extension <CODE>.c</CODE>.</P><P><B>Example :</B> <CODE>name = {bigtest};</CODE></P><H3 CLASS="subsection"><A NAME="htoc29">4.1.2</A>&#XA0;&#XA0;Author Statement</H3><P>
<A NAME="@default155"></A></P><P><B>Syntax :</B> <CODE>author = { "</CODE><EM>author name</EM><CODE>, </CODE> <EM>author 
name</EM> <CODE>, ... "};</CODE></P><P><B>Description :</B> sets the list of author names; each author name 
must be separated by a comma.
These list (not the author name) is enclosed between quotes; it is
used to insert copyright in the run-time command and in the
module documentation.</P><P><B>Example :</B> <CODE>author = {"A.Turing, J. Von Neumann"};</CODE></P><H3 CLASS="subsection"><A NAME="htoc30">4.1.3</A>&#XA0;&#XA0;Function Statement</H3><P>
<A NAME="@default156"></A></P><P><B>Syntax :</B> <CODE>function = { "</CODE><EM>sentence</EM><CODE>"};</CODE></P><P><B>Description :</B> Explains shortly the function of the module; 
this statement contains one string enclosed between quote.
It is used every time a short help is requested.</P><P><B>Example :</B> <CODE>function = { "Return 1 if a MegaWave2 module is useful, 0 elsewhere" };</CODE></P><H3 CLASS="subsection"><A NAME="htoc31">4.1.4</A>&#XA0;&#XA0;Labo Statement</H3><P>
<A NAME="@default157"></A></P><P><B>Syntax :</B> <CODE>labo = { "</CODE><EM>Laboratory name and address </EM><CODE>"};</CODE></P><P><B>Description :</B> sets the name of the laboratory (or firm) from which the authors
are issued, followed by the address. 
This statement contains one string enclosed between quote.
Several laboratories may be put in the same string.
This string is used to insert copyright in the run-time command and in the
module documentation.</P><P><B>Example :</B> <CODE>labo = { "Babbage Inc. 2001 W 99th St. NY New York 10021, USA"};</CODE></P><P>This statement is an optional statement. 
If not set, a default laboratory is used for the copyright
(the one from which MegaWave2 is issued).</P><H3 CLASS="subsection"><A NAME="htoc32">4.1.5</A>&#XA0;&#XA0;Group Statement</H3><P>
<A NAME="@default158"></A></P><P><B>Syntax :</B> <CODE>group = { "</CODE> <EM>group name</EM> <CODE>"};</CODE></P><P><B>Description :</B> sets the group name in which the module belongs; 
a group is a word that follows UNIX file naming syntax (including an
optional path).</P><P><B>Example :</B> <CODE>group = {"autoref/tests"};</CODE>
Here, <CODE>tests</CODE> is a subgroup included in the main group <CODE>autoref</CODE>.</P><P>This statement is an optional statement.
If not set, the default group is given by the location of the module file
into the directory <CODE>$MY_MEGAWAVE2/src</CODE>.
If set, it must match this location.
Since MegaWave2 versions 2.x, use of this statement is no more recommended.
It is still available for backward compatibility only.</P><H3 CLASS="subsection"><A NAME="htoc33">4.1.6</A>&#XA0;&#XA0;Version Statement</H3><P>
<A NAME="@default159"></A></P><P><B>Syntax :</B> <CODE>version = { "</CODE> <EM>version </EM> <CODE>"};</CODE></P><P><B>Description :</B> sets the version of the module.
Each time you modify the module file you should increment this number.</P><P><B>Example :</B> <CODE>version = { "1.00"};</CODE></P><P>Since MegaWave2 versions 2.x, this statement is no more optional.</P><H3 CLASS="subsection"><A NAME="htoc34">4.1.7</A>&#XA0;&#XA0;Usage Statement</H3><P>
<A NAME="@default160"></A></P><P><B>Syntax :</B> <CODE>usage = { </CODE> <EM>usage specification list</EM> <CODE>};</CODE></P><P><B>Description :</B> describes the module interface for a call by the run-time command.
An usage specification is made by an argument declaration followed by space and a quoted string; 
the quoted string is a description of the corresponding argument.
The usage specifications are separated by a comma.
Therefore, an extended description of the syntax may be:
</P><PRE CLASS="verbatim">usage = { arg_1 "string_1",
          arg_2 "string_2",
              ...
          arg_n "string_n"
        };
</PRE><P>There are five types of argument declaration:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<B>options</B><A NAME="@default161"></A><A NAME="@default162"></A> : 
they are optional parameters, which are selected by
putting in the command line a <CODE>-</CODE> followed by any printable character
(but <CODE>?</CODE>). These character defines the option.
Unix uses such options for its commands, as the option <CODE>-a</CODE> (list all entries) of the command <CODE>ls</CODE>.
Options are always placed before needed arguments.</LI><LI CLASS="li-enumerate"><B>needed arguments </B><A NAME="@default163"></A> : they are needed parameters, as the Unix
command <CODE>write</CODE> has a needed arguments (which is a user name).
Any module must define at least one needed argument.</LI><LI CLASS="li-enumerate"><B>optional arguments</B><A NAME="@default164"></A> : it is a list of parameters which is used entirely or is not used at all (you cannot use some of the arguments of this list and don&#X2019;t use the others);
this list is put between <CODE>{</CODE> and <CODE>}</CODE> and is always placed after needed arguments.</LI><LI CLASS="li-enumerate"><B>variable argument</B><A NAME="@default165"></A> : this argument corresponds to a list of undefined length, the module loops on all arguments of the list;
it is always placed after needed arguments;
You cannot define for the same module optional and variable arguments.</LI><LI CLASS="li-enumerate"><B>unused arguments</B><A NAME="@default166"></A> : this list describes the parameters of the module function which are not used as arguments in the command mode.
This list should be put at the end of the declaration.
</LI></OL><P>The corresponding C variables (which are defined in the module function) 
can be of scalar type (<CODE>short</CODE>, <CODE>int</CODE>, <CODE>long</CODE>, <CODE>unsigned short</CODE>, <CODE>unsigned int</CODE>, <CODE>unsigned long</CODE>, <CODE>float</CODE>, <CODE>double</CODE>) 
or of MegaWave2 type (a pointer to a structure, see the Volume two: &#X201C;MegaWave2 System Library&#X201D; for a list of all available MegaWave2 types).</P><P>The common description for the usage specification is the following: 
<EM>H name</EM> <CODE>-&gt;</CODE> or <CODE>&lt;-</CODE> <EM>C name</EM>. 
The right arrow <CODE>-&gt;</CODE> describes an input flow and the left arrow
<CODE>&lt;-</CODE> describes an output flow. </P><P>The word <EM>H name</EM> contains the name of the argument which is
used by Human being (e.g. used in the help, in the documentation)
The word <EM>C name</EM> contains the name of the C variable used 
in the module body.
One can choice to give to <EM>H name</EM> and <EM>C name</EM> the same word.</P><P>The syntax for each type of argument declaration is described in the 
next sections&#XA0;<A HREF="#header_options">4.2</A> to&#XA0;<A HREF="#header_unused-arg">4.6</A>.
We write by <TT>H_id</TT> any word of type <EM>H name</EM> and by
<TT>C_id</TT> any word of type <EM>C name</EM>.</P><H2 CLASS="section"><A NAME="toc16"></A><A NAME="htoc35">4.2</A>&#XA0;&#XA0;Options</H2><P>
<A NAME="header_options"></A>
<A NAME="@default167"></A></P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;&#X2212;&gt;<TT>C_id</TT></B>  
</P><P> (where &#X2019;c&#X2019; is a character) defines a flag option (i.e. an option without value); <TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. char *). 
The flag has been set by the user if and only if <TT>C_id</TT> &#X2260; <TT>NULL</TT>.</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:<TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> (where &#X2019;c&#X2019; is a character) defines an option with input value.
The flag has been set by the user if and only if <TT>C_id</TT> &#X2260; <TT>NULL</TT>.
If <TT>C_id</TT> &#X2260; <TT>NULL</TT>, the value of the option is given by <TT>*C_id</TT>.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>),
in this case its value is defined in the command line by writting the
number (or character) on the terminal,
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>),
in this case its value is given by writting the file name on the terminal.</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:[<TT>H_id</TT>  = <TT>Val</TT>]&#X2212;&gt;<TT>C_id</TT></B>  
</P><P>
defines an option with default input value.
This case is similar to the former, but when the option is not set by the user
then <TT>*C_id</TT>= <TT>Val</TT> that is, one can never have <TT>C_id</TT> = <TT>NULL</TT>.
MegaWave2 types are not allowed.
<TT>Val</TT> must be a constant of same type than <TT>C_id</TT>.
Warning: no implicit conversions are made (e.g. if <TT>C_id</TT> is of type <CODE>float</CODE>, <TT>Val</TT> =1.0 is allowed but not <TT>Val</TT> =1).</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:<TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P>
defines an option with input value and with interval checking 
(an error is send if the input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:[<TT>H_id</TT>  = <TT>Val</TT>] &#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P>
defines an option with default input value and with interval checking.</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:<TT>H_id</TT>  &lt;&#X2212;<TT>C_id</TT></B>  
</P><P> 
(where &#X2019;c&#X2019; is a character) defines an option with output value.
The flag has been set by the user if and only if <TT>C_id</TT> &#X2260; <TT>NULL</TT>.
If <TT>C_id</TT> &#X2260; <TT>NULL</TT>, MegaWave2 writes the output value at the end of the module
from the content of <TT>*C_id</TT>.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>)
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>).
In this last case and if <TT>C_id</TT> &#X2260; <TT>NULL</TT>, you must allocate the
structure to the right size using functions of the system library,
before doing any computation with this variable (see Volume two: &#X201C;MegaWave2 System Library&#X201D;).</P><P>Restriction: <TT>C_id</TT> cannot be a function (return value of the module), 
whereas this is allowed with needed arguments (see section&#XA0;<A HREF="#header_needed-arg">4.3</A>).</P><H2 CLASS="section"><A NAME="toc17"></A><A NAME="htoc36">4.3</A>&#XA0;&#XA0;Needed arguments</H2><P>
<A NAME="header_needed-arg"></A>
<A NAME="@default168"></A>
<A NAME="@default169"></A></P><P> <BR>
<BR>
<B><TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines a needed argument with input value.
<TT>C_id</TT> is a C variable of scalar type (e.g. <CODE>char</CODE>),
in this case its value is defined in the command line by writting the
number (or character) on the terminal,
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>),
in this case its value is given by writting the file name on the terminal.
In the body of the module function, you are sure to be able to access
to the content of this variable.
Do not perform any deallocation on it, since MegaWave2 may try to access it
after the end of the module.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT>[<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P> 
defines a needed argument with input value and with interval checking 
(an error is send if the input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &lt;&#X2212;<TT>C_id</TT></B>  
</P><P>
defines a needed argument with output value.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>)
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>).
It can be also the return of the module (e.g. <TT>H_id</TT> &lt;&#X2212;<CODE>fentropy</CODE>
if <CODE>fentropy</CODE> is the module function which returns a value of the same type than <TT>C_id</TT>),
although this form is not always recommanded when the return value is a
MegaWave2 object (since the structure has to be allocated at each call to
the module). 
The pointer <TT>C_id</TT> can never be <CODE>NULL</CODE> (MegaWave2 allocates space for the
value, if needed).
If <TT>C_id</TT> is of MegaWave2 type, you must allocate the
structure to the right size using functions of the system library,
before doing any computation with this variable (see Volume two: &#X201C;MegaWave2 System Library&#X201D;).
MegaWave2 writes the output value at the end of the module
from the content of <TT>*C_id</TT>.</P><P>Caution: when <TT>C_id</TT> is a pointer to a scalar, there is no number (nor character) to write in the command line, and therefore these needed argument is virtual
(it does not appear in the usage print).</P><H2 CLASS="section"><A NAME="toc18"></A><A NAME="htoc37">4.4</A>&#XA0;&#XA0;Optional arguments</H2><P>
<A NAME="header_optional-arg"></A>
<A NAME="@default170"></A></P><P>The definition of optional arguments and needed arguments differs only
in the fact that the first are enclosed into <CODE>{</CODE> and <CODE>}</CODE>.
In addition, optional arguments must be defined after needed arguments.
When they are several optional arguments, they are linked in the sense
that the selection of the first leads the need of the selection of the others.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines an optional argument with input value.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>),
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>).
If <TT>C_id</TT> = <TT>NULL</TT>, then the argument has not been selected.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P> 
defines an optional argument with input value and with interval checking 
(an error is send if the input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B>[<TT>H_id</TT>  = <TT>Val</TT>] &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines an optional argument with default input value.
When the argument is not set by the user then <TT>*C_id</TT>= <TT>Val</TT> that is, one 
can never have <TT>C_id</TT> = <TT>NULL</TT>.
MegaWave2 types are not allowed.
<TT>Val</TT> must be a constant of same type than <TT>C_id</TT>.
Warning: no implicit conversions are made (e.g. if <TT>C_id</TT> is of type <CODE>float</CODE>, <TT>Val</TT> =1.0 is allowed but not <TT>Val</TT> =1).</P><P> <BR>
<BR>
<B>[<TT>H_id</TT>  = <TT>Val</TT> ] &#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P> 
defines an optional argument with input value and with interval checking 
(an error is send if the input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &lt;&#X2212;<TT>C_id</TT></B>  
</P><P>
defines an optional argument with output value.
The argument has been given by the user if and only if <TT>C_id</TT> &#X2260; <TT>NULL</TT>.
If <TT>C_id</TT> &#X2260; <TT>NULL</TT>, MegaWave2 writes the output value at the end of the module
from the content of <TT>*C_id</TT>.
<TT>C_id</TT> is a C variable of MegaWave2 type only (e.g. <CODE>Cmovie</CODE>).
If <TT>C_id</TT> &#X2260; <TT>NULL</TT>, you must allocate the
structure to the right size using functions of the system library,
before doing any computation with this variable (see Volume two: &#X201C;MegaWave2 System Library&#X201D;).</P><P>Restriction: <TT>C_id</TT> cannot be a function (return value of the module), 
whereas this is allowed with needed arguments (see section&#XA0;<A HREF="#header_needed-arg">4.3</A>).</P><H2 CLASS="section"><A NAME="toc19"></A><A NAME="htoc38">4.5</A>&#XA0;&#XA0;Variable arguments</H2><P>
<A NAME="header_variable-arg"></A>
<A NAME="@default171"></A></P><P> <BR>
<BR>
<B>&#X2026;&#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines variable arguments with input values.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>),
in this case its successive values are defined in the command line by writting the numbers (or characters) on the terminal,
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>),
in this case its successive values are given by writting the file names on the terminal.
The module function is call as many time as the number of variable parameters given in the command line.
If no variable parameters are given, the module function is called only once
with <TT>C_id</TT> = <TT>NULL</TT>.</P><P> <BR>
<BR>
<B>&#X2026;&#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P>
defines variable arguments with input values and with interval checking 
(an error is send if one input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B>&#X2026;&lt;&#X2212;<TT>C_id</TT></B>  
</P><P> 
defines variable arguments with output values.
<TT>C_id</TT> is a C variable of MegaWave2 type only (e.g. <CODE>Cmovie</CODE>): its successive values will be put in the files whose names are written on the terminal.
The module function is call as many time as the number of variable parameters given in the command line.
If no variable parameters are given, the module function is called only once
with <TT>C_id</TT> = <TT>NULL</TT>.</P><P>Restriction: <TT>C_id</TT> cannot be a function (return value of the module), 
whereas this is allowed with needed arguments (see section&#XA0;<A HREF="#header_needed-arg">4.3</A>).</P><H2 CLASS="section"><A NAME="toc20"></A><A NAME="htoc39">4.6</A>&#XA0;&#XA0;Unused arguments</H2><P>
<A NAME="header_unused-arg"></A>
<A NAME="@default172"></A> </P><P> <BR>
<BR>
<B><TT>notused</TT> &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines an argument which is not used in the command line mode.
We have always <TT>C_id</TT> = <TT>NULL</TT> when the module function is called
in the command line mode.
Therefore, a value &#X2260; <TT>NULL</TT> means a call from the library.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <TT>char *</TT>),
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>).</P><P>Remarks: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The notation &#X2212;&gt; does not mean here that the argument is an input argument.
</LI><LI CLASS="li-itemize">The word <B><CODE>notused</CODE></B> being a keyword, you cannot use it elsewhere.
</LI><LI CLASS="li-itemize">Unused arguments should be put at the end of the usage declaration.
</LI></UL><H2 CLASS="section"><A NAME="toc21"></A><A NAME="htoc40">4.7</A>&#XA0;&#XA0;Examples of headers</H2><P>
<A NAME="header_examples"></A></P><P>We give in the following the source of several modules, which were written in 
order to show the various possibilities of the header&#X2019;s syntax.
All of these modules are available with the public distribution, in the
directory <CODE>$MEGAWAVE2/src/demo</CODE>.</P><H3 CLASS="subsection"><A NAME="htoc41">4.7.1</A>&#XA0;&#XA0;Use of options</H3><P>
<A NAME="header_examples_options"></A></P><P><A NAME="@default173"></A>
The module <CODE>demohead1</CODE> demonstrates all the different kinds of options.
It uses also two needed arguments, one in input (a scalar with interval 
checking) and one in output (a MegaWave2 type).</P><P>Notice that the output variable (a <CODE>Cimage</CODE>) is not a parameter of
the module function: it is notified to the mother procedure using the
return value of the module.
This form is not recommended since it leads to allocate memory for the
<CODE>Cimage</CODE> at each call to the module.
The recommended form is to put the variable as a regular parameter of
the module function, so the variable is allocated by a call to <CODE>mw_change_cimage(output,nrow,ncol)</CODE> only if no previously memory allocation was done. </P><PRE CLASS="verbatim"> 
/*----------------------------- MegaWave Module -----------------------------*/
/* mwcommand
  name = {demohead1};
  version = {"1.0"};
  author = {"Jacques Froment"};
  function = {"Demo of MegaWave2 header - #1 : options -"};
  usage = {
  'a'-&gt;flg                   
     "Flag -option-",
  'B':cimage_input_opt -&gt; B
     "Input MegaWave2 type (cimage) -option-", 
  'c':[c_opt=1.0] -&gt; c
     "Input scalar (float) with default value -option-",
  'd':d_opt -&gt; d          [-10,10] 
     "Input scalar (integer) with boundary -option-",
  'e':[e_opt=0.0] -&gt; e    [0.0,1e20] 
     "Input scalar (double) with default value and boundary -option-",
  'F':f_opt &lt;- F
     "Output MegaWave2 type (cimage) -option-",

  float_input -&gt; input    [-1.0,1.0]
     "Input scalar (float) with boundary -needed argument-",

  cimage_output&lt;-demohead1      
     "Output MegaWave2 type (cimage) -needed argument-"
           };
*/
/*---------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;

/* Include always the MegaWave2 Library */
#include "mw.h"

Cimage demohead1(flg,B,c,d,e,F,input)

char *flg;   /* Or int *flg, ... */
Cimage B;    /* You don't need *B since Cimage is of MegaWave2 type (pointer)*/
float *c;    /* You need *c since float is a scalar (not a pointer) */
int *d;      /* You need *d since int is a scalar (not a pointer) */
double *e;   /* You need *e since double is a scalar (not a pointer) */
Cimage F;    /* You don't need *F since Cimage is of MegaWave2 type */
float input; /* You don't need any pointer since it's a needed input */


{
  Cimage output;  /* return of the module */
  
  if (flg) printf("flg flag active\n"); else printf("flg flag not active\n");

  /* B may be NULL */
  if (B) 
    {
      printf("Optional input B image selected\n"); 
      /* Here you can access to the content of the image B
         ...
       */
    }
  else 
    {
      printf("No B image selected\n");
      /* Do not access to B */
    }


  /* c cannot be NULL since *c has a default value */
  printf("*c = %f\n",*c);


  /* d may be NULL */
  if (d) printf("*d = %d\n",*d); else printf("No d value\n");
    
  /* e cannot be NULL since *e has a default value */
  printf("*e = %lf\n",*e);

  /* F may be NULL */
  if (F)
    {
      printf("Optional output F image selected\n");
      /* Here you can compute the image F, after dimensioning.  
      */      
      F = mw_change_cimage(F,10,10); /* for a size of (10,10) */
      if (F == NULL) mwerror(FATAL,1,"Not enough memory\n");
      /*
         ...
      */
    }
  else printf("No optional output F selected\n");

  /* Needed scalar argument is not a pointer */
  printf("input = %f\n",input);

  /* We need to create the structure and to allocate the output image */
  /* - In this example the size is (1,1) */  
  output = mw_change_cimage(NULL,1,1);
  if (output == NULL) mwerror(FATAL,1,"Not enough memory\n");

  /* Here you can compute the image output 
     ...
  */  

  return(output);
}
</PRE><H3 CLASS="subsection"><A NAME="htoc42">4.7.2</A>&#XA0;&#XA0;Use of optional arguments</H3><P>
<A NAME="header_examples_optarg"></A></P><P><A NAME="@default174"></A>
With the module <CODE>demohead2</CODE>, we show the use of optional arguments.
This module defines also a needed output argument (a scalar).</P><PRE CLASS="verbatim"> 
/*----------------------------- MegaWave Module -----------------------------*/
/* mwcommand
  name = {demohead2};
  version = {"1.0"};
  author = {"Jacques Froment"};
  function = {"Demo of MegaWave2 header - #2 : optional arguments -"};
  usage = {

  output0 &lt;- out0    
     "Output scalar (int) -needed argument-",

     {
     [input0=1]  -&gt; in0 [-5,5]
       "Input scalar (int) with default value and boundary - optional argument -",
     input1 -&gt; in1 
       "Input scalar (float) - optional argument -",
     output1 &lt;- out1
       "Output MegaWave2 type (cimage) - optional argument -"
     }
           };
*/
/*---------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;

/* Include always the MegaWave2 Library */
#include "mw.h"

void demohead2(out0,in0,in1,out1)

int *out0;    /* You need a pointer since it's an output */
int *in0;     /* You need a pointer since it's an optional argument */
float *in1;   /* You need a pointer since it's an optional argument */
Cimage out1;  /* out1 is already a pointer since it's of MegaWave2 type */

{
  /* out0 cannot be NULL */
  *out0 = 3;

  /* in0 cannot be NULL */
  printf("*in0 = %d\n",*in0);

  /* in1 may be NULL */
  if (in1) printf("*in1 = %f\n",*in1); else printf("No in1 value\n");

  /* out1 may be NULL */
  if (out1) 
    {
      /* Here you can compute out1, after dimensionning */
      out1 = mw_change_cimage(out1,10,10); /* for a size of (10,10) */
      if (out1 == NULL) mwerror(FATAL,1,"Not enough memory\n");
      /*
         ...
      */
    }
  else printf("No optional output image out1\n");

}
</PRE><H3 CLASS="subsection"><A NAME="htoc43">4.7.3</A>&#XA0;&#XA0;Use of variable and unused arguments</H3><P>
<A NAME="header_examples_var-unused"></A></P><P><A NAME="@default175"></A>
The module <CODE>demohead3</CODE> shows the use of variable arguments.
It includes also one unused argument, <CODE>Win</CODE>, which is a pointer to a 
scalar.
The type of this argument should be <CODE>Wframe</CODE>, a pointer to a window structure
(See the Volume two: &#X201C;MegaWave2 System Library&#X201D; about the Wdevice library).
But <CODE>Wframe</CODE> is not a MegaWave2 object, therefore this type cannot be
used in the header. By casting the variable in the call to <CODE>demohead3</CODE>, one can define <CODE>Win</CODE> as a pointer to any scalar.</P><P>Notice that the variable <CODE>Output</CODE> is of type <CODE>Cimage *</CODE>; it is therefore
a pointer of pointer.
Why ? this is not requested by the MegaWave2 header, but by the last instruction<BR>
<CODE>*Output = Input;</CODE><BR>
This instruction changes the address pointed out by <CODE>*Output</CODE>.
If <CODE>Output</CODE> was of type <CODE>Cimage</CODE>, the instruction<BR>
<CODE>Output = Input;</CODE><BR>
would change the address inside the module function only, not outside.
With <CODE>Output</CODE> of type <CODE>Cimage</CODE>, the only solution is to copy the
content of <CODE>Input</CODE> into <CODE>Output</CODE> (using the function <CODE>mw_copy_cimage()</CODE>).</P><PRE CLASS="verbatim"> 
/*----------------------------- MegaWave Module -----------------------------*/
/* mwcommand
  name = {demohead3};
  version = {"1.0"};
  author = {"Jacques Froment"};
  function = {"Demo of MegaWave2 header - #3: variable and notused arguments -"};
  usage = {
    A-&gt;Input            "Input (could be a cimage)",
    ...&lt;-Output         "Output (copy of the input)",
    notused -&gt; Win      "Window (internal use only)" 
          };
*/
/*---------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;

/* Include always the MegaWave2 Library */
#include "mw.h"

/* Include the window since we use windows facility */
#include "window.h" 

void demohead3(Input,Output,Win)

Cimage Input;
Cimage *Output;  /* Here we define *Output since the function changes the  */
                 /* pointer value (we set bellow *Output = Input)          */

char *Win;       /* Should be "Wframe *Win" for a MegaWave2 window         */
                 /* BUG: We cannot use other type than scalar or MegaWave2 */
                 /* Don't forget to cast before the function call          */
{
  if (Win != NULL)
    {
      printf("Library call: passing Window ptr\n");
      /*
         ...
      */
    }
  else printf("Command call: no Window ptr\n");

  if (*Output == NULL) printf("No output requested !\n");
  else 
    *Output = Input;  
}
</PRE><H2 CLASS="section"><A NAME="toc22"></A><A NAME="htoc44">4.8</A>&#XA0;&#XA0;System&#X2019;s options</H2><P>
<A NAME="header_optsys"></A></P><P>The options defined in the header&#X2019;s module (see section&#XA0;<A HREF="#header_options">4.2</A>)
are called <EM>user&#X2019;s options</EM><A NAME="@default176"></A> since they are defined by the user.
You may notice that one letter only is used to select a user&#X2019;s option in
the command line.</P><P>In addition to user&#X2019;s options, there exist other options called 
system&#X2019;s options<A NAME="@default177"></A> since they are defined by MegaWave2 and always available.
System&#X2019;s options use more than one letter, therefore no confusion can be
made.</P><P>Here is the list of all available system&#X2019;s options:</P><P><B><CODE>-debug</CODE></B><A NAME="@default178"></A>
actives the debugging mode that is, the print of the function <CODE>mwdebug</CODE>
(see the Volume two for a description of this function).</P><P><B><CODE>-fsum</CODE></B><A NAME="@default179"></A>
prints the module&#X2019;s function summary as given in the Volume three: &#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D;, and exits. 
This recalls the user the parameters needed to call the module from
another module.</P><P><B><CODE>-ftype "file type"</CODE></B><A NAME="@default180"></A>
allows to overwrite the default file type for the MegaWave2 outputs<A NAME="@default181"></A>.
By default, MegaWave2 selects the same file type than the one of the
inputs (if the internal input type matches the internal output type)
or the file type which it considers to be the &#X201C;most common&#X201D;.
Using this option, you force MegaWave2 to write files having the
type given in the string (file types are given in the Volume two: 
&#X201C;MegaWave2 System Library&#X201D; ).
Do not use this option in case of several outputs with incompatible types. 
On some file types, option(s) may be added. Option mark is &#X2019;:&#X2019;.
For example, JFIFC:80 means JPEG/JFIFC<A NAME="@default182"></A> file format with the 
option 80 (quality factor).</P><P><B><CODE>-help</CODE></B><A NAME="@default183"></A>
prints a short help for the module and exits.</P><P><B><CODE>-proto</CODE></B><A NAME="@default184"></A>
prints the module&#X2019;s function prototype as to be included in a C source file, and
exits.</P><P><B><CODE>-verbose</CODE></B><A NAME="@default185"></A>
active the verbose mode that is, the print of all functions writting on
the standard output <CODE>STDOUT</CODE> or on the standard error <CODE>STDERR</CODE>.
Indeed, these outputs may be redirected using the shell variables
<CODE>MW_STDOUT</CODE><A NAME="@default186"></A> and 
<CODE>MW_STDERR</CODE> <A NAME="@default187"></A>
(see section&#XA0;<A HREF="user_manual003.html#install_user_set-up">2.2.1</A> page&#XA0;<A HREF="user_manual003.html#install_user_set-up">??</A>).
The verbose switch allows to suppress the redirection for only the 
current module.</P><P><B><CODE>-vers</CODE></B><A NAME="@default188"></A>
prints the module&#X2019;s version<A NAME="@default189"></A> number and exits.

</P><HR>
<A HREF="user_manual004.html"><abbr title="previous chapter" class="navigation">&larr;</abbr></A>
<A HREF="index.html"><abbr title="table of contents" class="navigation">&uarr;</abbr></A>
<A HREF="user_manual006.html"><abbr title="next chapter" class="navigation">&rarr;</abbr></A>
</BODY>
</HTML>
