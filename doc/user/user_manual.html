<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>megawave user manual
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
body	{
	color: #000000; 
	background-color: #ffffff; 
	font-family: Arial, Helvetica, sans-serif; 
	font-size: 13px;
	width: 60em; 
	margin: auto;
	text-align: justify;
	}

h1	{ 
	font-size:1.4em; 
	border: #CCCCFF solid; 
	border-width: 1px 0; 
	padding: .5em 2em; 
	margin: 2em 0 0 0;
	}
h2 	{ 
	font-size:1.2em; 
	padding: 0 1em;
	}
h3 	{ 
	font-size: 1em; 
	padding: 0 1em;
	}

a 	{
	color:#1E4869; 
	text-decoration: none;
	}
a:hover { 
	background:#EEEEEE;
	}

p 	{ 
	padding: 0 1em;
	}
abbr 	{ 
	border: 0; 
	}
table 	{
	text-align: left; 
	width: 100%; 
	}

ul, ol 	{ 
	padding: 0 1em 0 2em;
	}

pre 	{
        padding: 1em 1em 0 1em;
        margin: 0 0 0 1em;
        background: #EEEEEE;
        border-left: #AAAAAA 3px solid; 
	}

hr 	{
	color: #EEEEEE;
	border: 0;
	height: 1px;
  	width: 80%; 
	}

img 	{
	border: 0; 
	}

.navigation {
	font-size: 150%;
	font-weight: bold;
	float: left; 
	}

// original hevea style //

.li-itemize {
	margin: 1ex 0ex; 
	}
.li-enumerate{
	margin: 1ex 0ex;
	}
.toc	{
	list-style: none; 
	}
.thefootnotes {
	text-align: left;
	margin: 0ex; 
	}
.dt-thefootnotes {
	margin: 0em;
	}
.dd-thefootnotes {
	margin: 0em 0em 0em 2em; 
	}
.footnoterule {
	margin: 1em auto 1em 0px;
	width: 50%; 
	}
.caption {
	padding-left: 2ex; 
	padding-right: 2ex; 
	margin-left: auto; 
	margin-right: auto; 
	}
.center	{
	text-align: center;
	margin-left: auto;
	margin-right:auto; 
	}
div table {
	margin-left: inherit;
    	margin-right: inherit; 
	}
pre	{
	text-align: left;
	margin-left: 0ex;
	margin-right: auto; 
	}
blockquote {
	margin-left: 4ex;
	margin-right: 4ex;
	text-align: left; 
	}
td p	{
	margin: 0px; 
	}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -fix -O -o user_manual.html user_manual.tex -->
<!--CUT DEF chapter 1 --><DIV CLASS="center">
megawave software suite documentation (version 3.01)<BR>
<BR>
<BR>
<BR>

<FONT SIZE=4><B>volume one</B></FONT><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<FONT SIZE=6><SPAN STYLE="font-variant:small-caps">megawave user manual</SPAN></FONT><BR>
<BR>
<BR>
<BR>

<FONT SIZE=4><EM>edited by Jacques Froment</EM></FONT><BR>
</DIV><DIV CLASS="center"><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>


copyright &#XA9;  CMLA, Ecole Normale Sup&#XE9;rieure de Cachan<BR>
61 avenue du Pr&#XE9;sident Wilson, 94235 Cachan cedex, France<BR>
all rights reserved<BR>
http://megawave.cmla.ens-cachan.fr/
</DIV><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter&#XA0;1&#XA0;&#XA0;Introduction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1&#XA0;&#XA0;What is MegaWave2</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc3">1.2&#XA0;&#XA0;Motivations and history</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.3&#XA0;&#XA0;Authors and acknowledgements</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">1.4&#XA0;&#XA0;Main changes between MegaWave2 versions 1.x, versions 2.x and versions 3.x</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">1.5&#XA0;&#XA0;Contents of the MegaWave2 guides</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">1.6&#XA0;&#XA0;What you will find in this guide</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">1.7&#XA0;&#XA0;The MegaWave2 philosophy: basic principles</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">1.8&#XA0;&#XA0;MegaWave2 Macros</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">1.9&#XA0;&#XA0;The MegaWave2 Compiler</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">Chapter&#XA0;2&#XA0;&#XA0;Installation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc12">2.1&#XA0;&#XA0;Installation of the system</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc13">2.1.1&#XA0;&#XA0;Upgrading to a new MegaWave2 version</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">2.1.2&#XA0;&#XA0;Restoration of the package</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">2.1.3&#XA0;&#XA0;Directories structure</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">2.1.4&#XA0;&#XA0;Set up the environment</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">2.1.5&#XA0;&#XA0;Make the software ready</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">2.1.6&#XA0;&#XA0;No longer registration, but still license</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">2.2&#XA0;&#XA0;Installation for the user</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc20">2.2.1&#XA0;&#XA0;Set up the environment</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">2.2.2&#XA0;&#XA0;Make the directory tree ready</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">Chapter&#XA0;3&#XA0;&#XA0;Getting started</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc23">3.1&#XA0;&#XA0;A simple module</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">3.2&#XA0;&#XA0;Some optimizations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">3.3&#XA0;&#XA0;A little more complex extension</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">Chapter&#XA0;4&#XA0;&#XA0;Module&#X2019;s header</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc27">4.1&#XA0;&#XA0;Syntax</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc28">4.1.1&#XA0;&#XA0;Name Statement</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">4.1.2&#XA0;&#XA0;Author Statement</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">4.1.3&#XA0;&#XA0;Function Statement</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">4.1.4&#XA0;&#XA0;Labo Statement</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">4.1.5&#XA0;&#XA0;Group Statement</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">4.1.6&#XA0;&#XA0;Version Statement</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">4.1.7&#XA0;&#XA0;Usage Statement</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">4.2&#XA0;&#XA0;Options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">4.3&#XA0;&#XA0;Needed arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">4.4&#XA0;&#XA0;Optional arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">4.5&#XA0;&#XA0;Variable arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">4.6&#XA0;&#XA0;Unused arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">4.7&#XA0;&#XA0;Examples of headers</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc41">4.7.1&#XA0;&#XA0;Use of options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">4.7.2&#XA0;&#XA0;Use of optional arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">4.7.3&#XA0;&#XA0;Use of variable and unused arguments</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">4.8&#XA0;&#XA0;System&#X2019;s options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">Chapter&#XA0;5&#XA0;&#XA0;System&#X2019;s macros</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc46">5.1&#XA0;&#XA0;Macros summary</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">5.2&#XA0;&#XA0;List of modules</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">Chapter&#XA0;6&#XA0;&#XA0;User&#X2019;s macros</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc49">6.1&#XA0;&#XA0;Header of a Macro</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">6.2&#XA0;&#XA0;How to use user&#X2019;s macros</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">Chapter&#XA0;7&#XA0;&#XA0;Documentation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc52">7.1&#XA0;&#XA0;Document a module</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">7.2&#XA0;&#XA0;Document a macro</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">7.3&#XA0;&#XA0;Print the documentation</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">Chapter&#XA0;8&#XA0;&#XA0;Annex</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc56">8.1&#XA0;&#XA0;License</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">8.2&#XA0;&#XA0;How to contact the CMLA</A>
</LI></UL>
</LI></UL><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter&#XA0;1</A>&#XA0;&#XA0;Introduction</H1><!--SEC END --><P>
<A NAME="intro"></A>
</P><!--TOC section What is MegaWave2-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>&#XA0;&#XA0;What is MegaWave2</H2><!--SEC END --><P>
<A NAME="intro_what-is"></A></P><P>MegaWave2<A NAME="@default0"></A> is a software environment designed to help people
to write algorithms on signal processing and image analysis.
The user is assumed to be a non-computer scientist, 
in particular he is likely to be a mathematician 
(notice however that a good knowledge of the C language is assumed).</P><P>This means that the programmer should focus his mind on the algorithm only and not on pure computer problems (such as how to read an image, how to display a movie on the screen, how to select a curve with the mouse, how to manage an object library,&#X2026;)</P><P>The solution adopted by MegaWave2 is the concept of modules<A NAME="@default1"></A>, that is, of black boxes where the algorithms are described as C functions, without any assumption about the context in which the modules may be executed.
It is the task of the MegaWave2 compiler (basically a MegaWave2 preprocessor<A NAME="@default2"></A> followed by a standard C compiler) to make from a module a run-time command, a function of a library or a function to be run under a window-oriented interpreter.</P><!--TOC section Motivations and history-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">1.2</A>&#XA0;&#XA0;Motivations and history</H2><!--SEC END --><P>
<A NAME="intro_historic"></A></P><P>MegaWave2 has been basically created to help researchers in writing algorithms in the domain of signal processing and 
image analysis.
MegaWave2 allows a diffusion of the scientific information along all members of Jean-Michel Morel&#X2019;s research team (and also between
members of other teams): a module written to experiment a process may be used by somebody else several 
months later.
MegaWave2 was born in 1993 at the CEREMADE<A NAME="@default3"></A>, a mathematical laboratory of the Paris-IX Dauphine University,
France, inside a research group in image processing conducted by Jean-Michel Morel.
It succeeded to MegaWave<A NAME="@default4"></A> (renamed MegaWave1<A NAME="@default5"></A>) which essentially was a set of C files related to
the wavelet transform <SUP><A NAME="text1" HREF="#note1">1</A></SUP>.
Notice that in MegaWave2, if the wavelet part still exists, it only represents a small piece of all
the mathematical methods for image analysis that can be found. 
Since the move of the Morel&#X2019;s team in 1999, MegaWave2 is no longer directed by the CEREMADE but by the CMLA<A NAME="@default6"></A> (Centre de Math&#XE9;matiques et de 
Leurs Applications), CNRS UMR-8536, at the Ecole Normale Sup&#XE9;rieure de Cachan, Cachan, France.</P><P>We decided to put MegaWave2 in the public domain in 1994 (under some restrictions with version 1.x), since some 
algorithms may be worthy of interest for people working in the field of signal processing and image analysis.
The source of each algorithm is given, and therefore each researcher in the world can check it and understand it more deeply than he could do by reading the published article.
Thus, we experiment a new kind of scientific publication: the &#X201C;soft-publication&#X201D;<A NAME="@default7"></A>.
The main scientific interest of soft-publication in image processing is to offer <EM>reproducible research</EM><A NAME="@default8"></A>
<SUP><A NAME="text2" HREF="#note2">2</A></SUP>.</P><P>Moreover, we put together with the modules the whole MegaWave2 environment, so people can write new modules which may use 
(or not) our algorithms.
Thus we hope to help the scientific community, by encouraging (in the limit of our capacities) the communication and the 
emergence of new ideas.</P><P>Please notice that, because we could not check MegaWave2 on all possible computer architectures and systems, there is only 
a limited number of computers on which you may run the software without encountering difficulties. 
But even if your computer is not compatible with the ones we have, you still can read the algorithms by reading the sources of
the modules and even better, since MegaWave2 version 2.x, you may adapt the system so that it can run on your computer.</P><P>Last, please be indulgent with this software (which is not perfect - far from that - and which is still in development).
It has been written essentially by mathematicians (and not by computer scientists), using the short time left after 
teaching and research activities.</P><!--TOC section Authors and acknowledgements-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">1.3</A>&#XA0;&#XA0;Authors and acknowledgements</H2><!--SEC END --><P>
<A NAME="intro_authors"></A></P><P>As MegaWave1, MegaWave2 has been created by <EM>Jacques Froment</EM>, but with the help of a greater number of people.
New developments in MegaWave2 are still directed by <EM>Jacques Froment</EM>, with the help since 1998 of <EM>Lionel Moisan</EM>
who is in charge of collecting and updating public modules and user&#X2019;s macros. </P><P>Our thanks go first to <EM>Jean-Michel Morel</EM>, without whom nothing would have been possible.</P><P>It is hardly possible to cite here all the people who participated in MegaWave2 by writing new modules, or 
simply by giving valuable advices. 
Here is the list of people who wrote modules included in the public MegaWave2 package Version 3.01, released in
June 2007 :</P><P><EM>Andr&#XE9;s Almansa,
Chiaa Babya,
Toni Buades,
Fr&#XE9;d&#XE9;ric Cao,
Vicent Caselles,
Antonin Chambolle,
Guillaume Charpiat,
Thierry Cohignac,
Bartomeu Coll,
Jean-Pierre D&#X2019;Al&#XE8;s,
Fran&#XE7;oise Dibos,
Vincent Feuvrier,
Jacques Froment,
Fr&#XE9;d&#XE9;ric Guichard,
Yann Guyonvarc&#X2019;h,
Yan Jinhai,
Claire Jonchery,
Georges Koepfler,
Sa&#XEF;d Ladjal,
Kamal Lakhiari,
Jos&#XE9;-Luis Lisani,
Simon Masnou,
Lionel Moisan,
Pascal Monasse,
Pablo Muse,
Denis Pasquignon,
Florent Ranchin,
Amandine Robin,
Olivia Sanchez,
Catalina Sbert,
Fr&#XE9;d&#XE9;ric Sur.
</EM></P><P>Special thanks <EM>Claire Moisan</EM> who revised the text of the guides. </P><!--TOC section Main changes between MegaWave2 versions 1.x, versions 2.x and versions 3.x-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">1.4</A>&#XA0;&#XA0;Main changes between MegaWave2 versions 1.x, versions 2.x and versions 3.x</H2><!--SEC END --><P>
<A NAME="intro_main_changes"></A></P><P>This guide is intended to be the User&#X2019;s Guide of MegaWave2 versions 2.x<A NAME="@default9"></A> and 3.x<A NAME="@default10"></A> and it 
should not be used with former versions 1.x<A NAME="@default11"></A> (check the version number with <CODE>mwvers</CODE>). 
For those of you who were familiar with MegaWave2 versions 1.x, I give below a short list of the most important changes
between versions 1.x and version 2.00. 
To get an updated list of all changes<A NAME="@default12"></A>, please read the file <CODE>CHANGES</CODE> in the distribution
package.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The <EM>Registration<A NAME="@default13"></A> procedure</EM> to get a free <EM>license</EM> does no longer exists : with versions 2.x 
you do not have any registration form to send.
</LI><LI CLASS="li-itemize">The <EM>sources of MegaWave2 kernel</EM> (preprocessor and libraries) are given. Therefore, you are now able to
modify the kernel, for example to adapt it on a new machine architecture.
</LI><LI CLASS="li-itemize">In return, the kernel binaries are no longer distributed : the local MegaWave2 administrator has
to compile the kernel by himself.
</LI><LI CLASS="li-itemize">MegaWave2 has been adapted for <EM>Linux</EM><A NAME="@default14"></A> on i386.
</LI><LI CLASS="li-itemize">Effort has been done to offer more modules with associated demos, and former modules have been fully checked (some of them may see their name changed).
The <CODE>src</CODE> directory has been deeply reorganized.
</LI><LI CLASS="li-itemize">The <CODE>doc</CODE> directory structure has changed : see Section&#XA0;<A HREF="#document">7</A>.
</LI><LI CLASS="li-itemize">The <CODE>data</CODE> directory structure has changed, together with the search path convention.
In short, a PUBLIC subdirectory has been created where all public data not specifically associated 
to some modules have to be put. To resolve an input filename, a module now searches inside all 
subdirectories of data (See Volume 2 &#X201C;MegaWave2 System Library&#X201D;).
</LI></UL><P>The main change between versions 2.x and versions 3.x is about the MegaWave2 preprocessor<A NAME="@default15"></A>, which decodes the modules source files.
In versions 2.x the &#X2019;traditional&#X2019; preprocessor<A NAME="@default16"></A> includes a complete C parser and lexical analyzer generator. 
This preprocessor handles correctly C preprocessor directives (that begin with the pound sign #, as <TT>#define</TT> or <TT>#include</TT>). 
By reading system include files, the &#X2019;traditional&#X2019; preprocessor can decode modules that use objects defined in these include files (such as a type 
name defined by <TT>typedef</TT>). However, the C parser assumes a ANSI or K&amp;R standard C grammar whereas on Linux system, include files do not
always strictly follow these standards (indeed, the GNU C compiler provides several language features not found in standard C).
As a result of, on some glibc versions of Linux the MegaWave2 &#X2019;traditional&#X2019; preprocessor fails in decoding include files and outputs a parsing error.
After several years of workarounds, it appeared impossible to adapt the &#X2019;traditional&#X2019; preprocessor to the GNU C language and therefore
a new MegaWave2 preprocessor was developed.</P><P>The versions 3.x include the new MegaWave2 &#X2019;light&#X2019; preprocessor<A NAME="@default17"></A>. The adjective &#X2019;light&#X2019; refers to the fact that this 
preprocessor does not try to implement all standard C features : it reads and decodes what is essential in the modules source files, and nothing more.
In particular, C preprocessor directives are no more decoded and therefore parsing errors on system include files are avoided.
Of course, the &#X2019;light&#X2019; preprocessor has a serious drawback : since the tree of the C code is incomplete, it may fail on some unusual features.
For example, as <TT>#define</TT> directives are no more decoded, the line <TT>#define real float</TT> will not be read and if you use a parameter of type
<TT>real</TT> in the main function, a parse error will be generated (since types of parameters are essential for the main function only, you may use 
a parameter of type <TT>real</TT> in all other functions). Such limitations may be seen very restrictive, however it appears that over the 310 modules
of the last version 2.31, only one of them had to be modified to fulfill the new conditions.</P><!--TOC section Contents of the MegaWave2 guides-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">1.5</A>&#XA0;&#XA0;Contents of the MegaWave2 guides</H2><!--SEC END --><P>
<A NAME="intro_all-guides"></A></P><P>There are four guides about MegaWave2. 
Here are their contents:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Volume 1 : &#X201C;MegaWave2 User&#X2019;s Guide&#X201D;</B>. 
This is the present guide.
It introduces the user to the MegaWave2 philosophy and environment, it explains
the software installation and gives the directions for use.
</LI><LI CLASS="li-itemize"><B>Volume 2: &#X201C;MegaWave2 System Library&#X201D;</B>.
It is a reference manual on the functions of the system library. 
It also details all the available MegaWave2 objects.
Users who do not need to write modules may skip it.
</LI><LI CLASS="li-itemize"><B>Volume 3: &#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D;</B>.
It is a reference manual on the public modules.
This manual is automatically generated by the MegaWave2 compiler to reflect
the current modules library. 
You can get an updated version of this volume at any time.
It is essential for all users.
</LI><LI CLASS="li-itemize"><B>Volume 4: &#X201C;XMegaWave2 User&#X2019;s Guide&#X201D;</B>.
(Not yet available).
It is a guide for the XMegaWave extension to MegaWave2, called XMegaWave2<A NAME="@default18"></A>, which is a Windowed-oriented 
interface and interpreter. At this time, the MegaWave2 distribution package does not include the XMegaWave extension.
</LI></UL><!--TOC section What you will find in this guide-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">1.6</A>&#XA0;&#XA0;What you will find in this guide</H2><!--SEC END --><P>
<A NAME="intro_guide"></A></P><P>The section&#XA0;<A HREF="#intro">1</A> gives you an overall idea about the software.
In Section&#XA0;<A HREF="#install">2</A> you will learn how to install it and how to install the environment of each user.
The section&#XA0;<A HREF="#start">3</A> guides you to write and compile your first MegaWave2 module.
Next sections give references about the header&#X2019;s module (section&#XA0;<A HREF="#header">4</A>) and the system macros (section&#XA0;<A HREF="#sysmacros">5</A>).
The section&#XA0;<A HREF="#document">7</A> explains how to write the documentation attached to a module.
In the last section&#XA0;<A HREF="#annex">8</A> you will find the instructions to register your copy of MegaWave2 and some miscellaneous references.</P><!--TOC section The MegaWave2 philosophy: basic principles-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">1.7</A>&#XA0;&#XA0;The MegaWave2 philosophy: basic principles</H2><!--SEC END --><P>
<A NAME="intro_philo"></A></P><P>The aim of MegaWave2 is to make the coding of signal and image-oriented algorithms easier.
An algorithm is implemented as a function (or a set of functions) written in C language; such a function (or set of functions) is called a <B>module</B><A NAME="@default19"></A>.</P><P>The programmer does not write a complete program: what a module becomes is the matter of the <B>MegaWave2 compiler</B><A NAME="@default20"></A>. 
This compiler adds input/output code to generate a run-time command: the <B>module&#X2019;s command</B>. The module can then be called under the shell as Unix commands (and in a compatible mode with the MegaWave1 software). 
But the MegaWave2 compiler can also add interface to a window-oriented interpreter (XMegaWave2<A NAME="@default21"></A>); the module is then included in the interpreter as a new function.
The MegaWave2 compiler does even more; see Section&#XA0;<A HREF="#intro_compiler">1.9</A> page&#XA0;<A HREF="#intro_compiler">??</A> for details.</P><P>What does a module&#X2019;s source looks like ? you can refer to Section&#XA0;<A HREF="#start">3</A> for a first example of a module.
In short, the source of a module is a file (its name is the module name followed by the <CODE>.c</CODE> extension) which contains pure C instructions.
It begins with a header<A NAME="@default22"></A> put into comments (<CODE>/* ... */</CODE>), so the C compiler ignores it (see Section&#XA0;<A HREF="#header">4</A> for a description of the header).
But the MegaWave2 preprocessor<A NAME="@default23"></A> decodes this header. 
Informations are defined about the module, so are the author&#X2019;s name, the version number, etc. 
More important are the informations about the <B>usage</B>, that is, about the <B>input/output objects</B> (or <B>input/output variables</B>) of the module. 
This usage may say that a given variable (for example a <CODE>float</CODE>) is an optional input
with default value 1.0, and that another variable (for example an image with gray levels stored as <FONT COLOR=purple>float</FONT> numbers) is an output.</P><P>After the header comes the regular C body, where functions are defined.
One function must always be present, it is the <B>main function</B><A NAME="@default24"></A> of the module and it must have the same name as the module. 
When we refer to input/output objects of the module, we think about the parameters 
of this main function. 
Only the main function is global (i.e. can be accessed from other modules), all other functions are local.</P><P>In the module&#X2019;s skeleton below, the main function is <CODE>module</CODE> and the input/output objects are <CODE>obj1,obj2,...</CODE>:
</P><PRE CLASS="verbatim">/*------------------ MegaWave2 Module ----------------*/
/* mwcommand
.
. [header, including usage of obj1,obj2,...]
.
*/
/*----------------------------------------------------*/

internal_function(a1,a2,....)
.
. [definition of this function]
.

module(obj1,obj2,....)
{
  .
  .
  internal_function(b1,b2,...);
  .
  .
}
</PRE><P>A module can access to the main function of any other module, following these rules:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
They are <B>public modules</B><A NAME="@default25"></A>. Such modules are available for all users; they are located in the MegaWave2 system directory (for example <CODE>$MEGAWAVE2</CODE>). 
It is the responsibility of the MegaWave2 administrator to manage this set of modules (see Section&#XA0;<A HREF="#install_system">2.1</A>).
</LI><LI CLASS="li-itemize">They are <B>private modules</B><A NAME="@default26"></A>. 
All MegaWave2 users coding new modules generate their own private modules (located in the directory <CODE>$MY_MEGAWAVE2</CODE>).
A module cannot access to another private module <EM>from another user</EM>.
Therefore, if somebody has written a module of some interest for others, the MegaWave2 administrator should make it public.
</LI></UL><P>A module belongs to a <B>group</B><A NAME="@default27"></A>.
A group puts together all modules dealing about the same subject.
For example, you can imagine a group <CODE>fourier</CODE> where all the algorithms about the Fourier transform are put.
But you may want to distinguish between Fourier applied on one-dimensional signals and Fourier applied on images.
So you can define <B>subgroups</B> of the group <CODE>fourier</CODE>, as for example <CODE>signal</CODE> and <CODE>image</CODE>: you get two groups named <CODE>fourier/signal</CODE> and <CODE>fourier/image</CODE>.</P><P>How are the groups defined ? You define a group by creating a directory corresponding to the name of the group
into the existing directory <CODE>$MEGAWAVE2/src</CODE> (or <CODE>$MY_MEGAWAVE2/src</CODE>).
In our former example you must create <CODE>$MEGAWAVE2/src/fourier/signal</CODE> and<BR>
<CODE>$MEGAWAVE2/src/fourier/image</CODE>.
The source of the modules (with <CODE>.c</CODE> extension) has to be put into those directories.
With MegaWave2 versions 1.x, in addition you had to specify in the header of each module the name 
of the group (see Section&#XA0;<A HREF="#header">4</A>): <CODE>group={"fourier/signal"}</CODE> for all modules in the directory <CODE>$MEGAWAVE2/src/fourier/signal</CODE> and <CODE>group={"fourier/image"}</CODE> for all modules in 
the directory <CODE>$MEGAWAVE2/src/fourier/image</CODE>.
This is no longer required in MegaWave2 versions 2.x. </P><P>What is the meaning of the input/output objects<A NAME="@default28"></A> ? 
First, they are variables of C type. 
All scalar types are allowed, such as <CODE>char</CODE>, <CODE>int</CODE>, <CODE>long</CODE>, <CODE>float</CODE>, &#X2026;More sophisticated types are available. 
They are called <B>MegaWave2 memory</B><A NAME="@default29"></A> (or 
<B>internal</B><A NAME="@default30"></A>) <B>types</B>, 
and they are always pointers to a <B>structure</B><A NAME="@default31"></A>.
The structure defines the object to be processed by the module.
For example, the memory type <CODE>Cimage</CODE> represents monochrome images with gray levels of (unsigned) Char values.
The memory type <CODE>Curve</CODE> represents a discrete curve in the plane, etc.
See the Volume two &#X201C;MegaWave2 System Library&#X201D; for a description of all available MegaWave2 memory types.</P><P>How do these objects live outside a module ? They are C variables until the process finishes : a module which calls another module just gives the objects as parameters of the function; into the XMegaWave2 interpreter, all commands reside in memory and therefore objects remain C variables until they are removed.
When the process finishes (e.g. at the end of a module&#X2019;s command), the output objects have to be saved on disk as a file.
The same problem occurs when a process begins: input objects have to be read from files.
The format of the file depends on the memory type, we call it the <B>MegaWave2 file</B><A NAME="@default32"></A> 
(or <B>external</B>)<A NAME="@default33"></A> <B>type</B>.
Whereas there is only one memory type associated to an object, a memory type may be represented on disk with many different file types.
This is because MegaWave2 recognizes several standard file formats<A NAME="@default34"></A>, especially for the images. 
Also see Volume two for a description of all available MegaWave2 file types.</P><!--TOC section MegaWave2 Macros-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">1.8</A>&#XA0;&#XA0;MegaWave2 Macros</H2><!--SEC END --><P>
<A NAME="intro_macros"></A></P><P>A MegaWave2 <B>macro</B><A NAME="@default35"></A> is a Bourne shell<A NAME="@default36"></A> script with a normalized header.
It can call a set of MegaWave2 modules (in command mode), in order to repeat a sequence of actions automatically.
It can also be a <B>system&#X2019;s macro</B><A NAME="@default37"></A> which is an utility to manage MegaWave2.</P><P>For example, the macro <CODE>cmw2</CODE><A NAME="@default38"></A> calls the MegaWave2 Compiler, the macro 
<CODE>mwdoclatex</CODE><A NAME="@default39"></A> compiles the documentation of a module using L<sup>A</sup>T<sub>E</sub>X<A NAME="@default40"></A>,
&#X2026;.
Please refer to Section&#XA0;<A HREF="#sysmacros">5</A> for a list of all available system&#X2019;s macros.
You can get an updated list of these macros by running <CODE>mwsysmaclist</CODE><A NAME="@default41"></A> or
<CODE>mwdoc s</CODE><A NAME="@default42"></A> from the command line.</P><P>Notice that you can create your own macros (called <B>user&#X2019;s macros</B>)<A NAME="@default43"></A>.
You may want, for example, to put in a macro a sequence of calls to some
modules you frequently use.
In the first versions of MegaWave2, the user&#X2019;s macros were put into the directory 
<CODE>$MY_MEGAWAVE2/shell</CODE>. 
Since the version 1.04 of the software, user&#X2019;s macros are managed in the same way as modules.
There are <B>public user&#X2019;s macros</B> as well as <B>private user&#X2019;s macros</B>.
The public user&#X2019;s macros are put into the same directories as the sources of the public modules, 
that is subdirectories of <CODE>$MEGAWAVE2/src</CODE>, while private user&#X2019;s macros are in the
subdirectories of <CODE>$MY_MEGAWAVE2/src</CODE>.
Please refer to Section&#XA0;<A HREF="#usermacros">6</A> to learn more about user&#X2019;s macros.</P><!--TOC section The MegaWave2 Compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">1.9</A>&#XA0;&#XA0;The MegaWave2 Compiler</H2><!--SEC END --><P>
<A NAME="intro_compiler"></A></P><P>The MegaWave2 Compiler<A NAME="@default44"></A> is activated by the macro <CODE>cmw2</CODE><A NAME="@default45"></A> 
(see description Section&#XA0;<A HREF="#sysmacros_summary">5.1</A>). 
Let us suppose that you are in the directory <CODE>$MY_MEGAWAVE2/src/test</CODE> (i.e. the group is <CODE>test</CODE>) and that you call <CODE>cmw2 mod</CODE> (i.e. the module is <CODE>mod</CODE>, coded in the file <CODE>mod.c</CODE>).
If no error occurs, <CODE>cmw2 mod</CODE> processes the following items:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A file object is created which contains the code of the module for the architecture of the machine; this object is added to a user library called <CODE>libmymw.a</CODE>.
</LI><LI CLASS="li-itemize">If <CODE>cmw2</CODE> has been called with the <CODE>-X</CODE> option (which means: prepare this module for XMegaWave2), an object is created which makes an interface between the module function and XMegaWave2; this object is added to a user library called <CODE>libmyxmw.a</CODE>.
</LI><LI CLASS="li-itemize">A document skeleton is created in the directory <CODE>MY_MEGAWAVE2/doc/obj</CODE>, which has the name <CODE>mod.doc</CODE>. 
This document will be included into the volume 3 of the MegaWave2 guides; it explains the use of the module (syntax of the command, synopsis of the function, input/output objects, &#X2026;).
</LI><LI CLASS="li-itemize">A command is generated and compiled for the architecture of the machine.
The executable allows to run the module as a Unix command. 
The input/output variables of the module are read or written using files, keyboard or screen.
The command is compiled using standard C libraries and the following libraries:
<CODE>mymw</CODE>, <CODE>sysmw</CODE>, <CODE>W_X11R4</CODE>, <CODE>mw</CODE>, <CODE>tiff</CODE> or <CODE>notiff</CODE>. 
They allow the module to access to functions of the System Library, of all the public modules, 
of all your private modules and of the Wdevice facilities (window toolkit). 
If there are shared libraries for your machine architecture, you will save a lot of disk space.
</LI></UL><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">Actually, MegaWave1 was a quite different system since it did not have any specific 
pre-processor.The advantages of MegaWave1 were the simplicity and the documentation, which was written in french and 
therefore which did not misuse the Shakespeare language. Strong protests from our U.S. partners have urged us to change 
that !
</DD><DT CLASS="dt-thefootnotes"><A NAME="note2" HREF="#text2">2</A></DT><DD CLASS="dd-thefootnotes">The reproducible research paradigm is exposed in the report<BR>
<EM>http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf</EM>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Installation-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc11">Chapter&#XA0;2</A>&#XA0;&#XA0;Installation</H1><!--SEC END --><P>
<A NAME="install"></A>
</P><!--TOC section Installation of the system-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc12">2.1</A>&#XA0;&#XA0;Installation of the system</H2><!--SEC END --><P>
<A NAME="install_system"></A></P><P><A NAME="@default46"></A>
This section explains how to install the MegaWave2 software on your machine, it is written for the MegaWave2 administrator.
If you are a plain user, you can skip this and go to Section&#XA0;<A HREF="#install_user">2.2</A>.
To be the MegaWave2 administrator<A NAME="@default47"></A>, you don&#X2019;t need to be root<A NAME="@default48"></A> (super-user)<SUP><A NAME="text3" HREF="#note3">1</A></SUP>.
The administrator has to compile the kernel and the modules, and to manage the local public version of the software; in 
addition to the installation, he may update the modules library with some private modules
from the users (see Section&#XA0;<A HREF="#intro_philo">1.7</A>).</P><!--TOC subsection Upgrading to a new MegaWave2 version-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">2.1.1</A>&#XA0;&#XA0;Upgrading to a new MegaWave2 version</H3><!--SEC END --><P>
<A NAME="upgrading_megawave2"></A></P><P>If a former MegaWave2 software is installed on your machine, you may upgrade to a new version 
by following the same instructions as for a first installation. Old public modules will be
replaced by new ones. It is likely that you or other users would have developed private 
modules (i.e. modules set in <CODE>$MY_MEGAWAVE2/src</CODE>) that make use of older system library
and older public modules. In such a case when the new installation is finished,
check if public modules used by private modules have changed in some way (especially in the 
input/output parameters) and modify accordingly private modules. And then, recompile all
private modules (run a <CODE>cmw2_all -clear -2p -dep .</CODE> under <CODE>$MY_MEGAWAVE2/src</CODE>).
All MegaWave2 user&#X2019;s should do such a recompilation on their own private modules, even if the
sources (.c files) didn&#X2019;t require any modification : from one MegaWave2 version to a new one, 
the kernel may change a lot and therefore objects (such as .o and .doc files) generated by the 
old kernel may not be compatible with the new one.</P><!--TOC subsection Restoration of the package-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">2.1.2</A>&#XA0;&#XA0;Restoration of the package</H3><!--SEC END --><P>
<A NAME="install_system_restoration"></A></P><P><A NAME="@default49"></A>
The MegaWave2 administrator has to install the distribution package in a subdirectory of its home directory.
Let us call this subdirectory <CODE>$PRIVATE_MEGAWAVE2</CODE>.
If needed, the administrator may also create a directory (usually outside its home directory) where
the public version of the software will be copied. 
Let us call this subdirectory <CODE>$PUBLIC_MEGAWAVE2</CODE>.</P><P>You should begin the installation by restoring the full MegaWave2 package in <CODE>$PRIVATE_MEGAWAVE2</CODE>. 
As you are reading this document, you probably have already completed the restoration (in that
case, you can go to the next Section&#XA0;<A HREF="#install_system_set-up">2.1.4</A>).</P><P>If not, the best way to download<A NAME="@default50"></A> the last version of the software and to get
full instructions for the restoration is to 
visit our <EM>World Wide WEB</EM> pagehttp://megawave.cmla.ens-cachan.fr/<SUP><A NAME="text4" HREF="#note4">2</A></SUP> on the Internet.
The package should be in a file named <CODE>MegaWave2_V&lt;n&gt;.tar.Z</CODE>, 
<CODE>MegaWave2_V&lt;n&gt;.tar.gz</CODE> or <CODE>MegaWave2_V&lt;n&gt;.tgz</CODE>, where <CODE>&lt;n&gt;</CODE> is the version number.
After downloading it and if your WWW browser didn&#X2019;t do it for you, decompress the tar file using 
<CODE>uncompress</CODE> (<CODE>.Z</CODE> file) or using <CODE>gunzip</CODE> (<CODE>.gz</CODE> and <CODE>.tgz</CODE> files), and extract the
files from the tar file using <CODE>tar xf MegaWave2_V&lt;n&gt;.tar</CODE>.
If you are using the GNU tar command, you may also handle restoration of <CODE>MegaWave2_V&lt;n&gt;.tgz</CODE>
in one pass by means of the &#X201C;z&#X201D; flag : <CODE>tar xfz MegaWave2_V&lt;n&gt;.tgz</CODE>.</P><P>In any case, first load the file named README and follow the instructions in it. 
When the restoration will be done, you will get a main directory containing the software,
with a name referred to as <CODE>$PRIVATE_MEGAWAVE2</CODE>.</P><P>Please read first the additional information put in the file <CODE>$PRIVATE_MEGAWAVE2/README</CODE>.</P><P>If you are the administrator, you should entirely read the following sections. However, you may try to
install the software quickly by calling the shell <CODE>Install</CODE><A NAME="@default51"></A> located at the root directory
of the MegaWave2 package <CODE>$PRIVATE_MEGAWAVE2</CODE>. If your system and machine architecture is the same
as one we have, this may install the whole software without pain.</P><!--TOC subsection Directories structure-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">2.1.3</A>&#XA0;&#XA0;Directories structure</H3><!--SEC END --><P>
<A NAME="install_directories_struc"></A></P><P><A NAME="@default52"></A>
We know from Section&#XA0;<A HREF="#intro_philo">1.7</A> that modules are split between <EM>public modules</EM><A NAME="@default53"></A> put in a 
directory named <CODE>$MEGAWAVE2</CODE> and <EM>private modules</EM><A NAME="@default54"></A> put in <CODE>$MY_MEGAWAVE2</CODE>. </P><P>Actually, for the MegaWave2 administrator things are a little bit more complicated : the administrator may
want to be able to check new public modules and new kernel binaries before making them available for plain users. 
Therefore, the administrator has his own <CODE>$MEGAWAVE2</CODE> directory wich is not necessary the same as the
<CODE>$MEGAWAVE2</CODE> directory of plain users.
His own <CODE>$MEGAWAVE2</CODE> directory is called <EM>private MegaWave2</EM><A NAME="@default55"></A> 
(with associated environment variable <CODE>$PRIVATE_MEGAWAVE2</CODE><A NAME="@default56"></A>) whereas the 
<CODE>$MEGAWAVE2</CODE> directory of plain users is called <EM>public MegaWave2</EM><A NAME="@default57"></A> (<CODE>$PUBLIC_MEGAWAVE2</CODE>
<A NAME="@default58"></A>).
Of course, if you don&#X2019;t plan to update the system or if the only user is the administrator you should set 
<CODE>$PUBLIC_MEGAWAVE2</CODE> = <CODE>$PRIVATE_MEGAWAVE2</CODE>.
Notice that the administrator always has <CODE>$PRIVATE_MEGAWAVE2</CODE> = <CODE>$MEGAWAVE2</CODE>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.1: The various MegaWave2 directories a user may see.</TD></TR>
</TABLE></DIV>
<A NAME="install_directories_fig"></A><P>(150,90)(0,0)</P><P>(0,70)A plain user
(50,80)<TT>$MY_MEGAWAVE2</TT> (read/write) : user&#X2019;s private modules
(50,60)<TT>$MEGAWAVE2</TT> (read only)
(0,40)The administrator
(60,55)<FONT SIZE=5>=</FONT>
(50,50)<TT>$PUBLIC_MEGAWAVE2</TT> (read/write)
(50,30)<TT>$PRIVATE_MEGAWAVE2 = $MEGAWAVE2</TT> (r/w) : distribution,
(75,26)future public modules, kernel binaries and sources
(50,10)<TT>$MY_MEGAWAVE2</TT> (r/w) : modules in development</P><P>(80,55)current public modules and kernel binaries</P><P>(30,71)(2,1)15
(30,71)(2,-1)15</P><P>(35,41)(2,1)13
(35,41)(2,-1)13
(35,41)(1,-2)14

</P><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Set up the environment-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">2.1.4</A>&#XA0;&#XA0;Set up the environment</H3><!--SEC END --><P>
<A NAME="install_system_set-up"></A></P><P>You have to set up some environment variables<A NAME="@default59"></A> used by MegaWave2.
Put these definitions in a file which is executed at login time (such as <CODE>.profile</CODE>,<CODE>.login</CODE>,&#X2026;) or when opening a new shell (e.g. <CODE>.cshrc</CODE>).
They have to be set both for the administrator account and for all user accounts.
Therefore, it may be better for the administrator to put the definitions in a file which will be sourced at login time by all users.</P><P>The system&#X2019;s macro <CODE>mwsetenv</CODE><A NAME="@default60"></A> helps you to generate such a file, 
see its description in Section&#XA0;<A HREF="#sysmacros_summary">5.1</A>. 
This macro is called by the shell <CODE>Install</CODE><A NAME="@default61"></A> (see 
Sections&#XA0;<A HREF="#install_system_make-ready">2.1.5</A> and&#XA0;<A HREF="#sysmacros_summary">5.1</A>), so if you choose to install the software
in this way you should not have to set up the environment manually.</P><P>The following variables are needed <EM>for the administrator only</EM>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>PUBLIC_MEGAWAVE2</CODE><A NAME="@default62"></A> : 
directory where the public installation of the software has to be made, 
usually outside the administrator home directory.
You need write permission on it. Plain users need read and execute permissions, but they should not have write 
permission.<BR>
Example: <CODE>setenv PUBLIC_MEGAWAVE2 /usr/local/share/megawave2</CODE>.
</LI><LI CLASS="li-itemize"><CODE>PRIVATE_MEGAWAVE2</CODE><A NAME="@default63"></A> : 
directory where the temporary installation of the software has to be made
(future public version), usually inside the administrator home directory. This is also the directory where
the original distribution is put. Plain users do not need any permission on it.<BR>
Example: <CODE>setenv PRIVATE_MEGAWAVE2 ${home}/megawave2</CODE>.
</LI></UL><P>The following variables are needed for all users (including the administrator):
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>MEGAWAVE2</CODE><A NAME="@default64"></A> : 
for a plain user, directory where the public installation of the software is made (ask your
administrator for it). For the MegaWave2 administrator, set it to <CODE>PRIVATE_MEGAWAVE2</CODE>.<BR>
Example: <CODE>setenv MEGAWAVE2 /usr/local/share/megawave2</CODE>.
</LI><LI CLASS="li-itemize"><CODE>MY_MEGAWAVE2</CODE><A NAME="@default65"></A> : 
directory where the private user&#X2019;s version of the modules is.<BR>
Example: <CODE>setenv MY_MEGAWAVE2 ${home}/my_megawave2</CODE>.
</LI><LI CLASS="li-itemize"><CODE>MW_MACHINETYPE</CODE><A NAME="@default66"></A> : machine architecture as returned by the macro <CODE>mwarch</CODE><A NAME="@default67"></A> (if the
version of this macro accepts the option <CODE>-s</CODE>, use it).<BR>
Example: <CODE>setenv MW_MACHINETYPE `$MEGAWAVE2/sys/shell/mwarch -s`</CODE>.
On Sun computers running Solaris (SunOS 5.x or higher), you need to call <CODE>mwarch</CODE> with
the option <CODE>-s</CODE>. Otherwise, MegaWave2 will confuse the objects with those for SunOS 4.x.
</LI><LI CLASS="li-itemize"><CODE>MW_SYSTEMTYPE</CODE> : name of the operating system as HPUX, SunOS, &#X2026;.<BR>
Example: <CODE>setenv MW_SYSTEMTYPE `uname | tr -d -`</CODE>.
</LI></UL><P>
Special attention is requested if the directory path put in <CODE>MEGAWAVE2</CODE>
or <CODE>MY_MEGAWAVE2</CODE> corresponds to a link or to an automounted file: you
should always put the true pathname and not the link name. In short, if
you type under your shell the command <CODE>cd $MEGAWAVE2</CODE> followed by
the command <CODE>/bin/pwd</CODE> (and not the shell built-in command <CODE>pwd</CODE>),
you must get the same pathname as the one put in <CODE>$MEGAWAVE2</CODE>.</P><P>The following variables may be needed:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>MW_INCLUDEX11</CODE><A NAME="@default68"></A> : directory where the X Window include files are, if not in <CODE>/usr/include/X11</CODE>. If you are the administrator, this variable is always required.<BR>
Example: <CODE>setenv MW_INCLUDEX11 /usr/include/X11R5</CODE>
</LI><LI CLASS="li-itemize"><CODE>MW_LIBX11</CODE><A NAME="@default69"></A> : directory where the X Window libraries are, if not in <CODE>/usr/lib/X11</CODE>. 
If you are the administrator, this variable is always required.<BR>
Example: <CODE>setenv MW_LIBX11 /usr/lib/X11R5</CODE>.
</LI><LI CLASS="li-itemize"><CODE>MW_INCLUDEXm</CODE><A NAME="@default70"></A> : XMegaWave2 only. 
Directory where the Motif include files are, if not in <CODE>/usr/include/Xm</CODE>.<BR>
Example: <CODE>setenv MW_INCLUDEXm /usr/include/Motif1.2</CODE>.
</LI><LI CLASS="li-itemize"><CODE>MW_LIBXm</CODE><A NAME="@default71"></A> : XMegaWave2 only. 
Directory where the Motif libraries are, if not in <CODE>/usr/lib</CODE>.<BR>
Example: <CODE>setenv MW_LIBXm /usr/lib/Motif1.2</CODE>.
</LI><LI CLASS="li-itemize"><CODE>MW_LIBTIFF</CODE><A NAME="@default72"></A> : directory path where the TIFF<A NAME="@default73"></A> library 
(libtiff<A NAME="@default74"></A>) is located, if you want to use TIFF image format.
</LI><LI CLASS="li-itemize"><CODE>MW_LIBJPEG</CODE><A NAME="@default75"></A> : directory path where the JPEG<A NAME="@default76"></A> library (libjpeg<A NAME="@default77"></A>) is located, if you want to use JPEG image format.
</LI><LI CLASS="li-itemize"><CODE>LD_LIBRARY_PATH</CODE><A NAME="@default78"></A> : add directory path where the MegaWave2 system shared libraries are located, on UNIX 
systems (e.g. IRIX, SUN SOLARIS, LINUX) which require this definition for their runtime linker. Example :<BR>
<CODE>setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:${MEGAWAVE2}/sys/lib/${MW_MACHINETYPE}</CODE>.
</LI><LI CLASS="li-itemize"><CODE>LD_RUN_PATH</CODE><A NAME="@default79"></A> : 
add directory path where the MegaWave2 system shared libraries are located, on UNIX 
systems (e.g. LINUX) which require this definition for their runtime linker. Example :<BR>
<CODE>setenv LD_RUN_PATH ${LD_RUN_PATH}:${MEGAWAVE2}/sys/lib/${MW_MACHINETYPE}</CODE>.
</LI></UL><P>Note:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The X Window system Version 11 is a priori needed only by modules which use the Wdevice library to display signals, images, movies, &#X2026;However, it cannot be discarded since it is required to compile the kernel.
</LI><LI CLASS="li-itemize">The Motif Window system is needed only for XMegaWave2<A NAME="@default80"></A>; 
in that case you need also the X Window system Version 11.
</LI><LI CLASS="li-itemize">L<sup>A</sup>T<sub>E</sub>X<A NAME="@default81"></A> is needed only to make a new documentation for the modules you are going to write.
But to read the current documentation, you need a DVI viewer. MegaWave2 assumes <CODE>xdvi</CODE>
<A NAME="@default82"></A> (DVI Previewer for the X Window System) is installed on your system.
</LI><LI CLASS="li-itemize">The TIFF library is needed to load and save images in the TIFF format only.
You may already have this library, e.g. if you use the <CODE>XV</CODE> software<A NAME="@default83"></A> of John Bradley.
If not, you can load it by anonymous ftp at the following Internet address:
<CODE>sgi.com (directory graphics/tiff)</CODE>.
</LI><LI CLASS="li-itemize">The JPEG library is needed to load and save images in the JPEG/JFIF format, as defined by the 
Independent JPEG Group. Be aware that this is a loosely image format.
</LI></UL><P>Last, you need to update your path variable in order to allow execution of the MegaWave2 commands from any location. 
Add the following paths (the first one should have greatest priority): 
<CODE>${MY_MEGAWAVE2}/shell</CODE>, <CODE>${MY_MEGAWAVE2}/bin/${MW_MACHINETYPE}</CODE>,<BR>
<CODE>${MEGAWAVE2}/sys/bin/${MW_MACHINETYPE}</CODE>, <CODE>${MEGAWAVE2}/sys/shell</CODE>,<BR>
<CODE>${MEGAWAVE2}/bin/${MW_MACHINETYPE}</CODE>.</P><P>Example: 
</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP>
<CODE>set path=(${MEGAWAVE2}/sys/bin/${MW_MACHINETYPE} ${MEGAWAVE2}/sys/shell</CODE> &#X2026;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>          ${MEGAWAVE2}/bin/${MW_MACHINETYPE} $path)</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>set path=(${MY_MEGAWAVE2}/shell ${MY_MEGAWAVE2}/bin/${MW_MACHINETYPE} $path)</CODE>
</TD></TR>
</TABLE><!--TOC subsection Make the software ready-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">2.1.5</A>&#XA0;&#XA0;Make the software ready</H3><!--SEC END --><P>
<A NAME="install_system_make-ready"></A></P><P>The simplest way to install the software is to call the shell <CODE>Install</CODE><A NAME="@default84"></A> located at the root directory
of the MegaWave2 package <CODE>$PRIVATE_MEGAWAVE2</CODE>, and to answer some questions. 
Actually, this shell simply calls the macro <CODE>mwinstall</CODE><A NAME="@default85"></A> 
with parameters depending on your answers (see the description of this system macro in 
Section&#XA0;<A HREF="#sysmacros_summary">5.1</A>).
If <CODE>mwinstall</CODE> successfully exits, you should not have to do anything else to install the software
but to include the environment file generated by <CODE>mwsetenv</CODE> in your <CODE>.profile</CODE> or <CODE>.cshrc</CODE>.</P><P>If your system is the same as one we have, the installation procedure should be straightforward.
If not or if something goes wrong during the installation procedure, you will have to compile the whole thing
manually. The following explains the main steps you should manually complete. You may also have a look on
the installation shells, such as <CODE>Install</CODE> and <CODE>mwinstall</CODE>, for a better understanding of what has
to be done. Once the environment variables are set (see Section&#XA0;<A HREF="#install_system_set-up">2.1.4</A>), you should try to compile
the kernel first, and the modules and user&#X2019;s macros afterwards. </P><P>The kernel<A NAME="@default86"></A>, that is to say the system functions and the MegaWave2 preprocessor, is no longer pre-compiled on
MegaWave2 versions 2.x. You may compile it for your system architecture using the shell 
<CODE>$PRIVATE_MEGAWAVE2/kernel/Install</CODE>.</P><P>The software contains the modules as source files (located in the directory <CODE>$MEGAWAVE2/src</CODE>), so they have to be 
compiled for your machine architecture.
Just type <CODE>cmw2_all $MEGAWAVE2/src</CODE> to compile all the modules located in the subdirectories
of <CODE>$MEGAWAVE2/src</CODE>.
If your system can run the compiler, you probably won&#X2019;t encounter a lot of errors at this time.
Most likely errors are those about standard libraries or include files not found: check the environment setup or the installation of your operating system.
If you get an error about an unsatisfied symbol while compiling a module <CODE>A</CODE>, it is probably because <CODE>A</CODE> calls a module <CODE>B</CODE> which has not been already compiled. 
To fix that, you may type <CODE>cmw2_all $MEGAWAVE2/src</CODE> one more time or, preferably, 
use the option <CODE>-2p</CODE> (two pass - does not work for all linkers, see 
Section&#XA0;<A HREF="#sysmacros">5</A>).</P><!--TOC subsection No longer registration, but still license-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">2.1.6</A>&#XA0;&#XA0;No longer registration, but still license</H3><!--SEC END --><P>
<A NAME="install_system_registration"></A></P><P><A NAME="@default87"></A>
When the modules are compiled, you may want to check some algorithms. 
Just type from your Shell the name of the module you want to run: MegaWave2
recalls you the parameters needed to execute the corresponding algorithm.
Please refer to the Volume three: &#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D; to learn more about the different modules.
You may also run the system&#X2019;s macro <CODE>mwdoc M</CODE><A NAME="@default88"></A> to get the list of available modules
and user&#X2019;s macros, together with a short description.</P><P>On MegaWave2 versions 1.x you had noticed that some input and output data were disturbed. 
This is because you had to register the copy of MegaWave2 you got in order to use it freely.
This is no longer the case on MegaWave2 version 2.x.</P><P>However, the use of MegaWave2 is still under a license<A NAME="@default89"></A>. By using it, you accept the terms of this
license. 
You will find the license text at Section&#XA0;<A HREF="#annex_license">8.1</A> page&#XA0;<A HREF="#annex_license">??</A>.
If you do not agree with these conditions, you have to remove all the MegaWave2 files in your possession. 
Otherwise, your copy may be declared illegal regarding the european laws.</P><!--TOC section Installation for the user-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">2.2</A>&#XA0;&#XA0;Installation for the user</H2><!--SEC END --><P>
<A NAME="install_user"></A></P><P><A NAME="@default90"></A>
This section explains what each user must do in order to run the software.
It includes the MegaWave2 administrator which may also want to use the software as
a plain user.</P><P>If you were using an older MegaWave2 software, you will have to recompile all
private modules after the new software will be installed : check if some of your
private modules need to be upgraded and run a <CODE>cmw2_all -clear -2p -dep .</CODE> 
under <CODE>$MY_MEGAWAVE2/src</CODE>. You have to redo all compilations even if your
private modules didn&#X2019;t require any modification : from one MegaWave2 version to a 
new one, the kernel may change a lot and therefore objects (such as .o and .doc files) 
generated by the old kernel may not be compatible with the new one.</P><!--TOC subsection Set up the environment-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">2.2.1</A>&#XA0;&#XA0;Set up the environment</H3><!--SEC END --><P>
<A NAME="install_user_set-up"></A></P><P>The user may have to set up some variables of the environment.
Two cases may be encountered: if the MegaWave2 administrator has put the definitions in a specific file
(this is automatically done if he has used the standard installation procedure), you just have to load this file at 
login time or when opening a new shell (by using the shell command <CODE>source</CODE> or the <CODE>.</CODE> - dot -).
Ask the local administrator about this possibility.
If there is no such a file, you have to set the variables in your own configuration file as explained at Section&#XA0;<A HREF="#install_system_set-up">2.1.4</A> page&#XA0;<A HREF="#install_system_set-up">??</A>.</P><P>In addition to the standard environment setup, you may want to define the
following variables 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>MW_STDOUT</CODE><A NAME="@default91"></A>, <CODE>MW_STDERR</CODE><A NAME="@default92"></A><BR>
If you type under your C-compatible shell <CODE>setenv MW_STDOUT /dev/null</CODE>,
you ask the system to redirect the standard output of all modules to 
the null device that is, to the trash.
Make the experience by calling a run-time module which usually prints a 
lot of messages... No more messages will disturb your terminal !
But you have lost the messages. If you want to get them in a file 
(let us call <CODE>output</CODE> its name), type <CODE>setenv MW_STDOUT output</CODE>.
You can reset the default prints by removing your definition: <CODE>unsetenv MW_STDOUT</CODE>.
You can also redirect the standard error by setting the variable 
<CODE>MW_STDERR</CODE>. We do not recommend you to redirect this output to the
trash, since you won&#X2019;t be able to know if your modules correctly exit.
</LI><LI CLASS="li-itemize"><CODE>MW_CHECK_HIDDEN</CODE><A NAME="@default93"></A><BR>
If this variable is set, 
each time a module is called a check is performed using the system&#X2019;s macro <CODE>mwwhere</CODE> to see if the 
called module does not hide another one of same name. Indeed, path for private modules is set
before path for public modules in the <CODE>PATH</CODE> variable (and the same rule applies for module&#X2019;s library at
link time). So, if you write a user&#X2019;s module called <CODE>foo</CODE> while a <CODE>foo</CODE> public module already exists, 
the public module will be hidden by the first one. In such a case and providing <CODE>MW_CHECK_HIDDEN</CODE> is
set, a warning message will be issued by the non-hidden module at running-time.
The same procedure applies to macro, to check if a private user&#X2019;s macro hides a public one.
However, for macros the check is performed when the header/usage text is output only (e.g. when calling
the macro with -help or with an invalid syntax).
</LI></UL><!--TOC subsection Make the directory tree ready-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc21">2.2.2</A>&#XA0;&#XA0;Make the directory tree ready</H3><!--SEC END --><P>
<A NAME="install_user_make-dir"></A></P><P><A NAME="@default94"></A>
An user may want to develop new modules. 
In this case, he writes its private modules into a local MegaWave2 directory called <CODE>$MY_MEGAWAVE2</CODE>.
This directory should contain several sub-directories although some of them are optional:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>src</CODE><A NAME="@default95"></A> : sources of the user&#X2019;s modules and macros. 
May be divided into subdirectories representing groups.
</LI><LI CLASS="li-itemize"><CODE>bin</CODE><A NAME="@default96"></A> : executable modules. You have one subdirectory per machine architecture on which you have compiled the modules.
</LI><LI CLASS="li-itemize"><CODE>lib</CODE><A NAME="@default97"></A> : user&#X2019;s library of modules. You have one subdirectory per machine architecture on which you have compiled the modules.
</LI><LI CLASS="li-itemize"><CODE>obj</CODE><A NAME="@default98"></A> : object files. You have one subdirectory per machine architecture on which you have compiled the modules.
</LI><LI CLASS="li-itemize"><CODE>doc</CODE><A NAME="@default99"></A> : documentation. May be divided into <CODE>src</CODE> (source) and <CODE>obj</CODE> (object) subdirectories.
</LI><LI CLASS="li-itemize"><CODE>data</CODE><A NAME="@default100"></A> : samples of MegaWave2 data files such as images, movies, filters, 
shapes. May be divided into subdirectories representing groups or whatever else. 
</LI><LI CLASS="li-itemize"><CODE>shell</CODE><A NAME="@default101"></A> : links to the user&#X2019;s macros (Bourne shell scripts). 
</LI><LI CLASS="li-itemize"><CODE>mwi</CODE><A NAME="@default102"></A> : usage interface for the interpreter (XMegaWave2).
</LI><LI CLASS="li-itemize"><CODE>tmp</CODE><A NAME="@default103"></A> : directory for temporary files.
</LI></UL><P>You should only focus on the directories <CODE>src</CODE>, <CODE>doc/src</CODE> and maybe <CODE>data</CODE> (the last one being optional), where you will have to write something.
Other directories will be automatically updated by the system.</P><P>Subdirectories of these directories will be automatically created when necessary (except groups into <CODE>src</CODE>, see Section&#XA0;<A HREF="#intro_philo">1.7</A> page&#XA0;<A HREF="#intro_philo">??</A>).
But the directories themselves have to be created before the first call to the MegaWave2 compiler.
You can make them manually, or you can call the macro <CODE>mwnewuser</CODE><A NAME="@default104"></A>.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note3" HREF="#text3">1</A></DT><DD CLASS="dd-thefootnotes">It is not a good idea to install MegaWave2 as root. If you have root privileges, you should better create a <EM>megawave</EM> account and install the
software using this account.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">2</A></DT><DD CLASS="dd-thefootnotes">http://megawave.cmla.ens-cachan.fr/
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Getting started-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc22">Chapter&#XA0;3</A>&#XA0;&#XA0;Getting started</H1><!--SEC END --><P>
<A NAME="start"></A>
</P><P>This section shows you how to write a MegaWave2 module, by explaining several examples.
If you want to run existing modules only, please refer to the Volume three: &#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D; to learn more about the different modules.</P><!--TOC section A simple module-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc23">3.1</A>&#XA0;&#XA0;A simple module</H2><!--SEC END --><P>
<A NAME="start_simple"></A></P><P><A NAME="@default105"></A>
Let us suppose that you want to write an algorithm which adds the content of
two monochrome images<A NAME="@default106"></A>, that is to say it adds pixel by pixel the gray level values.</P><P>The first question you should ask yourself is &#X201C;what should be the input and the output of this algorithm ?&#X201D;.
Obviously you need two images for the input and the output will be another image, which will support the result of the addition.
If you refer to the Volume two: &#X201C;MegaWave2 System Library&#X201D;, you will see
that monochrome images may be implemented by two MegaWave2 objects: the
memory type <CODE>Cimage</CODE><A NAME="@default107"></A> and the memory type <CODE>Fimage</CODE><A NAME="@default108"></A>.
The first one uses small integers for the gray levels (unsigned char) while the second one uses floating point representation.
Let us say that your algorithm will make additions using the floating point representation: this is the less restrictive choice since integers are reals (and reals are not integers !) and the addition of two integers may exceed the capacity of the unsigned char representation (255).</P><P>Other important questions are &#X201C;what name should I give to the module ?&#X201D;, &#X201C;what group should it belong to?&#X201D;.
Due to the limitation of some standard link editors and archives, we recommend
you choose short names (with no more than 11 characters).
One uses to begin the name with a letter which recalls the memory type of the input: here it will be <CODE>f</CODE> since we use <CODE>Fimage</CODE>.
The remainder should be chosen in order to recall the algorithm, here <CODE>add1</CODE> for example (the letter <CODE>1</CODE> means that variants will be presented).
You may also want to put the module in a group, let us say <CODE>demo</CODE>.</P><P>At this point, we have all the information to write the MegaWave2 header<A NAME="@default109"></A> (please
have a look at the listing page&#XA0;<A HREF="#listing_fadd1">??</A>):
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the line <CODE>/* mwcommand</CODE><A NAME="@default110"></A> tells the MegaWave2 compiler that you begin the header. 
It is enclosed by comments (<CODE>/*</CODE> &#X2026;<CODE>*/</CODE>) since standard C compilers must be able to compile a module.
</LI><LI CLASS="li-itemize">the line <CODE>name = {fadd1};</CODE><A NAME="@default111"></A> defines the name of the module to be <CODE>fadd1</CODE>.
Although this event is not reported as an error, this name must coincide with the name of the module file and with the name of the main function of the module.
</LI><LI CLASS="li-itemize">the line <CODE>author = {"My name"};</CODE><A NAME="@default112"></A> gives the name of the author(s). It will be used for copyrights.
</LI><LI CLASS="li-itemize">the line <CODE>labo = {"My labo with the address"}</CODE><A NAME="@default113"></A> reports the laboratory(ies) where the author(s) belong(s). It will be used for copyrights (this definition is optional. If not set, native laboratory is assumed).
</LI><LI CLASS="li-itemize">the line <CODE>version = {"1.0"};</CODE><A NAME="@default114"></A> indicates the version number of the algorithm (this definition is optional).
</LI><LI CLASS="li-itemize">the line <CODE>function = {"Adds the ... "};</CODE><A NAME="@default115"></A> explains (very) shortly the algorithm.
</LI><LI CLASS="li-itemize">Last, the more important field is the usage. Here,
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>fimage1-&gt;A</CODE> means that <CODE>A</CODE> is an input parameter of the function <CODE>fadd1</CODE> (whose type &#X2014;here <CODE>Fimage</CODE>&#X2014; is given by the C declaration). 
The word <CODE>fimage1</CODE> is the one which will appear in the help and in the documentation (instead of the C word <CODE>A</CODE>).
The string following this declaration explains shortly the meaning of this argument.
</LI><LI CLASS="li-itemize"><CODE>fimage2-&gt;B</CODE> means that <CODE>B</CODE> is also an input parameter of the function.
</LI><LI CLASS="li-itemize"><CODE>result&lt;-C</CODE> means that <CODE>C</CODE> is an output parameter of the function.
</LI></UL>
</LI></UL><P>
To be in concordance with this header, you must edit the module in a file
called <CODE>fadd1.c</CODE> into the directory <CODE>$MY_MEGAWAVE2/src/examples</CODE>.
This module is actually given with the standard distribution and it is located in
<CODE>$MEGAWAVE2/src/examples</CODE>. 
So you can avoid editing it by copying it on your home location <CODE>$MY_MEGAWAVE2/src/examples</CODE>.</P><P>After the MegaWave2 header comes the regular C body.
You must first include the needed standard C files (here <CODE>stdio.h</CODE>)
followed by the MegaWave2 include file (<CODE>mw.h</CODE>).</P><P>The declaration of the main function<A NAME="@default116"></A> (<CODE>fadd1</CODE>) must list all the parameters (and no others) put in the <CODE>usage</CODE> part of the header:
you recognize the three parameters <CODE>A,B,C</CODE>.
The body of this function uses several functions of the system library (all functions of the system library begin with the prefix <CODE>mw</CODE>).
Please see the Volume two: &#X201C;MegaWave2 System Library&#X201D; to get explanations about all these functions.</P><P>The instructions
</P><PRE CLASS="verbatim"> if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");
</PRE><P><A NAME="@default117"></A>
check that the sizes of the two input images <CODE>A</CODE> and <CODE>B</CODE> are the same,
that is, that they have the same number of rows and columns.
If not, a fatal error is sent<A NAME="@default118"></A>, which terminates the module.</P><P>The line
</P><PRE CLASS="verbatim">  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  
</PRE><P><A NAME="@default119"></A>
allocates memory for the output image <CODE>C</CODE>, if <CODE>C</CODE> does not have enough
memory to record a size of (<CODE>A-&gt;nrow,A-&gt;ncol</CODE>).
Indeed, when you write a module, you don&#X2019;t know in which context the module may be executed:
It can be run in the command mode, in which case no memory is allocated for <CODE>C</CODE> (but the C structure by itself) or it can be run as a function in memory
(e.g. call from another module, from an interpreter, &#X2026;) in which case 
<CODE>C</CODE> may have been previously allocated.</P><P>The loop
</P><PRE CLASS="verbatim"> for (x=0;x&lt;A-&gt;ncol;x++) for (y=0;y&lt;A-&gt;nrow;y++)
    {
      a = mw_getdot_fimage(A,x,y);
      b = mw_getdot_fimage(B,x,y);
      mw_plot_fimage(C,x,y,a+b);
    }
</PRE><P>is the main part of the algorithm: 
for each pixel (<I>x</I>,<I>y</I>), we get in <CODE>a</CODE> the gray level of the image <CODE>A</CODE>
and in <CODE>b</CODE> the gray level of the image <CODE>B</CODE><A NAME="@default120"></A>
<A NAME="@default121"></A>.
The last instruction makes the addition <CODE>a+b</CODE> and put the result in the
image <CODE>C</CODE><A NAME="@default122"></A>.</P><P>We show in the following the whole listing of the simple module called <CODE>fadd1</CODE>:
<A NAME="listing_fadd1"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fadd1};
 author = {"My name"};
 labo = {"My labo with the address"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages (for demo #1)"};
 usage = {
   fimage1-&gt;A 
      "Input fimage #1", 
   fimage2-&gt;B
      "Input fimage #2", 
   result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

void fadd1(A,B,C)

Fimage  A,B,C;

{ int x,y;
  float a,b;

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (x=0;x&lt;A-&gt;ncol;x++) for (y=0;y&lt;A-&gt;nrow;y++)
    {
      a = mw_getdot_fimage(A,x,y);
      b = mw_getdot_fimage(B,x,y);
      mw_plot_fimage(C,x,y,a+b);
    }
}

</PRE><P>You are now ready to compile<A NAME="@default123"></A> the module: type under your favorite shell the command:<BR>
<CODE>cmw2 fadd1</CODE><BR>
<A NAME="@default124"></A>
This assumes that you have a standard C compiler called <CODE>cc</CODE>.
If your prefer to use the GNU C compiler, type the command:<BR>
<CODE>cmw2 -gnu fadd1</CODE><BR>
You should get something like the following prints:
</P><PRE CLASS="verbatim">cmw2 fadd1 
 
&gt;&gt;&gt; Welcome on the MegaWave2 Compiler V1.18 &lt;&lt;&lt;
 
  Phase 1 : MegaWave2 preprocessor
fadd1.c :
done.
  Phase 2 : production of sources and objects
          production of document squeleton (doc/demo/fadd1.doc)
          production of arguments analyser object
          production of module object
          add objects to MegaWave2 user library
          production of interface with MegaWave2 interpretor source
          production of interface with MegaWave2 library object
  Phase 3 : production of MegaWave command
          linking MegaWave2 command "fadd1" on hp
     (New command added... Type rehash)

</PRE><P>A lot of errors may occur during this compilation if your installation is not ready.
In that case, please check the installation (see section&#XA0;<A HREF="#install">2</A>).</P><P>If you didn&#X2019;t get any errors, type <CODE>rehash</CODE> if you are using a C-shell and execute the module in
the command mode by typing <CODE>fadd1</CODE> first without parameters.
You should get something like:

</P><PRE CLASS="verbatim">-------------------------------------------------------------------------------
\\     //  Adds the pixel's gray-levels of two fimages (for demo #1).
 \\   //   
  fadd1    Copyright (C)1998 Jacques Froment. 
 //   \\   MegaWave2 : J.Froment (C)1988-98 CEREMADE, Univ. Paris-Dauphine
//V 1.0\\  and (C)1998-2002 CMLA, ENS Cachan, 94235 Cachan cedex, France.
-------------------------------------------------------------------------------

error : missing 'fimage1'

usage : fadd1 fimage1 fimage2 result

        fimage1 :       Input fimage #1
        fimage2 :       Input fimage #2
        result :        Output image

</PRE><P>
This print recalls you the syntax of the command.
Since you run the module in the command mode, the parameters associated to a MegaWave2 type (<CODE>fimage1 fimage2 result</CODE>) refer to file names.
If you have some favorite image files available, use them for the two requested inputs
<CODE>fimage1 fimage2</CODE>.
If not (or if MegaWave2 cannot read those file formats), type the line:<BR>
<CODE>fadd1 fimage cimage result</CODE><BR>
How MegaWave2 does access to the files <CODE>fimage</CODE> and <CODE>cimage</CODE> ?
If a file is not found in the given path and name (here <CODE>./fimage</CODE> and <CODE>./cimage</CODE>), MegaWave2 tries to resolve the name by reading the directories <CODE>$MY_MEGAWAVE2/data</CODE>
and <CODE>$MEGAWAVE2/data</CODE> and their subdirectories.
For each MegaWave2 internal type, we put in those directories examples of external types.
The name of the file corresponds to the name of the internal type: for example, the file<BR>
<CODE>$MEGAWAVE2/data/PUBLIC/cimage</CODE> contains a monochrome image where the gray levels were recorded using the unsigned char representation, that is the representation of the <CODE>Cimage</CODE> internal type.
You can display this image on your screen by calling the following public module:<BR>
<CODE>cview cimage</CODE><BR>

You may have noticed that we called <CODE>fadd1</CODE> with a parameter (<CODE>cimage</CODE>) which does not match the requested internal type for the C variable <CODE>B</CODE> (a <CODE>Fimage</CODE>).
It doesn&#X2019;t matter since the MegaWave2 library makes the right conversion<A NAME="@default125"></A>.
It is also possible to convert a Fimage into a Cimage although is this case information may
be lost.
Of course some conversions are not supported (e.g. you cannot call <CODE>fadd1</CODE> with a signal as parameter).
Please refer to Volume two: &#X201C;MegaWave2 System Library&#X201D; to learn more about that.</P><P>After the command <CODE>fadd1 fimage cimage result</CODE> has been run, you should get on disk
the new file <CODE>./result</CODE> which records the contents of the C variable <CODE>C</CODE>.
You can display it on the screen by typing:<BR>
<CODE>cview result</CODE><BR>
You may get a warning message like<BR>
<CODE>MegaWave warning (cview) : 27757 Gray levels were out of [0,255].</CODE><BR>
This is because <CODE>cview</CODE> takes a <CODE>Cimage</CODE> as the input, so the gray levels of
<CODE>result</CODE> out of 255 have been thresholded.</P><P>Because <CODE>C</CODE> is a <CODE>Fimage</CODE>, the file <CODE>./result</CODE> has a compatible format 
with the floating point representation.
By default, MegaWave2 uses the same format as the format of the input <CODE>fimage</CODE>
but you can choice the format you want by using the option <CODE>-ftype</CODE><A NAME="@default126"></A>.
Indeed, there are some options in addition to the options you can define in the usage.
Such options are called <B>system&#X2019;s options</B><A NAME="@default127"></A> and one can distinguish them from
<B>user&#X2019;s options</B><A NAME="@default128"></A> since they use more than one letter
(see section&#XA0;<A HREF="#header_optsys">4.8</A> page&#XA0;<A HREF="#header_optsys">??</A> for more details).
For example, <CODE>fadd1 -ftype IMG fimage cimage result2</CODE> creates a file
<CODE>result2</CODE> which has the external format <CODE>IMG</CODE>.
This file format uses the unsigned char representation, therefore you get this warning
during the execution of <CODE>fadd1</CODE>:<BR>
<CODE>MegaWave warning (fadd1) : 27757 Gray levels were out of [0,255].</CODE><BR>
But now if you call <CODE>cview result2</CODE>, no more warning appears since thresholding has
been done by <CODE>fadd1</CODE>.</P><P>If you want to print the output image on a PostScript printer<A NAME="@default129"></A>, you should use
the external format <CODE>PS</CODE> instead of <CODE>IMG</CODE>: the file <CODE>result2</CODE>
will contain the image following PostScript format, so you can print it 
using the command <CODE>lp result2</CODE> (on most Unix systems). 
If you don&#X2019;t want to print <CODE>result2</CODE> alone, e.g. if you want to include this
file as an image in a L<sup>A</sup>T<sub>E</sub>X<A NAME="@default130"></A> document, you should use the <CODE>EPSF</CODE> format 
instead of <CODE>PS</CODE>.</P><!--TOC section Some optimizations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">3.2</A>&#XA0;&#XA0;Some optimizations</H2><!--SEC END --><P>
<A NAME="start_optim"></A></P><P><A NAME="@default131"></A>
<A NAME="@default132"></A>
The main part of the algorithm in <CODE>fadd1</CODE> uses standard MegaWave2 functions
to access to the pixels<A NAME="@default133"></A>.
Since fast pixel access is critical for image processing, we give in this section two alternatives to speed the execution of the module.
You may find more tips in the Volume two: &#X201C;MegaWave2 System Library&#X201D;, 
at this time keep just in mind that this kind of optimization can be adapted 
to other memory types such signals or movies.</P><P>The first alternative is given by the module <CODE>fadd2</CODE>.
Here is the listing:
<A NAME="listing_fadd2"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fadd2};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages (for demo #2)"};
 usage = {
   fimage1-&gt;A 
      "Input fimage #1", 
   fimage2-&gt;B
      "Input fimage #2", 
   result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

#define _(a,i,j) ((a)-&gt;gray[(j)*(a)-&gt;ncol+(i)])

void fadd2(A,B,C)

Fimage  A,B,C;

{ int x,y;

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (x=0;x&lt;A-&gt;ncol;x++) for (y=0;y&lt;A-&gt;nrow;y++)
    _(C,x,y) = _(A,x,y) + _(B,x,y);
}
</PRE><P>
This module does not really optimize the speed of the execution (the saving is small) but it makes the listing more readable for people:
once you have defined the C macro <CODE>_(a,i,j)</CODE>, you can access to the pixel
(<I>x</I>,<I>y</I>) on an image <CODE>I</CODE> by writing <CODE>_(I,x,y)</CODE> only<A NAME="@default134"></A>.
But be aware that some checking are deconnected in this way: do not exceed the
maximum range for (<I>x</I>,<I>y</I>).</P><P><BR>
</P><P><A NAME="@default135"></A>
The second alternative is given by the module <CODE>fadd3</CODE>.
This one really improves the speed of the execution.
But and unlike the former example, it cannot be used in all algorithms: the
pixel cannot be addressed in random order.
The image has to be read (or written) in the &#X201C;natural&#X201D; order that is,
from up to down and left to right.
Here is the listing:<A NAME="@default136"></A>
<A NAME="listing_fadd3"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fadd3};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages (demo #3)"};
 usage = {
   fimage1-&gt;A 
      "Input fimage #1", 
   fimage2-&gt;B
      "Input fimage #2", 
   result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

void fadd3(A,B,C)

Fimage  A,B,C;

{
  register float *ptr1,*ptr2,*ptr3;
  register int i;

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (ptr1=A-&gt;gray, ptr2=B-&gt;gray, ptr3=C-&gt;gray, i=0;
       i &lt; A-&gt;nrow*A-&gt;ncol; ptr1++, ptr2++, ptr3++, i++)
    *ptr3 = *ptr1 + *ptr2;
}
</PRE><P><BR>
</P><P><A NAME="@default137"></A>
The third alternative is given by the module <CODE>fadd4</CODE>.
The speed of the execution for this module is not so fast that the
one for the previous module <CODE>fadd3</CODE>, but this last method can
be used in any algorithms, even if the pixels are not scanned
in the &#X201C;natural&#X201D; order.
This method consists to allocate, using a MegaWave2 function, a
bi-dimensional tab which is actually an one-dimensional tab of 
pointers, and each pointer points to the beginning of a image&#X2019;s
line<A NAME="@default138"></A>. 
Here is the listing:
<A NAME="listing_fadd4"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fadd4};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages (for demo #4)"};
 usage = {
   fimage1-&gt;A 
      "Input fimage #1", 
   fimage2-&gt;B
      "Input fimage #2", 
   result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

void fadd4(A,B,C)

Fimage  A,B,C;

{ int x,y;
  float **TA,**TB,**TC;

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  if ( ((TA = mw_newtab_gray_fimage(A)) == NULL) ||
       ((TB = mw_newtab_gray_fimage(B)) == NULL) ||
       ((TC = mw_newtab_gray_fimage(C)) == NULL) )
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (x=0;x&lt;A-&gt;ncol;x++) for (y=0;y&lt;A-&gt;nrow;y++)
    TC[y][x] = TA[y][x] + TB[y][x];

  free(TC);
  free(TB);
  free(TA); 
}
</PRE><!--TOC section A little more complex extension-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc25">3.3</A>&#XA0;&#XA0;A little more complex extension</H2><!--SEC END --><P>
<A NAME="start_ext"></A></P><P><A NAME="@default139"></A>
We give in this section a little more complex extension to our algorithm,
in order to show the easy way in which two modules can communicate.
This will also gives examples of the use of options in the usage.</P><P>You have seen in section&#XA0;<A HREF="#start_simple">3.1</A> that the addition of two floating point images 
may be source of errors when the resulting image has to be converted to the unsigned char 
representation (which may be necessary, for example, when the image has to be displayed).
You may want to control the conversion into the addition module<A NAME="@default140"></A>.
Let us suppose that you want to put an optional thresholding of the output image, which may be preceded by a normalization of the gray levels into a given interval [min,max].</P><P>You have to add in the new module inputs for the boundaries of the interval, and input
for a flag to say whether or not you want the normalization. 
You have therefore to familiarize yourself with the options.</P><P>There is a general rule about the input/output optional parameters<A NAME="@default141"></A> of the module function:
they have to be pointers<A NAME="@default142"></A>. 
If the pointer is <CODE>NULL</CODE> it means that the parameter has not been selected,
if the address is not equal to <CODE>NULL</CODE> it points to an allocated space which may be a scalar or a C structure (in case of MegaWave2 memory type).
Because all MegaWave2 memory types<A NAME="@default143"></A> (e.g. <CODE>Cimage</CODE>, <CODE>Fimage</CODE>, &#X2026;) are pointers to a structure, there is no difference in the type between an optional parameter and a needed parameter.
On the contrary, if the input/output optional parameter is a scalar, say a <CODE>float</CODE>,
it has to be defined has a pointer to a float (<CODE>float *</CODE>).</P><P>A flag<A NAME="@default144"></A> is nothing more than a pointer to any scalar, e.g. a <CODE>char *</CODE>.
In the following version of our module, called <CODE>fadd</CODE>, the flag <CODE>norm</CODE> 
indicates if the normalization has to be computed (see the listing page&#XA0;<A HREF="#listing_fadd">??</A>) : 
</P><PRE CLASS="verbatim">'n'-&gt;norm "Normalize pixel values into [min,max]"+
</PRE><P>The letter <CODE>'n'</CODE> means that, in the command mode, the flag is set when the module
is called with the user option <CODE>-n</CODE>.</P><P>The other options are about the boundaries, let have a look to the first one:
</P><PRE CLASS="verbatim">'m':min-&gt;m0 "Force minimal pixel value",
</PRE><P>There is here an additional term, <CODE>min</CODE>, which says that the option needs a value
when it is selected. 
This value is put into the C variable addressed by <CODE>m0</CODE>.
The word <CODE>min</CODE> is the one which will appear in the help and in the documentation,
instead of the name of the C variable (you can choice the same name).
The string following this declaration explains the meaning of the option.
Everything is similar for the second boundary option:
</P><PRE CLASS="verbatim">'M':max-&gt;m1  "Force maximal pixel value",
</PRE><P>You have of course to update the declaration of the module function, in order to
add the options:
</P><PRE CLASS="verbatim">void fadd(A,B,C,norm,m0,m1)

Fimage  A,B,C;
char *norm;
float *m0,*m1;
</PRE><P>When the <CODE>-n</CODE> option is not selected, it should be possible to give only one boundary of the interval [min,max].
Indeed, the threshold may be done only in one side.
But when the user ask for the normalization, both <CODE>-m</CODE> and <CODE>-M</CODE> options must
be selected.
So you need to check that somewhere.
It is not possible to put this information in the header (we could do that but the header&#X2019;s grammar would be horrible), but you can add the verification in the beginning of the function:
</P><PRE CLASS="verbatim">  if (norm &amp;&amp; (!m0 || !m1)) mwerror(USAGE,0,
            "Normalization needs selection of [min,max] values\n");
</PRE><P>We call the function <CODE>mwerror</CODE><A NAME="@default145"></A> with the argument 
<CODE>USAGE</CODE><A NAME="@default146"></A> 
to tell MegaWave2 that this error is about the usage.</P><P>The normalization and thresholding process is called by the last line:
</P><PRE CLASS="verbatim">  if (m0 || m1) fthre(C,C,norm,m0,m1);
</PRE><P>Where is the function <CODE>fthre</CODE> defined ?
Since it is not a function of the system library (it doesn&#X2019;t begin with <CODE>mw</CODE>),
and because this function is not defined in the module, it should be the main function
of another module.
We could have put the computations into <CODE>fadd</CODE>, but by creating another module we
offer the possibility to directly use the command <CODE>fthre</CODE> in other contexts.
In addition, other modules may want to make normalization or thresholding so the code
will not be duplicated.
Such a (well-known) &#X201C;philosophy of overlapped black boxes&#X201D; saves space and time, it is
one of the important aspect of MegaWave2:
if your mathematical algorithm may be decomposed into several independant algorithms, write one module per algorithm.</P><P>Now we rapidly study the module <CODE>fthre</CODE>.
You should refer to the listing page&#XA0;<A HREF="#listing_fthre">??</A>.
The header of <CODE>fthre</CODE> is copied from the one of <CODE>fadd</CODE>, but there is
only one input image instead of two.
Please notice that the output image (the C variable <CODE>B</CODE>) is a priori not the same
as the input image <CODE>A</CODE>.
This allows to call <CODE>fthre</CODE> from a module which needs to keep the original image.
But you can force <CODE>fthre</CODE> to use the same variable for the input and the output,
by calling it with twice the same variable: that is what we do in <CODE>fadd</CODE>.
In this way, you save memory since the instruction<A NAME="@default147"></A>
</P><PRE CLASS="verbatim">  if ((B = mw_change_fimage(B,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  
</PRE><P>won&#X2019;t allocate any memory (<CODE>A</CODE> = <CODE>B</CODE> and therefore <CODE>B</CODE> has the gray
plane already allocated for the requested size).</P><P>Here is the listing of the addition module <CODE>fadd</CODE>.
It is a public module put into the group <CODE>common/float_image</CODE>:
<A NAME="listing_fadd"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module  -----------------------------*/
/* mwcommand
 name = {fadd};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Adds the pixel's gray-levels of two fimages"};
 usage = {
 'n'-&gt;norm "Normalize pixel values into [min,max]",
 'm':min-&gt;m0 "Force minimal pixel value",
 'M':max-&gt;m1  "Force maximal pixel value",
 fimage1-&gt;A 
   "Input fimage #1", 
 fimage2-&gt;B
   "Input fimage #2", 
 result&lt;-C
      "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include  "mw.h"

void fadd(A,B,C,norm,m0,m1)

Fimage  A,B,C;
char *norm;
float *m0,*m1;

{
  register float *ptr1,*ptr2,*ptr3;
  register int i;

  if (norm &amp;&amp; (!m0 || !m1)) mwerror(USAGE,0,
            "Normalization needs selection of [min,max] values\n");

  if((A-&gt;nrow != B-&gt;nrow) || (A-&gt;ncol != B-&gt;ncol))
    mwerror(FATAL, 1, "The input images have not the same size!\n");

  if ((C = mw_change_fimage(C,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  

  for (ptr1=A-&gt;gray, ptr2=B-&gt;gray, ptr3=C-&gt;gray, i=0;
       i &lt; A-&gt;nrow*A-&gt;ncol; ptr1++, ptr2++, ptr3++, i++)
    *ptr3 = *ptr1 + *ptr2;

  if (m0 || m1) fthre(C,C,norm,m0,m1);
}

</PRE><P>Here is the listing of the threshold module <CODE>fthre</CODE>.
It is a public module put into the group <CODE>common/float_image</CODE>:
<A NAME="listing_fthre"></A>
</P><PRE CLASS="verbatim">/*--------------------------- MegaWave2 module -----------------------------*/
/* mwcommand
 name = {fthre};
 author = {"Jacques Froment"};
 version = {"1.0"};
 function = {"Threshold the pixel's gray-levels of a fimage"};
 usage = {
 'n'-&gt;norm    "Normalize pixel values into [min,max]",
 'm':min-&gt;m0  "Force minimal pixel value",
 'M':max-&gt;m1  "Force maximal pixel value",
 fimage-&gt;A    "Input fimage", 
 result&lt;-B    "Output image"
};
*/
/*--------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include  "mw.h"

void fthre(A,B,norm,m0,m1)

Fimage  A,B;
char *norm;
float *m0,*m1;

{
  register float *ptr;
  register int i;
  float min,max,a,b;
  
  if (!m0 &amp;&amp; !m1) mwerror(USAGE,0,"At least min or max pixel value requested\n");
  if (norm &amp;&amp; (!m0 || !m1)) mwerror(USAGE,0,"Normalization needs selection of [min,max] values\n");
  if (m0 &amp;&amp; m1 &amp;&amp; (*m1 &lt;= *m0)) mwerror(USAGE,0,"Illegal values of [min,max]\n");

  if ((B = mw_change_fimage(B,A-&gt;nrow,A-&gt;ncol)) == NULL)
    mwerror(FATAL, 1, "Not enough memory !\n");  
  
  mw_copy_fimage(A,B);  /* Copy pixel values of A into B */

  if (norm)  /* Normalization */
    {
      min=1e20; max=-min;
      for (ptr=B-&gt;gray, i=0;  i &lt; B-&gt;nrow*B-&gt;ncol; ptr++, i++) 
        {
          if (*ptr &lt; min) min=*ptr;
          if (*ptr &gt; max) max=*ptr;
        }
      if (fabs((double) max-min) &lt;= 1e-20)
        mwerror(FATAL,1,"Cannot normalize: constant input image\n");
      a = (*m1-*m0)/(max-min);
      b = *m0 - a * min;
      for (ptr=B-&gt;gray, i=0;  i &lt; B-&gt;nrow*B-&gt;ncol; ptr++, i++) 
        *ptr = a * *ptr + b;
    }

  /* Thresholding */
  if (m0) for (ptr=B-&gt;gray, i=0;  i &lt; B-&gt;nrow*B-&gt;ncol; ptr++, i++)
    if (*ptr &lt; *m0) *ptr=*m0;
  if (m1) for (ptr=B-&gt;gray, i=0;  i &lt; B-&gt;nrow*B-&gt;ncol; ptr++, i++)
    if (*ptr &gt; *m1) *ptr=*m1;
}

</PRE><P>In order to make a run-time executable for the module <CODE>fadd</CODE>, you have
to take the following precaution:
when you want to compile<A NAME="@default148"></A> a module <CODE>X</CODE> (here <CODE>fadd</CODE>) which call the function of 
another module 
<CODE>Y</CODE> (here <CODE>fthre</CODE>), be sure to compile <CODE>Y</CODE> before <CODE>X</CODE>.
If you don&#X2019;t, you may get this kind of message during the compilation of <CODE>X</CODE>:
</P><PRE CLASS="verbatim">  Phase 3 : production of MegaWave command
          linking MegaWave2 command "X" on hp
/bin/ld: Unsatisfied symbols:
   Y (code)
          Error : exit.
</PRE><P>There is an eviler possibility: if you change the content of the module <CODE>Y</CODE>, think
to recompile <CODE>X</CODE> after <CODE>Y</CODE> (no message will be displayed if you forget that).
Therefore, a good habit is to recompile all your modules from time to time
(use the macro <CODE>cmw2_all</CODE><A NAME="@default149"></A> for that).
You may also use the Unix <EM>make</EM> utility.
</P><!--TOC chapter Module&#X2019;s header-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc26">Chapter&#XA0;4</A>&#XA0;&#XA0;Module&#X2019;s header</H1><!--SEC END --><P>
<A NAME="header"></A>
</P><!--TOC section Syntax-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc27">4.1</A>&#XA0;&#XA0;Syntax</H2><!--SEC END --><P>
<A NAME="header_syntax"></A></P><P>Any module begins with a MegaWave2 header<A NAME="@default150"></A>.
Such header is a set of statements enclosed between 
<CODE>/* mwcommand</CODE><A NAME="@default151"></A> and <CODE>*/</CODE>.</P><P>There are some restrictions :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
no C code nor C preprocessor instructions (<CODE>#include</CODE>, 
<CODE>#define</CODE>, &#X2026;) must be present before the MegaWave2 header,
</LI><LI CLASS="li-itemize">no C comments inside the MegaWave2 header.
</LI></UL><P>The following sections describes the statements which are used in 
the MegaWave2 header.</P><P>Needed statements<A NAME="@default152"></A> are :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>name</CODE>,
</LI><LI CLASS="li-itemize"><CODE>author</CODE>,
</LI><LI CLASS="li-itemize"><CODE>function</CODE>,
</LI><LI CLASS="li-itemize"><CODE>usage</CODE>,
</LI><LI CLASS="li-itemize"><CODE>version</CODE>.</LI></UL><P>Optional statements<A NAME="@default153"></A> are :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>labo</CODE>,
</LI><LI CLASS="li-itemize"><CODE>group</CODE>.
</LI></UL><!--TOC subsection Name Statement-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">4.1.1</A>&#XA0;&#XA0;Name Statement</H3><!--SEC END --><P>
<A NAME="@default154"></A></P><P><B>Syntax :</B> <CODE>name = {</CODE><EM>C_name</EM><CODE>};</CODE></P><P><B>Description :</B> gives the name of the C module and the name of the 
run-time command; <EM>C_name</EM> must follow the C identifier syntax.
The file name of the module must be the same, but it is followed by the extension <CODE>.c</CODE>.</P><P><B>Example :</B> <CODE>name = {bigtest};</CODE></P><!--TOC subsection Author Statement-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">4.1.2</A>&#XA0;&#XA0;Author Statement</H3><!--SEC END --><P>
<A NAME="@default155"></A></P><P><B>Syntax :</B> <CODE>author = { "</CODE><EM>author name</EM><CODE>, </CODE> <EM>author 
name</EM> <CODE>, ... "};</CODE></P><P><B>Description :</B> sets the list of author names; each author name 
must be separated by a comma.
These list (not the author name) is enclosed between quotes; it is
used to insert copyright in the run-time command and in the
module documentation.</P><P><B>Example :</B> <CODE>author = {"A.Turing, J. Von Neumann"};</CODE></P><!--TOC subsection Function Statement-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">4.1.3</A>&#XA0;&#XA0;Function Statement</H3><!--SEC END --><P>
<A NAME="@default156"></A></P><P><B>Syntax :</B> <CODE>function = { "</CODE><EM>sentence</EM><CODE>"};</CODE></P><P><B>Description :</B> Explains shortly the function of the module; 
this statement contains one string enclosed between quote.
It is used every time a short help is requested.</P><P><B>Example :</B> <CODE>function = { "Return 1 if a MegaWave2 module is useful, 0 elsewhere" };</CODE></P><!--TOC subsection Labo Statement-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">4.1.4</A>&#XA0;&#XA0;Labo Statement</H3><!--SEC END --><P>
<A NAME="@default157"></A></P><P><B>Syntax :</B> <CODE>labo = { "</CODE><EM>Laboratory name and address </EM><CODE>"};</CODE></P><P><B>Description :</B> sets the name of the laboratory (or firm) from which the authors
are issued, followed by the address. 
This statement contains one string enclosed between quote.
Several laboratories may be put in the same string.
This string is used to insert copyright in the run-time command and in the
module documentation.</P><P><B>Example :</B> <CODE>labo = { "Babbage Inc. 2001 W 99th St. NY New York 10021, USA"};</CODE></P><P>This statement is an optional statement. 
If not set, a default laboratory is used for the copyright
(the one from which MegaWave2 is issued).</P><!--TOC subsection Group Statement-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc32">4.1.5</A>&#XA0;&#XA0;Group Statement</H3><!--SEC END --><P>
<A NAME="@default158"></A></P><P><B>Syntax :</B> <CODE>group = { "</CODE> <EM>group name</EM> <CODE>"};</CODE></P><P><B>Description :</B> sets the group name in which the module belongs; 
a group is a word that follows UNIX file naming syntax (including an
optional path).</P><P><B>Example :</B> <CODE>group = {"autoref/tests"};</CODE>
Here, <CODE>tests</CODE> is a subgroup included in the main group <CODE>autoref</CODE>.</P><P>This statement is an optional statement.
If not set, the default group is given by the location of the module file
into the directory <CODE>$MY_MEGAWAVE2/src</CODE>.
If set, it must match this location.
Since MegaWave2 versions 2.x, use of this statement is no more recommended.
It is still available for backward compatibility only.</P><!--TOC subsection Version Statement-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">4.1.6</A>&#XA0;&#XA0;Version Statement</H3><!--SEC END --><P>
<A NAME="@default159"></A></P><P><B>Syntax :</B> <CODE>version = { "</CODE> <EM>version </EM> <CODE>"};</CODE></P><P><B>Description :</B> sets the version of the module.
Each time you modify the module file you should increment this number.</P><P><B>Example :</B> <CODE>version = { "1.00"};</CODE></P><P>Since MegaWave2 versions 2.x, this statement is no more optional.</P><!--TOC subsection Usage Statement-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">4.1.7</A>&#XA0;&#XA0;Usage Statement</H3><!--SEC END --><P>
<A NAME="@default160"></A></P><P><B>Syntax :</B> <CODE>usage = { </CODE> <EM>usage specification list</EM> <CODE>};</CODE></P><P><B>Description :</B> describes the module interface for a call by the run-time command.
An usage specification is made by an argument declaration followed by space and a quoted string; 
the quoted string is a description of the corresponding argument.
The usage specifications are separated by a comma.
Therefore, an extended description of the syntax may be:
</P><PRE CLASS="verbatim">usage = { arg_1 "string_1",
          arg_2 "string_2",
              ...
          arg_n "string_n"
        };
</PRE><P>There are five types of argument declaration:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<B>options</B><A NAME="@default161"></A><A NAME="@default162"></A> : 
they are optional parameters, which are selected by
putting in the command line a <CODE>-</CODE> followed by any printable character
(but <CODE>?</CODE>). These character defines the option.
Unix uses such options for its commands, as the option <CODE>-a</CODE> (list all entries) of the command <CODE>ls</CODE>.
Options are always placed before needed arguments.</LI><LI CLASS="li-enumerate"><B>needed arguments </B><A NAME="@default163"></A> : they are needed parameters, as the Unix
command <CODE>write</CODE> has a needed arguments (which is a user name).
Any module must define at least one needed argument.</LI><LI CLASS="li-enumerate"><B>optional arguments</B><A NAME="@default164"></A> : it is a list of parameters which is used entirely or is not used at all (you cannot use some of the arguments of this list and don&#X2019;t use the others);
this list is put between <CODE>{</CODE> and <CODE>}</CODE> and is always placed after needed arguments.</LI><LI CLASS="li-enumerate"><B>variable argument</B><A NAME="@default165"></A> : this argument corresponds to a list of undefined length, the module loops on all arguments of the list;
it is always placed after needed arguments;
You cannot define for the same module optional and variable arguments.</LI><LI CLASS="li-enumerate"><B>unused arguments</B><A NAME="@default166"></A> : this list describes the parameters of the module function which are not used as arguments in the command mode.
This list should be put at the end of the declaration.
</LI></OL><P>The corresponding C variables (which are defined in the module function) 
can be of scalar type (<CODE>short</CODE>, <CODE>int</CODE>, <CODE>long</CODE>, <CODE>unsigned short</CODE>, <CODE>unsigned int</CODE>, <CODE>unsigned long</CODE>, <CODE>float</CODE>, <CODE>double</CODE>) 
or of MegaWave2 type (a pointer to a structure, see the Volume two: &#X201C;MegaWave2 System Library&#X201D; for a list of all available MegaWave2 types).</P><P>The common description for the usage specification is the following: 
<EM>H name</EM> <CODE>-&gt;</CODE> or <CODE>&lt;-</CODE> <EM>C name</EM>. 
The right arrow <CODE>-&gt;</CODE> describes an input flow and the left arrow
<CODE>&lt;-</CODE> describes an output flow. </P><P>The word <EM>H name</EM> contains the name of the argument which is
used by Human being (e.g. used in the help, in the documentation)
The word <EM>C name</EM> contains the name of the C variable used 
in the module body.
One can choice to give to <EM>H name</EM> and <EM>C name</EM> the same word.</P><P>The syntax for each type of argument declaration is described in the 
next sections&#XA0;<A HREF="#header_options">4.2</A> to&#XA0;<A HREF="#header_unused-arg">4.6</A>.
We write by <TT>H_id</TT> any word of type <EM>H name</EM> and by
<TT>C_id</TT> any word of type <EM>C name</EM>.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc35">4.2</A>&#XA0;&#XA0;Options</H2><!--SEC END --><P>
<A NAME="header_options"></A>
<A NAME="@default167"></A></P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;&#X2212;&gt;<TT>C_id</TT></B>  
</P><P> (where &#X2019;c&#X2019; is a character) defines a flag option (i.e. an option without value); <TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. char *). 
The flag has been set by the user if and only if <TT>C_id</TT> &#X2260; <TT>NULL</TT>.</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:<TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> (where &#X2019;c&#X2019; is a character) defines an option with input value.
The flag has been set by the user if and only if <TT>C_id</TT> &#X2260; <TT>NULL</TT>.
If <TT>C_id</TT> &#X2260; <TT>NULL</TT>, the value of the option is given by <TT>*C_id</TT>.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>),
in this case its value is defined in the command line by writting the
number (or character) on the terminal,
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>),
in this case its value is given by writting the file name on the terminal.</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:[<TT>H_id</TT>  = <TT>Val</TT>]&#X2212;&gt;<TT>C_id</TT></B>  
</P><P>
defines an option with default input value.
This case is similar to the former, but when the option is not set by the user
then <TT>*C_id</TT>= <TT>Val</TT> that is, one can never have <TT>C_id</TT> = <TT>NULL</TT>.
MegaWave2 types are not allowed.
<TT>Val</TT> must be a constant of same type than <TT>C_id</TT>.
Warning: no implicit conversions are made (e.g. if <TT>C_id</TT> is of type <CODE>float</CODE>, <TT>Val</TT> =1.0 is allowed but not <TT>Val</TT> =1).</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:<TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P>
defines an option with input value and with interval checking 
(an error is send if the input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:[<TT>H_id</TT>  = <TT>Val</TT>] &#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P>
defines an option with default input value and with interval checking.</P><P> <BR>
<BR>
<B>&#X2019;c&#X2019;:<TT>H_id</TT>  &lt;&#X2212;<TT>C_id</TT></B>  
</P><P> 
(where &#X2019;c&#X2019; is a character) defines an option with output value.
The flag has been set by the user if and only if <TT>C_id</TT> &#X2260; <TT>NULL</TT>.
If <TT>C_id</TT> &#X2260; <TT>NULL</TT>, MegaWave2 writes the output value at the end of the module
from the content of <TT>*C_id</TT>.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>)
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>).
In this last case and if <TT>C_id</TT> &#X2260; <TT>NULL</TT>, you must allocate the
structure to the right size using functions of the system library,
before doing any computation with this variable (see Volume two: &#X201C;MegaWave2 System Library&#X201D;).</P><P>Restriction: <TT>C_id</TT> cannot be a function (return value of the module), 
whereas this is allowed with needed arguments (see section&#XA0;<A HREF="#header_needed-arg">4.3</A>).</P><!--TOC section Needed arguments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc36">4.3</A>&#XA0;&#XA0;Needed arguments</H2><!--SEC END --><P>
<A NAME="header_needed-arg"></A>
<A NAME="@default168"></A>
<A NAME="@default169"></A></P><P> <BR>
<BR>
<B><TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines a needed argument with input value.
<TT>C_id</TT> is a C variable of scalar type (e.g. <CODE>char</CODE>),
in this case its value is defined in the command line by writting the
number (or character) on the terminal,
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>),
in this case its value is given by writting the file name on the terminal.
In the body of the module function, you are sure to be able to access
to the content of this variable.
Do not perform any deallocation on it, since MegaWave2 may try to access it
after the end of the module.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT>[<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P> 
defines a needed argument with input value and with interval checking 
(an error is send if the input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &lt;&#X2212;<TT>C_id</TT></B>  
</P><P>
defines a needed argument with output value.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>)
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>).
It can be also the return of the module (e.g. <TT>H_id</TT> &lt;&#X2212;<CODE>fentropy</CODE>
if <CODE>fentropy</CODE> is the module function which returns a value of the same type than <TT>C_id</TT>),
although this form is not always recommanded when the return value is a
MegaWave2 object (since the structure has to be allocated at each call to
the module). 
The pointer <TT>C_id</TT> can never be <CODE>NULL</CODE> (MegaWave2 allocates space for the
value, if needed).
If <TT>C_id</TT> is of MegaWave2 type, you must allocate the
structure to the right size using functions of the system library,
before doing any computation with this variable (see Volume two: &#X201C;MegaWave2 System Library&#X201D;).
MegaWave2 writes the output value at the end of the module
from the content of <TT>*C_id</TT>.</P><P>Caution: when <TT>C_id</TT> is a pointer to a scalar, there is no number (nor character) to write in the command line, and therefore these needed argument is virtual
(it does not appear in the usage print).</P><!--TOC section Optional arguments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">4.4</A>&#XA0;&#XA0;Optional arguments</H2><!--SEC END --><P>
<A NAME="header_optional-arg"></A>
<A NAME="@default170"></A></P><P>The definition of optional arguments and needed arguments differs only
in the fact that the first are enclosed into <CODE>{</CODE> and <CODE>}</CODE>.
In addition, optional arguments must be defined after needed arguments.
When they are several optional arguments, they are linked in the sense
that the selection of the first leads the need of the selection of the others.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines an optional argument with input value.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>),
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>).
If <TT>C_id</TT> = <TT>NULL</TT>, then the argument has not been selected.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P> 
defines an optional argument with input value and with interval checking 
(an error is send if the input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B>[<TT>H_id</TT>  = <TT>Val</TT>] &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines an optional argument with default input value.
When the argument is not set by the user then <TT>*C_id</TT>= <TT>Val</TT> that is, one 
can never have <TT>C_id</TT> = <TT>NULL</TT>.
MegaWave2 types are not allowed.
<TT>Val</TT> must be a constant of same type than <TT>C_id</TT>.
Warning: no implicit conversions are made (e.g. if <TT>C_id</TT> is of type <CODE>float</CODE>, <TT>Val</TT> =1.0 is allowed but not <TT>Val</TT> =1).</P><P> <BR>
<BR>
<B>[<TT>H_id</TT>  = <TT>Val</TT> ] &#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P> 
defines an optional argument with input value and with interval checking 
(an error is send if the input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B><TT>H_id</TT>  &lt;&#X2212;<TT>C_id</TT></B>  
</P><P>
defines an optional argument with output value.
The argument has been given by the user if and only if <TT>C_id</TT> &#X2260; <TT>NULL</TT>.
If <TT>C_id</TT> &#X2260; <TT>NULL</TT>, MegaWave2 writes the output value at the end of the module
from the content of <TT>*C_id</TT>.
<TT>C_id</TT> is a C variable of MegaWave2 type only (e.g. <CODE>Cmovie</CODE>).
If <TT>C_id</TT> &#X2260; <TT>NULL</TT>, you must allocate the
structure to the right size using functions of the system library,
before doing any computation with this variable (see Volume two: &#X201C;MegaWave2 System Library&#X201D;).</P><P>Restriction: <TT>C_id</TT> cannot be a function (return value of the module), 
whereas this is allowed with needed arguments (see section&#XA0;<A HREF="#header_needed-arg">4.3</A>).</P><!--TOC section Variable arguments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc38">4.5</A>&#XA0;&#XA0;Variable arguments</H2><!--SEC END --><P>
<A NAME="header_variable-arg"></A>
<A NAME="@default171"></A></P><P> <BR>
<BR>
<B>&#X2026;&#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines variable arguments with input values.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <CODE>char *</CODE>),
in this case its successive values are defined in the command line by writting the numbers (or characters) on the terminal,
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>),
in this case its successive values are given by writting the file names on the terminal.
The module function is call as many time as the number of variable parameters given in the command line.
If no variable parameters are given, the module function is called only once
with <TT>C_id</TT> = <TT>NULL</TT>.</P><P> <BR>
<BR>
<B>&#X2026;&#X2212;&gt;<TT>C_id</TT>  [<TT>Min</TT>,<TT>Max</TT>] </B> 
</P><P>
defines variable arguments with input values and with interval checking 
(an error is send if one input value does not fit into the given interval [<TT>Min</TT>,<TT>Max</TT>]).
MegaWave2 types are not allowed.
<TT>Min</TT> and <TT>Max</TT> must be constant of same type than <TT>C_id</TT> with <TT>Max</TT> &gt; <TT>Min</TT>.</P><P> <BR>
<BR>
<B>&#X2026;&lt;&#X2212;<TT>C_id</TT></B>  
</P><P> 
defines variable arguments with output values.
<TT>C_id</TT> is a C variable of MegaWave2 type only (e.g. <CODE>Cmovie</CODE>): its successive values will be put in the files whose names are written on the terminal.
The module function is call as many time as the number of variable parameters given in the command line.
If no variable parameters are given, the module function is called only once
with <TT>C_id</TT> = <TT>NULL</TT>.</P><P>Restriction: <TT>C_id</TT> cannot be a function (return value of the module), 
whereas this is allowed with needed arguments (see section&#XA0;<A HREF="#header_needed-arg">4.3</A>).</P><!--TOC section Unused arguments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc39">4.6</A>&#XA0;&#XA0;Unused arguments</H2><!--SEC END --><P>
<A NAME="header_unused-arg"></A>
<A NAME="@default172"></A> </P><P> <BR>
<BR>
<B><TT>notused</TT> &#X2212;&gt;<TT>C_id</TT></B>  
</P><P> 
defines an argument which is not used in the command line mode.
We have always <TT>C_id</TT> = <TT>NULL</TT> when the module function is called
in the command line mode.
Therefore, a value &#X2260; <TT>NULL</TT> means a call from the library.
<TT>C_id</TT> is a C variable of type pointer to a scalar (e.g. <TT>char *</TT>),
or a C variable of MegaWave2 type (e.g. <CODE>Cmovie</CODE>).</P><P>Remarks: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The notation &#X2212;&gt; does not mean here that the argument is an input argument.
</LI><LI CLASS="li-itemize">The word <B><CODE>notused</CODE></B> being a keyword, you cannot use it elsewhere.
</LI><LI CLASS="li-itemize">Unused arguments should be put at the end of the usage declaration.
</LI></UL><!--TOC section Examples of headers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc40">4.7</A>&#XA0;&#XA0;Examples of headers</H2><!--SEC END --><P>
<A NAME="header_examples"></A></P><P>We give in the following the source of several modules, which were written in 
order to show the various possibilities of the header&#X2019;s syntax.
All of these modules are available with the public distribution, in the
directory <CODE>$MEGAWAVE2/src/demo</CODE>.</P><!--TOC subsection Use of options-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc41">4.7.1</A>&#XA0;&#XA0;Use of options</H3><!--SEC END --><P>
<A NAME="header_examples_options"></A></P><P><A NAME="@default173"></A>
The module <CODE>demohead1</CODE> demonstrates all the different kinds of options.
It uses also two needed arguments, one in input (a scalar with interval 
checking) and one in output (a MegaWave2 type).</P><P>Notice that the output variable (a <CODE>Cimage</CODE>) is not a parameter of
the module function: it is notified to the mother procedure using the
return value of the module.
This form is not recommended since it leads to allocate memory for the
<CODE>Cimage</CODE> at each call to the module.
The recommended form is to put the variable as a regular parameter of
the module function, so the variable is allocated by a call to <CODE>mw_change_cimage(output,nrow,ncol)</CODE> only if no previously memory allocation was done. </P><PRE CLASS="verbatim"> 
/*----------------------------- MegaWave Module -----------------------------*/
/* mwcommand
  name = {demohead1};
  version = {"1.0"};
  author = {"Jacques Froment"};
  function = {"Demo of MegaWave2 header - #1 : options -"};
  usage = {
  'a'-&gt;flg                   
     "Flag -option-",
  'B':cimage_input_opt -&gt; B
     "Input MegaWave2 type (cimage) -option-", 
  'c':[c_opt=1.0] -&gt; c
     "Input scalar (float) with default value -option-",
  'd':d_opt -&gt; d          [-10,10] 
     "Input scalar (integer) with boundary -option-",
  'e':[e_opt=0.0] -&gt; e    [0.0,1e20] 
     "Input scalar (double) with default value and boundary -option-",
  'F':f_opt &lt;- F
     "Output MegaWave2 type (cimage) -option-",

  float_input -&gt; input    [-1.0,1.0]
     "Input scalar (float) with boundary -needed argument-",

  cimage_output&lt;-demohead1      
     "Output MegaWave2 type (cimage) -needed argument-"
           };
*/
/*---------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;

/* Include always the MegaWave2 Library */
#include "mw.h"

Cimage demohead1(flg,B,c,d,e,F,input)

char *flg;   /* Or int *flg, ... */
Cimage B;    /* You don't need *B since Cimage is of MegaWave2 type (pointer)*/
float *c;    /* You need *c since float is a scalar (not a pointer) */
int *d;      /* You need *d since int is a scalar (not a pointer) */
double *e;   /* You need *e since double is a scalar (not a pointer) */
Cimage F;    /* You don't need *F since Cimage is of MegaWave2 type */
float input; /* You don't need any pointer since it's a needed input */


{
  Cimage output;  /* return of the module */
  
  if (flg) printf("flg flag active\n"); else printf("flg flag not active\n");

  /* B may be NULL */
  if (B) 
    {
      printf("Optional input B image selected\n"); 
      /* Here you can access to the content of the image B
         ...
       */
    }
  else 
    {
      printf("No B image selected\n");
      /* Do not access to B */
    }


  /* c cannot be NULL since *c has a default value */
  printf("*c = %f\n",*c);


  /* d may be NULL */
  if (d) printf("*d = %d\n",*d); else printf("No d value\n");
    
  /* e cannot be NULL since *e has a default value */
  printf("*e = %lf\n",*e);

  /* F may be NULL */
  if (F)
    {
      printf("Optional output F image selected\n");
      /* Here you can compute the image F, after dimensioning.  
      */      
      F = mw_change_cimage(F,10,10); /* for a size of (10,10) */
      if (F == NULL) mwerror(FATAL,1,"Not enough memory\n");
      /*
         ...
      */
    }
  else printf("No optional output F selected\n");

  /* Needed scalar argument is not a pointer */
  printf("input = %f\n",input);

  /* We need to create the structure and to allocate the output image */
  /* - In this example the size is (1,1) */  
  output = mw_change_cimage(NULL,1,1);
  if (output == NULL) mwerror(FATAL,1,"Not enough memory\n");

  /* Here you can compute the image output 
     ...
  */  

  return(output);
}
</PRE><!--TOC subsection Use of optional arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">4.7.2</A>&#XA0;&#XA0;Use of optional arguments</H3><!--SEC END --><P>
<A NAME="header_examples_optarg"></A></P><P><A NAME="@default174"></A>
With the module <CODE>demohead2</CODE>, we show the use of optional arguments.
This module defines also a needed output argument (a scalar).</P><PRE CLASS="verbatim"> 
/*----------------------------- MegaWave Module -----------------------------*/
/* mwcommand
  name = {demohead2};
  version = {"1.0"};
  author = {"Jacques Froment"};
  function = {"Demo of MegaWave2 header - #2 : optional arguments -"};
  usage = {

  output0 &lt;- out0    
     "Output scalar (int) -needed argument-",

     {
     [input0=1]  -&gt; in0 [-5,5]
       "Input scalar (int) with default value and boundary - optional argument -",
     input1 -&gt; in1 
       "Input scalar (float) - optional argument -",
     output1 &lt;- out1
       "Output MegaWave2 type (cimage) - optional argument -"
     }
           };
*/
/*---------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;

/* Include always the MegaWave2 Library */
#include "mw.h"

void demohead2(out0,in0,in1,out1)

int *out0;    /* You need a pointer since it's an output */
int *in0;     /* You need a pointer since it's an optional argument */
float *in1;   /* You need a pointer since it's an optional argument */
Cimage out1;  /* out1 is already a pointer since it's of MegaWave2 type */

{
  /* out0 cannot be NULL */
  *out0 = 3;

  /* in0 cannot be NULL */
  printf("*in0 = %d\n",*in0);

  /* in1 may be NULL */
  if (in1) printf("*in1 = %f\n",*in1); else printf("No in1 value\n");

  /* out1 may be NULL */
  if (out1) 
    {
      /* Here you can compute out1, after dimensionning */
      out1 = mw_change_cimage(out1,10,10); /* for a size of (10,10) */
      if (out1 == NULL) mwerror(FATAL,1,"Not enough memory\n");
      /*
         ...
      */
    }
  else printf("No optional output image out1\n");

}
</PRE><!--TOC subsection Use of variable and unused arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">4.7.3</A>&#XA0;&#XA0;Use of variable and unused arguments</H3><!--SEC END --><P>
<A NAME="header_examples_var-unused"></A></P><P><A NAME="@default175"></A>
The module <CODE>demohead3</CODE> shows the use of variable arguments.
It includes also one unused argument, <CODE>Win</CODE>, which is a pointer to a 
scalar.
The type of this argument should be <CODE>Wframe</CODE>, a pointer to a window structure
(See the Volume two: &#X201C;MegaWave2 System Library&#X201D; about the Wdevice library).
But <CODE>Wframe</CODE> is not a MegaWave2 object, therefore this type cannot be
used in the header. By casting the variable in the call to <CODE>demohead3</CODE>, one can define <CODE>Win</CODE> as a pointer to any scalar.</P><P>Notice that the variable <CODE>Output</CODE> is of type <CODE>Cimage *</CODE>; it is therefore
a pointer of pointer.
Why ? this is not requested by the MegaWave2 header, but by the last instruction<BR>
<CODE>*Output = Input;</CODE><BR>
This instruction changes the address pointed out by <CODE>*Output</CODE>.
If <CODE>Output</CODE> was of type <CODE>Cimage</CODE>, the instruction<BR>
<CODE>Output = Input;</CODE><BR>
would change the address inside the module function only, not outside.
With <CODE>Output</CODE> of type <CODE>Cimage</CODE>, the only solution is to copy the
content of <CODE>Input</CODE> into <CODE>Output</CODE> (using the function <CODE>mw_copy_cimage()</CODE>).</P><PRE CLASS="verbatim"> 
/*----------------------------- MegaWave Module -----------------------------*/
/* mwcommand
  name = {demohead3};
  version = {"1.0"};
  author = {"Jacques Froment"};
  function = {"Demo of MegaWave2 header - #3: variable and notused arguments -"};
  usage = {
    A-&gt;Input            "Input (could be a cimage)",
    ...&lt;-Output         "Output (copy of the input)",
    notused -&gt; Win      "Window (internal use only)" 
          };
*/
/*---------------------------------------------------------------------------*/

#include &lt;stdio.h&gt;

/* Include always the MegaWave2 Library */
#include "mw.h"

/* Include the window since we use windows facility */
#include "window.h" 

void demohead3(Input,Output,Win)

Cimage Input;
Cimage *Output;  /* Here we define *Output since the function changes the  */
                 /* pointer value (we set bellow *Output = Input)          */

char *Win;       /* Should be "Wframe *Win" for a MegaWave2 window         */
                 /* BUG: We cannot use other type than scalar or MegaWave2 */
                 /* Don't forget to cast before the function call          */
{
  if (Win != NULL)
    {
      printf("Library call: passing Window ptr\n");
      /*
         ...
      */
    }
  else printf("Command call: no Window ptr\n");

  if (*Output == NULL) printf("No output requested !\n");
  else 
    *Output = Input;  
}
</PRE><!--TOC section System&#X2019;s options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">4.8</A>&#XA0;&#XA0;System&#X2019;s options</H2><!--SEC END --><P>
<A NAME="header_optsys"></A></P><P>The options defined in the header&#X2019;s module (see section&#XA0;<A HREF="#header_options">4.2</A>)
are called <EM>user&#X2019;s options</EM><A NAME="@default176"></A> since they are defined by the user.
You may notice that one letter only is used to select a user&#X2019;s option in
the command line.</P><P>In addition to user&#X2019;s options, there exist other options called 
system&#X2019;s options<A NAME="@default177"></A> since they are defined by MegaWave2 and always available.
System&#X2019;s options use more than one letter, therefore no confusion can be
made.</P><P>Here is the list of all available system&#X2019;s options:</P><P><B><CODE>-debug</CODE></B><A NAME="@default178"></A>
actives the debugging mode that is, the print of the function <CODE>mwdebug</CODE>
(see the Volume two for a description of this function).</P><P><B><CODE>-fsum</CODE></B><A NAME="@default179"></A>
prints the module&#X2019;s function summary as given in the Volume three: &#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D;, and exits. 
This recalls the user the parameters needed to call the module from
another module.</P><P><B><CODE>-ftype "file type"</CODE></B><A NAME="@default180"></A>
allows to overwrite the default file type for the MegaWave2 outputs<A NAME="@default181"></A>.
By default, MegaWave2 selects the same file type than the one of the
inputs (if the internal input type matches the internal output type)
or the file type which it considers to be the &#X201C;most common&#X201D;.
Using this option, you force MegaWave2 to write files having the
type given in the string (file types are given in the Volume two: 
&#X201C;MegaWave2 System Library&#X201D; ).
Do not use this option in case of several outputs with incompatible types. 
On some file types, option(s) may be added. Option mark is &#X2019;:&#X2019;.
For example, JFIFC:80 means JPEG/JFIFC<A NAME="@default182"></A> file format with the 
option 80 (quality factor).</P><P><B><CODE>-help</CODE></B><A NAME="@default183"></A>
prints a short help for the module and exits.</P><P><B><CODE>-proto</CODE></B><A NAME="@default184"></A>
prints the module&#X2019;s function prototype as to be included in a C source file, and
exits.</P><P><B><CODE>-verbose</CODE></B><A NAME="@default185"></A>
active the verbose mode that is, the print of all functions writting on
the standard output <CODE>STDOUT</CODE> or on the standard error <CODE>STDERR</CODE>.
Indeed, these outputs may be redirected using the shell variables
<CODE>MW_STDOUT</CODE><A NAME="@default186"></A> and 
<CODE>MW_STDERR</CODE> <A NAME="@default187"></A>
(see section&#XA0;<A HREF="#install_user_set-up">2.2.1</A> page&#XA0;<A HREF="#install_user_set-up">??</A>).
The verbose switch allows to suppress the redirection for only the 
current module.</P><P><B><CODE>-vers</CODE></B><A NAME="@default188"></A>
prints the module&#X2019;s version<A NAME="@default189"></A> number and exits.

</P><!--TOC chapter System&#X2019;s macros-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc45">Chapter&#XA0;5</A>&#XA0;&#XA0;System&#X2019;s macros</H1><!--SEC END --><P>
<A NAME="sysmacros"></A>
</P><P>You have been already introduced to the macros by Section&#XA0;<A HREF="#intro_macros">1.8</A>.
A system&#X2019;s macro is a Bourne Shell script which uses a normalized header.
All system&#X2019;s macros are located in the directory <CODE>$MEGAWAVE2/sys/shell</CODE>.
They are used to manage MegaWave2.
The following section explains each system&#X2019;s macro.
The next section&#XA0;<A HREF="#sysmacros_list">5.2</A> describes a file format which is used
by some macros to describe a list of MegaWave2 modules.</P><!--TOC section Macros summary-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc46">5.1</A>&#XA0;&#XA0;Macros summary</H2><!--SEC END --><P>
<A NAME="sysmacros_summary"></A></P><P>The next pages describe each system&#X2019;s macro; the list is
in alphabetical order.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default190"></A></P><P><FONT SIZE=4><B>cmw2</B></FONT> - The MegaWave2 Compiler</P><P><BR>
<BR>
<BR>

<A NAME="@default191"></A>
<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>cmw2  [-traditional] [-gnu] [-g] [-X] [-O] [-c compiler_and_linker_option]</CODE><BR>
<CODE>      [-cc compiler_option] [-cl linker_option] [-Dname[=def]] [-Uname]</CODE><BR>
<CODE>      [-Ipathname][-v] [-w] [-Ldirectory] [-llibrary] [-dep] [-pubsyslib]</CODE><BR>
<CODE>      [-N] module</CODE>
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command compiles a MegaWave2 module given by <CODE>module</CODE>.
Since version 1.41 of this system&#X2019;s macro, <CODE>module</CODE> may also be a
User&#X2019;s macro. In that case, <CODE>cmw2macro</CODE> is called.
Please refer to Section&#XA0;<A HREF="#intro_compiler">1.9</A> page&#XA0;<A HREF="#intro_compiler">??</A>
to learn more about this compilation.
The module must be located into a subdirectory of <CODE>$MY_MEGAWAVE2</CODE> (plain user)
or of <CODE>$MEGAWAVE2</CODE> (administrator only).</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-traditional</CODE> : Use the &#X2019;traditional&#X2019; preprocessor instead of the &#X2019;light&#X2019; one
(see Section&#XA0;<A HREF="#intro_main_changes">1.4</A> page&#XA0;<A HREF="#intro_main_changes">??</A>).</P><P><CODE>-gnu</CODE> : Use the Gnu C compiler <CODE>gcc</CODE> instead of the standard C compiler <CODE>cc</CODE>.</P><P><CODE>-g</CODE> : Debug flag. Cause the compiler to generate additional information
needed by the symbolic debugger. This option is normally incompatible with optimization.</P><P><CODE>-X</CODE> : XMegaWave flag. Cause the compiler to generate an interface to include the module in the XMegaWave2 software.</P><P><CODE>-O</CODE> : Invoke the C optimizer. This option is normally incompatible with debugging.</P><P><CODE>-c</CODE> : pass the following argument <CODE>compiler_and_linker_option</CODE> to the compiler and to the linker
(if the argument contains spaces, you can still pass it as one item by surrounding in <CODE>"</CODE>quotes<CODE>"</CODE>).</P><P><CODE>-cc</CODE> : pass the following argument <CODE>compiler_option</CODE> to the compiler only
(if the argument contains spaces, you can still pass it as one item by surrounding in <CODE>"</CODE>quotes<CODE>"</CODE>).</P><P><CODE>-cl</CODE> : pass the following argument <CODE>linker_option</CODE> to the linker only
(if the argument contains spaces, you can still pass it as one item by surrounding in <CODE>"</CODE>quotes<CODE>"</CODE>).</P><P><CODE>-Dname</CODE> : Define <CODE>name</CODE> to the preprocessor, as if by <CODE>'#define'</CODE>. 
If your compiler uses the ANSI mode, you should define the name <CODE>__STDC__</CODE>.</P><P><CODE>-Uname</CODE> : Remove any initial definition of <CODE>name</CODE> in the preprocessor. </P><P><CODE>-v</CODE> : Verbose mode. Print messages about what command is running, together with the name of temporary files. In this mode, temporary files are not deleted so you can edit them, debug, or run the commands manually.</P><P><CODE>-w</CODE> : Suppress warning messages.</P><P><CODE>-Ipathname</CODE> : Change the algorithm used by the preprocessor for finding include files to also search in directory <CODE>pathname</CODE>.</P><P><CODE>-Ldirectory</CODE> : Change the algorithm used by the linker to search for
the libraries. The -L option causes the compiler to search in <CODE>directory</CODE> before searching in the default locations.</P><P><CODE>-llibrary</CODE> : Include additional library given by <CODE>library</CODE> for linking.</P><P><CODE>-dep</CODE> : Dependencies list. Cause the compiler to generate a primary dependencies list of the module. See the macro <CODE>mwdep</CODE> for more information.</P><P><CODE>-pubsyslib</CODE> : Link module with the PUBLIC system library (adm only).</P><P><CODE>-N</CODE> : Do not propose to run <CODE>lint</CODE> (a C program checker/verifier) in case of compilation error.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default192"></A></P><P><FONT SIZE=4><B>cmw2_all</B></FONT> - Compile all MegaWave2 Modules</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>cmw2_all [-traditional] [-gnu] [-clear] [-g] [-X] [-O]</CODE><BR>
<CODE>         [-c compiler_and_linker_option] [-cc compiler_option]</CODE><BR>
<CODE>         [-cl linker_option] [-Dname[=def]] [-Uname] [-Ipathname] [-w]</CODE><BR>
<CODE>         [-Ldirectory] [-llibrary] [-2p] [-sp] [-dep] [-pubsyslib] [-force]</CODE><BR>
<CODE>         [-v tracefile] [-N processid] src_directory</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command compiles all MegaWave2 modules being in the given directory <CODE>src_directory</CODE>, and recursively in all subdirectories of <CODE>src_directory</CODE>.
It basically calls <CODE>cmw2</CODE> as many time as necessary. 
The location pointed by <CODE>src_directory</CODE> has to be a subdirectory of <CODE>$MY_MEGAWAVE2</CODE> 
(plain user) or of <CODE>$MEGAWAVE2</CODE> (administrator only).
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-traditional</CODE> : Use the &#X2019;traditional&#X2019; preprocessor instead of the &#X2019;light&#X2019; one
(see Section&#XA0;<A HREF="#intro_main_changes">1.4</A> page&#XA0;<A HREF="#intro_main_changes">??</A>).</P><P><CODE>-gnu</CODE> : Use the Gnu C compiler <CODE>gcc</CODE> instead of the standard C compiler <CODE>cc</CODE>.</P><P><CODE>-clear</CODE> : Clear the following target directories before processing the
compilations: <CODE>bin</CODE>, <CODE>lib</CODE>, <CODE>obj</CODE>, <CODE>mwi</CODE> and <CODE>doc/obj</CODE> 
(confirmation is requested).
This option allows to clean the target directories; otherwise old modules stay
in those directories even if the sources have been deleted (but if the system&#X2019;s macro
<CODE>mwrm</CODE> was used).</P><P><CODE>-sp</CODE> : Second pass. Do not compile a module if it has been already successfully compiled. This option works only with linkers which do not set a binary containing unresolved symbols to be executable.</P><P><CODE>-2p</CODE> : Two pass. During the first pass, all the modules are compiled. 
The second pass calls <CODE>cmw2_all</CODE> with <CODE>-sp</CODE>.
This option allows modules which depend on other modules to be successfully compiled after the second pass. This option works only with linkers which do not set a binary containing unresolved symbols to be executable.</P><P><CODE>-g</CODE> : Debug flag. Cause the compiler to generate additional information
needed by the symbolic debugger. This option is normally incompatible with optimization.</P><P><CODE>-X</CODE> : XMegaWave flag. Cause the compiler to generate an interface to include the modules in the XMegaWave2 software.</P><P><CODE>-O</CODE> : Invoke the C optimizer. This option is normally incompatible with debugging.</P><P><CODE>-c</CODE> : pass the following argument <CODE>compiler_and_linker_option</CODE> to the compiler and to the linker
(if the argument contains spaces, you can still pass it as one item by surrounding in <CODE>"</CODE>quotes<CODE>"</CODE>).</P><P><CODE>-cc</CODE> : pass the following argument <CODE>compiler_option</CODE> to the compiler only
(if the argument contains spaces, you can still pass it as one item by surrounding in <CODE>"</CODE>quotes<CODE>"</CODE>).</P><P><CODE>-cl</CODE> : pass the following argument <CODE>linker_option</CODE> to the linker only
(if the argument contains spaces, you can still pass it as one item by surrounding in <CODE>"</CODE>quotes<CODE>"</CODE>).</P><P><CODE>-Dname</CODE> : Define <CODE>name</CODE> to the preprocessor, as if by <CODE>'#define'</CODE>.
If your compiler uses the ANSI mode, you should define the name <CODE>__STDC__</CODE>.</P><P><CODE>-Uname</CODE> : Remove any initial definition of <CODE>name</CODE> in the preprocessor. </P><P><CODE>-Ipathname</CODE> : Change the algorithm used by the preprocessor for finding include files to also search in directory <CODE>pathname</CODE>.</P><P><CODE>-Ldirectory</CODE> : Change the algorithm used by the linker to search for
the libraries. The -L option causes the compiler to search in <CODE>directory</CODE> before searching in the default locations.</P><P><CODE>-llibrary</CODE> : Include additional library given by <CODE>library</CODE> for linking.</P><P><CODE>-w</CODE> : Suppress warning messages.</P><P><CODE>-dep</CODE> : Dependencies list. Cause the compiler to generate the primary dependencies list of each module. See the macro <CODE>mwdep</CODE> for more information.</P><P><CODE>-force</CODE> : Do not ask confirmation before removing target directories.</P><P><CODE>-v tracefile</CODE> : Verbose. Output trace of compilations in the file <CODE>tracefile</CODE> that can be viewed after the command ends.</P><P><CODE>-pubsyslib</CODE> : Link modules with the PUBLIC system library (adm only).</P><P><CODE>-N processid</CODE> : Internal use only.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default193"></A></P><P><FONT SIZE=4><B>cmw2macro</B></FONT> - Compile a user&#X2019;s macro : make it available and generate the document skeleton</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>cmw2macro [-adm] [-ret] [-path path] [-absolute] macro</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command writes the document skeleton (the <CODE>.doc</CODE> file) 
corresponding to the macro <CODE>macro</CODE>, and it creates a symbolic
link in <CODE>$MY_MEGAWAVE2/shell</CODE> (or in <CODE>$MEGAWAVE2/shell</CODE> if 
the option <CODE>-adm</CODE> is selected), so that you can call these macro
from any location. 
You should not have to use directly this command, since it is called by
<CODE>cmw2</CODE>, <CODE>mwmakedoc</CODE> or <CODE>mwdoclatex</CODE> when needed.
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-adm</CODE> : search <CODE>macro</CODE> in <CODE>$MEGAWAVE2</CODE> (instead of 
<CODE>$MY_MEGAWAVE2</CODE>.</P><P><CODE>-ret</CODE> : return filename (with pathname) of the document skeleton.</P><P><CODE>-path path</CODE> : search <CODE>macro</CODE> in <CODE>path</CODE> (instead of 
in <CODE>$MY_MEGAWAVE2</CODE>).</P><P><CODE>-absolute</CODE> : create link using absolute pathname (since cmw2macro version 2.08,
default is to create link with relative pathname).</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default194"></A></P><P><FONT SIZE=4><B>cxmw2</B></FONT> - The XMegaWave2 Compiler</P><P><BR>
<BR>
<BR>

<A NAME="@default195"></A>
<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>cxmw2 [-gnu] [-g] [-O] [-Dname[=def]] [-Uname] [-Ipathname] [-w] [-Ldirectory]</CODE><BR>
<CODE>      [-llibrary] modules_file</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command allows to compile your own version of the XMegaWave2 software.
The version is defined by the modules you want to include in the software.
Each module name will appear into a window panel, inside a window hierarchy
defined by the group of the module. 
The input of <CODE>cxmw2</CODE> is an ascii file which gives the list of the modules
to include together with the groups hierarchy.
Please see Section&#XA0;<A HREF="#sysmacros_list">5.2</A> to learn more about the format
of this file.
In order to be included in XMegaWave2, each module must have been compiled
with <CODE>cmw2</CODE> using option <CODE>-X</CODE>.</P><P>The name of the XMegaWave2 run-time program is <CODE>myxmw2</CODE>.
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-gnu</CODE> : Use the Gnu C compiler <CODE>gcc</CODE> instead of the standard C compiler <CODE>cc</CODE>.</P><P><CODE>-g</CODE> : Debug flag. Cause the compiler to generate additional information
needed by the symbolic debugger. This option is incompatible with optimization.</P><P><CODE>-O</CODE> : Invoke the C optimizer. This option is incompatible with debugging.</P><P><CODE>-Dname</CODE> : Define <CODE>name</CODE> to the preprocessor, as if by <CODE>'#define'</CODE>.</P><P><CODE>-Uname</CODE> : Remove any initial definition of <CODE>name</CODE> in the preprocessor. </P><P><CODE>-Ipathname</CODE> : Change the algorithm used by the preprocessor for finding include files to also search in directory <CODE>pathname</CODE>.</P><P><CODE>-Ldirectory</CODE> : Change the algorithm used by the linker to search for
the libraries. The -L option causes the compiler to search in <CODE>directory</CODE> before searching in the default locations.</P><P><CODE>-llibrary</CODE> : Include additional library given by <CODE>library</CODE> for linking.</P><P><CODE>-w</CODE> : Suppress warning messages.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default196"></A></P><P><FONT SIZE=4><B>mwmakedoc</B></FONT> - Make a new documentation for the modules (Volume 3)</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwmakedoc [-c] [-h] [-N] [-g group_directory] [-nobin] [+/-index] [+/-html]</CODE><BR>
<CODE>          mw2dir</CODE>
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command creates the T<sub>E</sub>X files corresponding to the Volume Three of the MegaWave2 guides 
(&#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D;).
The documentation is written in order to keep consistency with the current
MegaWave2 modules and macros put in the directory <CODE>mw2dir</CODE> 
(e.g. <CODE>$MEGAWAVE2</CODE>, <CODE>$MY_MEGAWAVE2</CODE> or a selected copy of such 
directories).
The T<sub>E</sub>X files are written in the directory <CODE>mw2dir/doc</CODE>, so you need
write permission in this directory.
The modules, located into <CODE>mw2dir/src</CODE>, must have been compiled in order
to fill the target directories <CODE>mw2dir/bin</CODE> and <CODE>mw2dir/doc</CODE>
(not applicable for macros).
Each module and macro must be documented that is, a <CODE>M.tex</CODE> file must 
be written in <CODE>mw2dir/doc</CODE> for all <CODE>M</CODE> modules and macros
(see Section&#XA0;<A HREF="#document">7</A> for more information).</P><P>In order to compile the documentation, run L<sup>A</sup>T<sub>E</sub>X several times (as well as
other commands, such as <TT>mwmodbibtex</TT> and <TT>makeindex</TT>) as mentioned at the end
of the execution of this command, or set option <TT>-c</TT>.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-c</CODE> : Compile the documentation (Volume 3) after T<sub>E</sub>X files have been created.</P><P><CODE>-h</CODE> : Make a html (HyperText Markup Language) version of the documentation (Volume 3) using <TT>latex2html</TT>. Need <TT>-c</TT>. The generation of all html files may take a while.</P><P><CODE>-N</CODE> : Identify the command to be not the primary process (internal use). </P><P><CODE>-g group_directory</CODE> : Limit the scanning of modules to the given group directory (and sub-directories).</P><P><CODE>-nobin</CODE> : Do not check consistency with the binaries (i.e. a module for which the compilation failed may be documented).</P><P><CODE>+index</CODE> : Force the creation of an index for the modules. You normally do not need to set this option,
since it is the default if the <CODE>makeidx</CODE> L<sup>A</sup>T<sub>E</sub>X package is installed.
If the option is set, you will need this package in order to run L<sup>A</sup>T<sub>E</sub>X on the generated T<sub>E</sub>X files.</P><P><CODE>-index</CODE> : Do not create an index for the modules, even if the <CODE>makeidx</CODE> L<sup>A</sup>T<sub>E</sub>X package is 
installed.</P><P><CODE>+html</CODE> : Force the addition of html code in the T<sub>E</sub>X files, to make the result of <CODE>latex2html</CODE>
nicer (this command may be used to translate L<sup>A</sup>T<sub>E</sub>X files to HyperText Markup Language). 
You normally do not need to set this option, since it is the default if the <CODE>html</CODE> and
<CODE>hthtml</CODE> L<sup>A</sup>T<sub>E</sub>X packages are installed.
If the option is set, you will need these packages in order to run L<sup>A</sup>T<sub>E</sub>X on the generated T<sub>E</sub>X files.</P><P><CODE>-html</CODE> : Do not add html code in the T<sub>E</sub>X files, even if the <CODE>html</CODE> and
<CODE>hthtml</CODE> L<sup>A</sup>T<sub>E</sub>X packages are installed.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default197"></A></P><P><FONT SIZE=4><B>mwarch</B></FONT> - Machine architecture</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwarch [ -s || -k ]</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command displays the architecture of the current host.
MegaWave2 assumes that two machines with the same name returned by <CODE>mwarch</CODE> can run the same executables and can link the same objects.
Therefore, you may have to call <CODE>mwarch</CODE> with the option <CODE>-s</CODE> if MegaWave2 supports
several implementations (corresponding to incompatible operating systems) for the same
machine.</P><P>If <CODE>mwarch</CODE> returns &#X201C;unknown&#X201D;, you cannot run your version of MegaWave2 on this architecture.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-s</CODE> : Add to the architecture name a suffix to identify the release of the operating system.</P><P><CODE>-k</CODE> : Give long architecture name.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default198"></A></P><P><FONT SIZE=4><B>mwcleandistrib</B></FONT> - Clean from objects and old files the MegaWave2 Distribution (adm only)</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwcleandistrib mw2_distrib_dir</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This macro can be used to remove all unnecessary files from the MegaWave2 distribution directory
named <CODE>mw2_distrib_dir</CODE> (recursively inside each subdirectory), in order to clean it.
Files removed are old files generated by <CODE>emacs</CODE> (i.e. ending by <CODE>~</CODE>) and objects.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default199"></A></P><P><FONT SIZE=4><B>mwcmwcheck</B></FONT> - Check the MegaWave2 compiler (adm only)</P><P><BR>
<BR>
<BR>

<A NAME="@default200"></A>
<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwcmwcheck</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This macro checks the MegaWave2 compiler <CODE>cmw2</CODE> by blind-compiling some standard
modules. It is intended to check if the kernel has been correctly installed on a new
architecture, before calling <CODE>cmw2_all</CODE>.
It should be used by the MegaWave2 administrator only, during the installation stage.</P><P>In case of errors, the output of <CODE>cmw2</CODE> is displayed and the macro exists with 
non-null error code.
If everything goes well, you should not experiment lot of problems by compiling
the whole modules of the standard distribution.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default201"></A></P><P><FONT SIZE=4><B>mwdep</B></FONT> - Make all the secondary dependencies lists</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwdep [ -adm ] [-v]</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command has to be called after all modules have been compiled using the option
<CODE>-dep</CODE> of <CODE>cmw2</CODE> or <CODE>cmw2_all</CODE>, since it needs the primary dependencies lists of each module<BR>
<CODE>$MY_MEGAWAVE2/doc/obj/DEPENDENCIES/*.mis</CODE>). 
From those files, <CODE>mwdep</CODE> generates in<BR>
<CODE>$MY_MEGAWAVE2/doc/obj/DEPENDENCIES</CODE> the following files, one per module <CODE>&lt;M&gt;</CODE>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>&lt;M&gt;.called</CODE> lists the modules called by <CODE>&lt;M&gt;</CODE>;
</LI><LI CLASS="li-itemize"><CODE>&lt;M&gt;.calling</CODE> lists the modules calling <CODE>&lt;M&gt;</CODE>;
</LI><LI CLASS="li-itemize"><CODE>&lt;M&gt;.dep</CODE> is a T<sub>E</sub>Xfile which lists the modules called by <CODE>&lt;M&gt;</CODE> followed
by the modules calling <CODE>&lt;M&gt;</CODE>. 
</LI></UL><P>The file <CODE>&lt;M&gt;.dep</CODE> is included by the documentation file to constitute the &#X201C;See Also&#X201D; field.
Therefore, run <CODE>mwdep</CODE> before <CODE>mwmakedoc</CODE>,
<CODE>mwdoclatex</CODE> or <CODE>mwdocxdvi</CODE> if you want to get the right &#X201C;See Also&#X201D; fields in your documentation.</P><P>The file <CODE>&lt;M&gt;.calling</CODE> is used by <CODE>cmw2</CODE> to issue a warning message when the
module <CODE>&lt;M&gt;</CODE> is compiled: you should re-compile also all the modules listed in
<CODE>&lt;M&gt;.calling</CODE>. </P><P>Warning : because this command uses the output generated by the link editor, it is 
linker and language-dependent. Only a subset of linkers and languages is supported
(english is always supported; french is supported on some linkers).
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-adm</CODE> : Administrator flag. The developer&#X2019;s directory is <CODE>$MEGAWAVE2</CODE> instead of <CODE>$MY_MEGAWAVE2</CODE>. The user must have write permission into this directory.</P><P><CODE>-v</CODE> : Verbose. Write more information on the standard output.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default202"></A></P><P><FONT SIZE=4><B>mwdoc</B></FONT> - Easy access to the documentation</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwdoc [&lt;name&gt; || M || S || F || 1 || 2 || 3]</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command offers an easy access to the documentation. Since objects doc files are in the
DeVice Independent (DVI) file format, your system must support the DVI previewer <CODE>xdvi</CODE>.
If you call <CODE>mwdoc</CODE> without argument, it will ask you to tell him what kind of doc you
are seeking. You may also put directly in argument the doc you want.</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>&lt;name&gt;</CODE> : The word <CODE>&lt;name&gt;</CODE> is supposed to be the name of a module or of a user&#X2019;s macro.
This causes to view the doc of the correponding module or user&#X2019;s macro. </P><P><CODE>M</CODE> or <CODE>m</CODE> : List all modules and user&#X2019;s macro with a short description.</P><P><CODE>S</CODE> or <CODE>s</CODE> : List all system&#X2019;s macros with a short description.</P><P><CODE>F</CODE> or <CODE>f</CODE> : List all available external (file) types with a short description. To reduce the
list to the file types you are looking for, after the prompt specify a keyword.</P><P><CODE>1</CODE> : View the Volume 1, MegaWave2 User&#X2019;s Guide.</P><P><CODE>2</CODE> : View the Volume 2, MegaWave2 System Library.</P><P><CODE>3</CODE> : View the Volume 3, MegaWave2 User&#X2019;s Modules and Macros Library.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default203"></A></P><P><FONT SIZE=4><B>mwecho</B></FONT> - Portable echo with -n and -E options</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwecho [-n] [-E] ...</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command emulates a portable <CODE>echo</CODE> command with -n and -E options.
The command <CODE>mwecho -n</CODE> replaces <CODE>mwechon</CODE> which is no more furnished.
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-n</CODE> : Do not output the trailing newline.</P><P><CODE>-E</CODE> : Disable interpretation of backslash-escaped characters. </P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default204"></A></P><P><FONT SIZE=4><B>mwinstall</B></FONT> - Install MegaWave2 (administrator only)</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwinstall [-traditional] [-static] [-public || -public=private]</CODE><BR>
<CODE>          [-clear] [-debug] [-level l] mw2distribution</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command is for the MegaWave2 Administrator only. Remember that the Administrator is the one
which is supposed to install, maintain and update MegaWave2 for all users.
This command may be called directly, but you may also use the shell <CODE>Install</CODE> in the root
directory of <CODE>mw2distribution</CODE> where <CODE>mw2distribution</CODE> is an original MegaWave2 
Distribution Package (<CODE>$PRIVATE_MEGAWAVE2</CODE>). 
The main steps of the installation are as follows :
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The environment variables needed to run most macros are built, using the macro <CODE>mwsetenv</CODE>.
</LI><LI CLASS="li-enumerate">The kernel is compiled for your machine architecture, using installation shells and makefiles
located in <CODE>mw2distribution/kernel</CODE>. The kernel is composed by the Wdevice library 
(interface with the Window System), by the System library, and by the preprocessor.
</LI><LI CLASS="li-enumerate">The modules and user&#X2019;s macros are compiled for your machine architecture, using the
macro <CODE>cmw2_all</CODE>.
</LI><LI CLASS="li-enumerate">The volume 3 of the documentation (User&#X2019;s Modules and Macros Library) is generated, using
macros <CODE>mwdep</CODE> and <CODE>mwmakedoc</CODE>.
</LI><LI CLASS="li-enumerate">If the option <CODE>-public</CODE> has been selected, a list of successfully compiled modules
and user&#X2019;s macros is written using the macro <CODE>mwmodlist</CODE>, and modules and user&#X2019;s macros
of this list are installed into the public MegaWave2 using the macro <CODE>mwmodinstall</CODE>.
</LI></OL><P>The macro <CODE>mwinstall</CODE> is intended to allow an easy installation process on the very most common
machines and configurations only. 
It means that something goes wrong is not an unlikely event. In that case, you will have to
correct the wrong things by yourself and to rerun the macro, eventually using the option 
<CODE>-level l</CODE> to avoid levels already completed. Or you will have to make the installation
&#X201C;manually&#X201D; that is, by calling lower-levels macros. Such manual installation is not a bad
idea, even if everything goes well with <CODE>mwinstall</CODE>. A manual installation allows to
customize MegaWave2 more deeply than the standard one. For example, you may want to install
in the public MegaWave2 a subset of the private modules only. This can be easily done by editing
the list of modules written by <CODE>mwmodlist</CODE>, before calling <CODE>mwmodinstall</CODE>.</P><P>Be aware that, since the installation is machine-dependent, you should install MegaWave2 on each
machine architecture for which you want to be able to use it. Of course, if for each installation
you specify the same public MegaWave2 directory, source files will not be duplicated.
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-traditional</CODE> : When compiling modules, use the &#X2019;traditional&#X2019; preprocessor instead of the &#X2019;light&#X2019; one
(see Section&#XA0;<A HREF="#intro_main_changes">1.4</A> page&#XA0;<A HREF="#intro_main_changes">??</A>).</P><P><CODE>-static</CODE> : Make static kernel libraries (by default, kernel libraries are shared). Selecting
this option may be hazardous since modules linked with static libraries are of big size. 
You should use it after having installed the shared libraries only (do not select <CODE>-clear</CODE> or
you will remove them), so that by default modules would be still dynamically linked. 
To statically link a module, call <CODE>cmw2 -c cc_opt</CODE> with <CODE>cc_opt</CODE> the corresponding cc option
(e.g. <CODE>-c -static</CODE> with <CODE>gcc</CODE>).
The advantage of a module statically linked lies in the fact that it can be executed without
the libraries. In addition, some debuggers have strange behavior when used with dynamically linked
modules. </P><P><CODE>-public</CODE> : Install two MegaWave2, the private one for the administrator only and the second
one for plain users. In this way, the administrator will be able to change and check modules, 
user&#X2019;s or system&#X2019;s macros and functions of the kernel libraries without touching the public version.
This option is obviously usefull only if several persons intensively use MegaWave2, and if you
plan to update MegaWave2.</P><P><CODE>-public=private</CODE> : Allow other persons than the administrator to use the private MegaWave2.
By default, the administrator is the only one supposed to use the private MegaWave2.</P><P><CODE>-clear</CODE> : Clear objects in the previous installation.</P><P><CODE>-debug</CODE> : Pass the debug option to the C compiler. By default, the C compiler is called with
the optimization flag.</P><P><CODE>-level l</CODE> : Do not start the installation from the beginning (level 1) but from level <I>l</I>.
This supposes that previous levels have been successfully completed. 
In particular, the environment variables must be correctly set in the shell from which you
call <CODE>mwinstall</CODE>.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default205"></A></P><P><FONT SIZE=4><B>mwmodbibtex</B></FONT> - Run BibTeX on the MegaWave2 documentation (guide #3) and add reference to modules</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwmodbibtex mw2dir</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command replaces the <TT>bibtex</TT><A NAME="@default206"></A> command included in standard T<sub>E</sub>X packages, when
compiling the &#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D; documentation (guide #3) into
the subdirectory <TT>mw2dir</TT>/doc.
In addition of calling <TT>bibtex</TT> to create a bibliography file <TT>guid3.bbl</TT>, 
<TT>mwmodbibtex</TT> adds to the bibliography<A NAME="@default207"></A> file a list of references to modules : 
at the end of each bibliographical reference, the list of modules making citation<A NAME="@default208"></A> to 
this reference is added. As a result of, the guide #3 obtained by normally post-processing
the file with L<sup>A</sup>T<sub>E</sub>X (as written when the command <TT>mwmakedoc</TT> ends) will contain, 
in the bibliography section, a list of modules associated to bibliographical references.</P><P>As well as <TT>bibtex</TT>, use of <TT>mwmodbibtex</TT> assumes at least one bibliographic database
(.bib file) exists. The needed one is <CODE>$MEGAWAVE2/doc/public.bib</CODE><A NAME="@default209"></A> which contains references
for public modules. It is normally included in standard MegaWave2 distribution. Put references for 
private modules in <CODE>$MY_MEGAWAVE2/doc/private.bib</CODE><A NAME="@default210"></A>.</P><P>In addition to standard fields one uses into public.bib and private.bib files, one may specify a WWW 
url<A NAME="@default211"></A> by using the special command <CODE>\hturl</CODE><A NAME="@default212"></A>, as in the following :
</P><PRE CLASS="verbatim">  note   =  "See \hturl{http://www.cmla.ens-cachan.fr/Cmla/Megawave}"
</PRE><P>By doing this, the corresponding url will become an active hyperlink<A NAME="@default213"></A> when the L<sup>A</sup>T<sub>E</sub>X 
documentation file will be processed through the <TT>latex2html</TT> command (and no error
will be encountered if the <TT>latex2html</TT> package is not available).</P><P>Beware : when documenting module M in M.tex, do not collapse citations.<BR>
Use e.g. <CODE>\cite{key1}\cite{key2}</CODE> instead of <CODE>\cite{key1,key2}</CODE>. </P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default214"></A></P><P><FONT SIZE=4><B>mwmodinstall</B></FONT> - Install a new MegaWave2 public modules environment (administrator only)</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwmodinstall [-clear] [-tdir target_directory]</CODE><BR>
<CODE>              [-X file_of_xmw2_modules] file_of_modules</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command allows to copy selected modules and user&#X2019;s macros from the source directory 
<CODE>$PRIVATE_MEGAWAVE2</CODE> to the target directory <CODE>$PUBLIC_MEGAWAVE2</CODE>.
It can be used by the administrator only to make some private modules available for all.
The command copies not only the module sources, but also everything associated such as
objects, binaries, documentation and data. 
The content of <CODE>$PRIVATE_MEGAWAVE2/data/PUBLIC</CODE> is always entirely copied.</P><P>The file <CODE>file_of_modules</CODE> lists the modules to be copied. See 
Section&#XA0;<A HREF="#sysmacros_list">5.2</A> for more informations about such modules file.
In the case where your configuration is such that<BR>
<CODE>$PRIVATE_MEGAWAVE2 = $PUBLIC_MEGAWAVE2</CODE>, this macro is obviously useless.</P><P>Before running this command (which may take a while), run <CODE>mwmodcheck</CODE> to check
the consistency of the modules file regarding the content of the source directory.
This macro will tell you any modules listed in the file but not in the source directory,
incomplete modules (e.g. without documentation attached) and, for information, modules 
which will remain private (i.e. in the source directory but not listed in the file).
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-clear</CODE> : Clear previous modules in <CODE>$PUBLIC_MEGAWAVE2</CODE>. This option should
be used each time the administrator wants to make a complete new version of the
public modules. </P><P><CODE>-tdir target_directory</CODE> : Change default target directory <CODE>$PUBLIC_MEGAWAVE2</CODE> to be<BR>
<CODE>target_directory</CODE>.</P><P><CODE>-X file_of_xmw2_modules</CODE> : Generate a public XMegaWave2 software containing the 
modules listed in the file <CODE>file_of_xmw2_modules</CODE>.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default215"></A></P><P><FONT SIZE=4><B>mwmodlist</B></FONT> - List the modules and macros found in a MegaWave2 source directory</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwmodlist [-mfile] [-bad] [-group gdir] mw2dir</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command prints all the modules and macros found in the directory <CODE>mw2dir</CODE>, 
which has to be a MegaWave2 directory such as <CODE>$MEGAWAVE2</CODE> or <CODE>$MY_MEGAWAVE2</CODE>.
In case of a module not successfully compiled, a warning is issued.
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-mfile</CODE> : print the list in the modules file format (which is compatible with 
input of macros like <CODE>mwmodinstall</CODE>). See Section&#XA0;<A HREF="#sysmacros_list">5.2</A> for more 
informations about this format.</P><P><CODE>-bad</CODE> : print modules which are not successfully compiled only.</P><P><CODE>-group gdir</CODE> : restrict the list to the group and subgroups of <CODE>gdir</CODE>.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default216"></A></P><P><FONT SIZE=4><B>mwmodsearch</B></FONT> - Search for modules matching words</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwmodsearch [-l] [-public] [-private] word_1 [word_2 ... word_n]</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command searches for modules and user&#X2019;s macros matching the given list of words. It is useful when you are
seeking a specific algorithm without any idea about the module&#X2019;s name or even about the group&#X2019;s name, and
when the short function description (as returned by <TT>mwmodlist</TT>) is not enough to perform a search on.</P><P>With <TT>mwmodsearch</TT>, the search is performed both on the source file and on the documentation (tex file). 
Only one matching file is enough to satisfy the search. 
But when several words are given, all words must be found in the same file.</P><P>By default, each matching lines are printed together with the name of the file. This may result to a pretty
huge number of lines if the words are common. In such a case, use -l and try to reduce the number of matching
modules by adding new keywords.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-l</CODE> : list only. Do not output matching lines, but only the list of matching modules.</P><P><CODE>-public</CODE> : restricts search to public modules and user&#X2019;s macros.</P><P><CODE>-private</CODE> : restricts search to private modules and user&#X2019;s macros.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default217"></A></P><P><FONT SIZE=4><B>mwnewuser</B></FONT> - Create the directory hierarchy for a new user</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwnewuser</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
If you are a new user, you may run this command once: it creates the directory
<CODE>$MY_MEGAWAVE2</CODE> and all subdirectories needed by the MegaWave2 system&#X2019;s macros.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default218"></A></P><P><FONT SIZE=4><B>mwrm</B></FONT> - Remove module(s) or user&#X2019;s macro(s)</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwrm [-macro] M</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command searches all modules (or user&#X2019;s macros) named <CODE>M</CODE> and removes
them from the system (confirmation is requested before to operate).
By using this command instead of directly removing the source files, you make
sure to remove all objects and references attached to the modules.</P><P>Only the MegaWave2 administrator should be able to remove public modules and macros.
Therefore make sure the <CODE>$PUBLIC_MEGAWAVE2</CODE> directory is not writable for plain
users.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-macro</CODE> : Say that <CODE>M</CODE> is a user&#X2019;s macro and not a module.
You normally don&#X2019;t need to set this option, since the command recognizes if 
<CODE>M</CODE> is a macro by its name, which should begin with a capital letter. </P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default219"></A></P><P><FONT SIZE=4><B>mwrnwordmod</B></FONT> - Rename words inside modules</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwrnwordmod [-adm] [-all] [-check] [-d dir] [-f file_of_names]</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
Sometimes the name of a system&#X2019;s function, of a structure or of a
structure field may change. In such a case, you may use this macro in order to
automatically perform the change of name inside each modules.</P><P>At the location of the macro <CODE>mwrnwordmod</CODE>, you can also find the
file <CODE>mwrnwordmod.data</CODE> : this is an Ascii file which gives the list of
words to change, in the obvious format <CODE>old_name new_name</CODE> (one change
per line).</P><P>This list is updated to reflect the last change of names we have performed
in the kernel.
By default (if you do not use the <CODE>-f</CODE> option), this is this file
which is read to perform the changes.
The <CODE>mwrnwordmod.data</CODE> is usefull if you have written lot of modules
and if you install a new MegaWave2 kernel, for which some function names
or structures have changed.</P><P>Warning :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The replacement is performed using the stream editor <CODE>sed</CODE>.
Therefore, the string(s) to be searched is specified by a <CODE>regex</CODE>
(regular expression).
</LI><LI CLASS="li-itemize">Be aware that the content of the file is not analyzed : for example, if you
wish to change a field named <CODE>open</CODE> to <CODE>is_open</CODE>, all occurrences
of &#X201C;open&#X201D; will be touched, including those inside comments.
</LI><LI CLASS="li-itemize">It is recommended to make a copy of the <CODE>src</CODE> directory before
running this macro : if the result does not match your wish, you will be
able to restore the old state.
</LI></UL><P>
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-adm</CODE> : administrator flag. Scan <CODE>$MEGAWAVE2/src</CODE> directory instead of the
default <CODE>$MY_MEGAWAVE2/src</CODE></P><P><CODE>-all</CODE> : scan all files (not only modules, that is .c files)</P><P><CODE>-check</CODE> : check only. See files that would be changed, but change nothing.</P><P><CODE>-d dir</CODE> : scan directory <CODE>dir</CODE> instead of <CODE>$MY_MEGAWAVE2/src</CODE> or
<CODE>$MEGAWAVE2/src</CODE>.</P><P><CODE>-f file_of_names</CODE> : use this file instead of the list given by
<CODE>mwrnwordmod.data</CODE>. </P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default220"></A></P><P><FONT SIZE=4><B>mwsetenv</B></FONT> - Set up the environment variables needed by MegaWave2 (adm only)</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwsetenv [-public=private || privateonly] mw2distribution</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command helps the administrator to set the environment variables needed by 
most user&#X2019;s macros. See Section&#XA0;<A HREF="#install_system_set-up">2.1.4</A> to learn more about
the environment variables.
The directory <CODE>mw2distribution</CODE> must corresponds to an original MegaWave2 Distribution Package,
its name will be the value set to the variable <CODE>$PRIVATE_MEGAWAVE2</CODE>.</P><P>As a result of, this macro write two files to be used by the administrator and two files
for plain users (one for Bourne-compatible shells and one for C-compatible shells). 
Those files, which may have to be customized, are to be included in the <CODE>.profile</CODE> or the 
<CODE>.cshrc</CODE> file. The location of these files are given at the end of the macro execution.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-privateonly</CODE> : Select this option if there is no public MegaWave2.
By default, this macro considers that both a public MegaWave2 and a private one has to be installed.</P><P><CODE>-public=private</CODE> : Select this option if there is no public MegaWave2 and if the installation 
allows other persons than the administrator to use the private MegaWave2. </P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default221"></A></P><P><FONT SIZE=4><B>mwsysmaclist</B></FONT> - List all system&#X2019;s macros</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwsysmaclist</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command prints all the system&#X2019;s macros found in the directory <CODE>$MEGAWAVE2/sys/shell</CODE>.
</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default222"></A></P><P><FONT SIZE=4><B>mwvers</B></FONT> - MegaWave2 Version</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwvers [-major || -minor || -variant]</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
</P><P>This command returns the current version number of the public MegaWave2 
software you are using. 
Please refer to this version number when you report bugs.
On MegaWave2 Version 1.x, this command was available on MegaWave2 system issued from the 
distribution package only. This is no more the case.
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-major</CODE> : Return the major version number only (e.g. 2 if the full version is 2.00a.12)</P><P><CODE>-minor</CODE> : Return the minor version number only (e.g. 00a if the full version is 2.00a.12)</P><P><CODE>-variant</CODE> : Return the variant version number only (e.g. 12 if the full version is 2.00a.12)</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default223"></A></P><P><FONT SIZE=4><B>mwwhere</B></FONT> - Give the location of the source of a module or user&#X2019;s macro</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwwhere [-macro] [-bin] M</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command returns the path where the source of the given module or user&#X2019;s macro 
<CODE>M</CODE> is found, searching first for private modules and then for public ones.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-macro</CODE> : Say that <CODE>M</CODE> is a user&#X2019;s macro and not a module.
You normally don&#X2019;t need to set this option, since the command recognizes if 
<CODE>M</CODE> is a macro by its name, which should begin with a capital letter. </P><P><CODE>-bin</CODE> : Return the path if the corresponding binary (executable) exists
only. When two paths are returned with this option set, it means that one module
is hidden (with default settings, the private module hides the public one).
In such a case, the macro exits with value 2.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default224"></A></P><P><FONT SIZE=4><B>mwdoclatex</B></FONT> - Make the documentation of a module or of a user&#X2019;s macro</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwdoclatex [-adm] M</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command compiles a single module documentation file using L<sup>A</sup>T<sub>E</sub>X.
Use it instead of the macro <CODE>mwmakedoc</CODE> when you want to print 
the documentation of only one module or user&#X2019;s macro (for example the one you just
finished to write).
If you rather want to see the documentation on the screen, use the
macro <CODE>mwdocxdvi</CODE>.</P><P>Run <CODE>mwdoclatex</CODE> after <CODE>cmw2</CODE> has been called so that the document 
skeleton <CODE>M.doc</CODE> exists.
Make sure to have written the corresponding T<sub>E</sub>Xfile (<CODE>M.tex</CODE>), see Section&#XA0;<A HREF="#document">7</A>.</P><P>This command calls L<sup>A</sup>T<sub>E</sub>X and, as the result, you get a <CODE>M.dvi</CODE> file
into the <CODE>$MY_MEGAWAVE2/doc/obj</CODE> directory which can be used to print the 
documentation.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-adm</CODE> : Say that <CODE>M</CODE> is a public module or a public macro
from <CODE>$MEGAWAVE2</CODE> and not from <CODE>$MY_MEGAWAVE2</CODE>.
In that case, if you are not the administrator but a plain user, and if the
administrator didn&#X2019;t make this doc already, the dvi file <CODE>M.dvi</CODE> is created into<BR>
<CODE>$MY_MEGAWAVE2/tmp/megawave2_doc/user</CODE>.</P><P>
<FONT SIZE=5><B>Macro</B></FONT> <BR>
<BR>
<A NAME="@default225"></A></P><P><FONT SIZE=4><B>mwdocxdvi</B></FONT> - Display on the screen the documentation of a given module</P><P><BR>
<BR>
<BR>

<FONT SIZE=5><B>Usage</B></FONT> <BR>
<BR>
</P><P><CODE>mwdocxdvi [-adm] [-macro] M</CODE></P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Description</B></FONT></P><P><BR>
<BR>
<BR>
This command compiles a single module documentation file using the macro
<CODE>mwdoclatex</CODE>, and then call the DVI previewer for the X Window System,
<CODE>xdvi</CODE>, to display the documentation on the screen.</P><P><BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Options</B></FONT> <BR>
<BR>
</P><P><CODE>-adm</CODE> : Say that <CODE>M</CODE> is a public module or a public macro
from <CODE>$MEGAWAVE2</CODE> and not from <CODE>$MY_MEGAWAVE2</CODE>.
In that case, if you are not the administrator but a plain user, and if the
administrator didn&#X2019;t make this doc already, the dvi file <CODE>M.dvi</CODE> is created into<BR>
<CODE>$MY_MEGAWAVE2/tmp/megawave2_doc/user</CODE>.</P><P><CODE>-macro</CODE> : Say that <CODE>M</CODE> is a user&#X2019;s macro and not a module.
In that case, the macro <CODE>cmw2macro</CODE> is called to generate a file
<CODE>M.doc</CODE>. You normally don&#X2019;t need to set this option, since the 
command recognizes if <CODE>M</CODE> is a macro by its name, which should 
begin with a capital letter. </P><!--TOC section List of modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc47">5.2</A>&#XA0;&#XA0;List of modules</H2><!--SEC END --><P>
<A NAME="sysmacros_list"></A>
<A NAME="@default226"></A></P><P>Some system&#X2019;s macros (e.g. <CODE>cxmw2</CODE>, <CODE>mwmodinstall</CODE>) need to know a list of 
modules you want to process together with the group hierarchy.
MegaWave2 uses a plain ascii format to describe such a list in a file.
You can write this file manually, or you can use the output generated by the macro
<CODE>mwmodlist</CODE> using <CODE>-mfile</CODE> option.</P><P>Each line of the file is normally filled by a module name.
They are special symbols which change the meaning of the line (those have to be the first character of the line)
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>%</CODE> : comments. The line is ignored. 
</LI><LI CLASS="li-itemize"><CODE>#</CODE> : keyword. The following keywords are available:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>#group group_name</CODE> : 
Give the group to which the next modules (or subgroups) belong. 
The hierarchy of the groups must be given that is, if <CODE>B</CODE> is a subgroup of the main group <CODE>A</CODE>, the line <CODE>#group A</CODE> must appear and after that, the line <CODE>#group A/B</CODE>.
</LI><LI CLASS="li-itemize"><CODE>#dir dirname</CODE> : 
Change the default source directory for the modules to be <CODE>dirname</CODE> (default is <CODE>$MEGAWAVE2</CODE>). Do not use this keyword for <CODE>cxmw2</CODE>.
</LI></UL>
</LI></UL><!--TOC chapter User&#X2019;s macros-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc48">Chapter&#XA0;6</A>&#XA0;&#XA0;User&#X2019;s macros</H1><!--SEC END --><P>
<A NAME="usermacros"></A>
</P><P>You have been already introduced to the macros by the 
section&#XA0;<A HREF="#intro_macros">1.8</A>.
An user&#X2019;s macro<A NAME="@default227"></A> is a Bourne shell<A NAME="@default228"></A> script which uses a normalized header,
and which calls a sequence of commands, such as MegaWave2 modules.</P><P>Since system&#X2019;s macros use the header of the user&#X2019;s macro to perform
some operations, as to make the documentation of the macro
(see section&#XA0;<A HREF="#document_macro">7.2</A>), you have to correctly fill the header 
when you write a new macro.</P><P>In order to easily recognize a user&#X2019;s macro from a user&#X2019;s module
(they are located in the same source directory), we use capital letters to 
name macros (at least for the first letter) and lower letters to name modules.
We recommand you to follow this convention.</P><!--TOC section Header of a Macro-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">6.1</A>&#XA0;&#XA0;Header of a Macro</H2><!--SEC END --><P>
<A NAME="usermacros_header"></A></P><P>Each macro must have an header<A NAME="@default229"></A> which consists of variables to be filled.
Falling to define most of these variables leads malfunctions when calling 
some systems&#X2019;s macros.</P><P>In the following is the list of the variables to define
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>_Prog</CODE>: Name of the macro.
</LI><LI CLASS="li-itemize"><CODE>_Group</CODE>: Group where belongs the macro.
</LI><LI CLASS="li-itemize"><CODE>_Func</CODE>: Short description of the function performed by the macro.
</LI><LI CLASS="li-itemize"><CODE>_Vers</CODE>: Version number of the macro.
</LI><LI CLASS="li-itemize"><CODE>_Date</CODE>: Year of the creation or last change.
</LI><LI CLASS="li-itemize"><CODE>_Auth</CODE>: Name of the author.
</LI><LI CLASS="li-itemize"><CODE>_Usage</CODE>: Usage line, following Unix command conventions (do not
mention the program name).
</LI><LI CLASS="li-itemize"><CODE>_Labo</CODE>: Name and address of the institution, when it is not
the CMLA.
</LI></UL><P>You can get examples of such headers by reading the source of some systems&#X2019;s 
macros (which share the same header conventions) or of some public user&#X2019;s
macros given in the distribution.</P><!--TOC section How to use user&#X2019;s macros-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc50">6.2</A>&#XA0;&#XA0;How to use user&#X2019;s macros</H2><!--SEC END --><P>
<A NAME="usermacros_howto"></A></P><P>An user&#X2019;s macro being a Bourne shell<A NAME="@default230"></A> script, you don&#X2019;t really need to compile 
it before to call it. But in order to be able to call it from any location,
a link has to be created in a directory recorded in the path variable
(which is <CODE>$MEGAWAVE2/shell</CODE> if you are the administrator,
<CODE>$MY_MEGAWAVE2/shell</CODE> otherwise). In addition to that, the documentation 
must also be generated. Therefore, you should compile a user&#X2019;s macro as
if it was a module, using <CODE>cmw2</CODE><A NAME="@default231"></A>.</P><!--TOC chapter Documentation-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc51">Chapter&#XA0;7</A>&#XA0;&#XA0;Documentation</H1><!--SEC END --><P>
<A NAME="document"></A>
</P><P><A NAME="@default232"></A>
<B>Warning : </B> in MegaWave2 versions 2.x, the <CODE>doc</CODE> directory structure has 
changed<A NAME="@default233"></A>.
Now put the documentation you write (the <CODE>.tex</CODE> files) into the 
<CODE>$MEGAWAVE2/doc/src/</CODE> directory (administrator) or <CODE>$MY_MEGAWAVE2/doc/src/</CODE> 
(plain user) directory, without creating subdirectories for the groups : the <CODE>.tex</CODE> 
files of all modules of all groups belong to the same directory.
The <CODE>$MEGAWAVE2/doc/obj/</CODE> and <CODE>$MY_MEGAWAVE2/doc/obj/</CODE> directories contain files
that are automatically generated (such as <CODE>.doc</CODE> and <CODE>.dvi</CODE> files). Do not put
your <CODE>.tex</CODE> files here, they may be destroyed by the system !</P><!--TOC section Document a module-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc52">7.1</A>&#XA0;&#XA0;Document a module</H2><!--SEC END --><P>
<A NAME="document_module"></A></P><P><A NAME="@default234"></A>
Each module you write must be documented.
MegaWave2 helps you as much as possible in this unattractive task:
when you compile a module, a document skeleton is generated in the directory
<CODE>$MEGAWAVE2/doc/obj/</CODE> (or <CODE>$MY_MEGAWAVE2/doc/obj/</CODE>).
It takes the name of the module and the extension <CODE>.doc</CODE>.
This file documents in the L<sup>A</sup>T<sub>E</sub>X<A NAME="@default235"></A> language about everything that could be
automatically done, as the synopsis of the run-time command, the summary of
the module function, the release number and the copyright for the authors and
laboratories.</P><P>(Un)Fortunately, there will always be a part of the documentation which cannot
be automatically generated: the mathematical description of the algorithm.
This part is the <EM>Description</EM> field of the documentation.
Therefore, the author of a new module must write this content in a file
into the <CODE>$MEGAWAVE2/doc/src/</CODE> (administrator only) or 
<CODE>$MY_MEGAWAVE2/doc/src/</CODE> (plain user) directory.
Give this file the name of the module with the extension <CODE>.tex</CODE>.
As the file will be inserted by MegaWave2 into the whole documentation, you must 
write the text using a subset of the L<sup>A</sup>T<sub>E</sub>X language.
In particular, don&#X2019;t use any commands about the style or the presentation
(as <CODE>\begin{document}</CODE>, <CODE>\documentstyle</CODE>, <CODE>\newpage</CODE>, <CODE>\section</CODE>, &#X2026;).</P><P>You can get a lot of examples of such documents by seeking the files into
subdirectories of <CODE>$MEGAWAVE2/doc/src</CODE>.</P><P>Since MegaWave2 V 2.21, the system uses bibliographic<A NAME="@default236"></A> databases where all citations<A NAME="@default237"></A>
are recorded. As this allows cross-references, it is now possible to get all modules associated to
a given article. In order to fulfill the new requirements, citations have to be set
in the <CODE>.tex</CODE> file using the standard <CODE>\cite</CODE> L<sup>A</sup>T<sub>E</sub>X command,
and the corresponding references have to be given in the bibliographic database (.bib file), NO MORE in the <CODE>.tex</CODE> file.
Beware, do not collapse citations : use e.g. <CODE>\cite{key1}\cite{key2}</CODE> instead of <CODE>\cite{key1,key2}</CODE>.
References for private modules have to be put in <CODE>$MY_MEGAWAVE2/doc/private.bib</CODE><A NAME="@default238"></A>
while references for public modules are in <CODE>$MEGAWAVE2/doc/public.bib</CODE><A NAME="@default239"></A>.
Of course, only references for private modules not in <CODE>public.bib</CODE> have to be in <CODE>private.bib</CODE>.
See the system macro <TT>mwmodbibtex</TT> for more information about the bibliographic database.</P><!--TOC section Document a macro-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc53">7.2</A>&#XA0;&#XA0;Document a macro</H2><!--SEC END --><P>
<A NAME="document_macro"></A></P><P><A NAME="@default240"></A>
The documentation of a macro follows the same rules as the ones for modules.
Therefore, for each new user&#X2019;s macro, you must write a description file 
<CODE>$MEGAWAVE2/doc/src/MACRO.tex</CODE> (for a public macro, administrator only), or 
<CODE>$MY_MEGAWAVE2/doc/src/MACRO.tex</CODE> (for a private macro), <CODE>MACRO</CODE> being 
the name of the macro located in a subdirectory of <CODE>$MEGAWAVE2/src/</CODE> (or of
<CODE>$MY_MEGAWAVE2/src/</CODE>).
In this file, you put in L<sup>A</sup>T<sub>E</sub>X the part which corresponds to the <EM>Description</EM> field of 
the documentation.</P><P>The difference between macros and modules is that macros do not need really need a compilation,
and therefore you may call a specific command to generate the document skeleton<BR>
<CODE>$MEGAWAVE2/doc/obj/MACRO.doc</CODE> (or <CODE>$MY_MEGAWAVE2/doc/obj/MACRO.doc</CODE>),
which is the macro <CODE>cmw2macro</CODE> (see section&#XA0;<A HREF="#sysmacros_summary">5.1</A>).
Since MegaWave2 Versions 2.x, <CODE>cmw2</CODE> will also perform this task if its argument
is a user&#X2019;s macro.</P><!--TOC section Print the documentation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc54">7.3</A>&#XA0;&#XA0;Print the documentation</H2><!--SEC END --><P>
<A NAME="document_print"></A></P><P><A NAME="@default241"></A>
Once the document skeleton of a module or macro is generated, and the description file is
written, you can compile the document skeleton by calling the macro <CODE>mwdoclatex</CODE>
<A NAME="@default242"></A> (see section&#XA0;<A HREF="#sysmacros_summary">5.1</A>).
Of course this needs to have the L<sup>A</sup>T<sub>E</sub>X<A NAME="@default243"></A> environment installed on your system.
You get a <CODE>DVI</CODE> file which can be printed on various devices using commands of the standard TeXware distribution.</P><P>If you want to print the documentation of all modules and user&#X2019;s macros instead of only one,
use the macro <CODE>mwmakedoc</CODE><A NAME="@default244"></A>. 
This will actually create an updated sample of the Volume Three of the MegaWave2 guides (&#X201C;MegaWave2 User&#X2019;s Modules Library&#X201D;).</P><P>In the document skeleton of each module (not available for macros), a field named 
&#X201C;See Also&#X201D; lists all the modules calling the module or called by the module: 
this is a dependencies list. In order to update this
list, you need to compile each module which the option <CODE>-dep</CODE> and you need to
run the macro <CODE>mwdep</CODE><A NAME="@default245"></A> before the macros <CODE>mwdoclatex</CODE> and <CODE>mwmakedoc</CODE>.

</P><!--TOC chapter Annex-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc55">Chapter&#XA0;8</A>&#XA0;&#XA0;Annex</H1><!--SEC END --><P>
<A NAME="annex"></A>
</P><!--TOC section License-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc56">8.1</A>&#XA0;&#XA0;License</H2><!--SEC END --><P>
<A NAME="annex_license"></A></P><P>You do not have to send a registration<A NAME="@default246"></A> form any longer, but by using MegaWave2 you are still
supposed to follow the term of the MegaWave2 Public License<A NAME="@default247"></A> below.</P><DIV CLASS="center">
<FONT SIZE=4><B>MEGAWAVE2 PUBLIC LICENSE<BR>
Terms and conditions for using, copying, distribution and modification of MegaWave2 version 2.x.
</B></FONT>
</DIV><P>You acknowledge to be informed about the following facts, and you accept the consequences:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
MegaWave2 is a &#X201C;soft-publication&#X201D; for the scientific community, 
maintained by the image department of the CMLA, URA CNRS 1611 de l&#X2019;Ecole Normale Sup&#XE9;rieure de Cachan.
</LI><LI CLASS="li-itemize">The image department is founded by the CMLA only, using public funds
and private grants for software development.
</LI><LI CLASS="li-itemize">MegaWave2 has been implemented for research purposes only; it comes therefore
without any warranty.
</LI><LI CLASS="li-itemize">The MegaWave2 compiler and the system libraries are known to run on some computer models and operating 
systems only.
</LI><LI CLASS="li-itemize">The CMLA may not maintain this software in the future.
</LI><LI CLASS="li-itemize">The CMLA can not help any user to install nor to use the software.
</LI><LI CLASS="li-itemize">The CMLA may not publish all the code contained in the various versions of MegaWave2.
</LI><LI CLASS="li-itemize">For transparency, the published code contains the source of the mathematical algorithms developed at the 
CMLA.
You are allowed to copy, modify and redistribute these programs.
</LI></UL><P>The CMLA claims to impose on the diffusion and on the use of its software the
same rules as the well-known rules which apply to paper publication.</P><P>You agree to
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
inform without delay the CMLA (see address next page)
about any contract between yourself or your department and any private or public organization, whenever
its execution uses an algorithm (modified or not) included in MegaWave2.
You will inform this organization about the origin of these algorithms by writing in the contract the use of the 
MegaWave2 software.
</LI><LI CLASS="li-itemize">mention in all products (as computer programs or scientific papers) 
which take advantage of an algorithm included in MegaWave2 (modified or not), the use of this
software together with the name(s) of the author(s) written in the header of 
the corresponding module and with the address of the CMLA and of 
other laboratories implied in the development, if any.
</LI></UL><!--TOC section How to contact the CMLA-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc57">8.2</A>&#XA0;&#XA0;How to contact the CMLA</H2><!--SEC END --><P>
<A NAME="annex_contact"></A></P><P><A NAME="@default248"></A><A NAME="@default249"></A>
Please 
visit our <EM>World Wide WEB</EM> homepagehttp://www.cmla.ens-cachan.fr/<A NAME="@default250"></A>
at the following URL :<BR>
http://www.cmla.ens-cachan.fr/.
By selecting the 
<EM>MegaWave</EM> linkhttp://megawave.cmla.ens-cachan.fr/, 
you will get the latest news
on MegaWave2.</P><P>At this site you will be able to
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
download the latest version of MegaWave2<A NAME="@default251"></A>;
</LI><LI CLASS="li-enumerate">get access to the MegaWave2 forum<A NAME="@default252"></A> 
(to submit a question and to read the answers given to former questions);
</LI><LI CLASS="li-enumerate">submit new modules;
</LI><LI CLASS="li-enumerate">propose some corrections on the existing modules and kernel;
</LI><LI CLASS="li-enumerate">inform the CMLA about contracts or products which use algorithms included in MegaWave2, as
it is required by the MegaWave2 Public License<A NAME="@default253"></A>;
</LI><LI CLASS="li-enumerate">report bugs, remarks, &#X2026;</LI></OL><P>Be sure that, even if we are not always able to answer, all mails will be read and remarks will 
be take into consideration for a new release.</P><P><B>Address</B>: MegaWave, CMLA, Ecole Normale Sup&#XE9;rieure de Cachan, 61 avenue du Pr&#XE9;sident Wilson,
94235 Cachan cedex, France.<A NAME="@default254"></A></P><P><B>E-mail</B>: megawave@cmla.ens-cachan.fr<A NAME="@default255"></A></P><!--TOC chapter Index-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Index</H1><!--SEC END --><P></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">
address, <A HREF="#@default254">8.2</A>
</LI><LI CLASS="li-indexenv">administrator, <A HREF="#@default47">2.1</A>
</LI><LI CLASS="li-indexenv">argument, see <I>usage</I>
</LI><LI CLASS="li-indexenv">author, <A HREF="#@default112">3.1</A>, <A HREF="#@default155">4.1.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Bourne shell, <A HREF="#@default36">1.8</A>, <A HREF="#@default228">6</A>, <A HREF="#@default230">6.2</A>
</LI><LI CLASS="li-indexenv">bibliography, <A HREF="#@default207">5.1</A>, <A HREF="#@default236">7.1</A>
</LI><LI CLASS="li-indexenv">bibtex, <A HREF="#@default206">5.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">CEREMADE, <A HREF="#@default3">1.2</A>
</LI><LI CLASS="li-indexenv">Cimage, <A HREF="#@default107">3.1</A>
</LI><LI CLASS="li-indexenv">CMLA, <A HREF="#@default6">1.2</A>, <A HREF="#@default248">8.2</A>
</LI><LI CLASS="li-indexenv">changes, <A HREF="#@default12">1.4</A>
</LI><LI CLASS="li-indexenv">citation, <A HREF="#@default208">5.1</A>, <A HREF="#@default237">7.1</A>
</LI><LI CLASS="li-indexenv">compiler, <A HREF="#@default20">1.7</A>, <A HREF="#@default44">1.9</A>, <A HREF="#@default123">3.1</A>, <A HREF="#@default148">3.3</A>, <A HREF="#@default191">5.1</A>
</LI><LI CLASS="li-indexenv">contact, <A HREF="#@default249">8.2</A>
</LI><LI CLASS="li-indexenv">conversion, <A HREF="#@default125">3.1</A>, <A HREF="#@default140">3.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">directories structure, <A HREF="#@default52">2.1.3</A>
</LI><LI CLASS="li-indexenv">directory tree, <A HREF="#@default94">2.2.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
bin, <A HREF="#@default96">2.2.2</A>
</LI><LI CLASS="li-indexenv">data, <A HREF="#@default100">2.2.2</A>
</LI><LI CLASS="li-indexenv">doc, <A HREF="#@default99">2.2.2</A>, <A HREF="#@default233">7</A>
</LI><LI CLASS="li-indexenv">lib, <A HREF="#@default97">2.2.2</A>
</LI><LI CLASS="li-indexenv">mwi, <A HREF="#@default102">2.2.2</A>
</LI><LI CLASS="li-indexenv">obj, <A HREF="#@default98">2.2.2</A>
</LI><LI CLASS="li-indexenv">shell, <A HREF="#@default101">2.2.2</A>
</LI><LI CLASS="li-indexenv">src, <A HREF="#@default95">2.2.2</A>
</LI><LI CLASS="li-indexenv">tmp, <A HREF="#@default103">2.2.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">distribution package, <A HREF="#@default49">2.1.2</A>
</LI><LI CLASS="li-indexenv">documentation, <A HREF="#@default232">7</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
macro, <A HREF="#@default240">7.2</A>
</LI><LI CLASS="li-indexenv">module, <A HREF="#@default234">7.1</A>
</LI><LI CLASS="li-indexenv">print, <A HREF="#@default241">7.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">download, <A HREF="#@default50">2.1.2</A>, <A HREF="#@default251">8.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">email, <A HREF="#@default255">8.2</A>
</LI><LI CLASS="li-indexenv">environment variable, <A HREF="#@default59">2.1.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
LD_LIBRARY_PATH, <A HREF="#@default78">2.1.4</A>
</LI><LI CLASS="li-indexenv">LD_RUN_PATH, <A HREF="#@default79">2.1.4</A>
</LI><LI CLASS="li-indexenv">MEGAWAVE2, <A HREF="#@default64">2.1.4</A>
</LI><LI CLASS="li-indexenv">MW_CHECK_HIDDEN, <A HREF="#@default93">2.2.1</A>
</LI><LI CLASS="li-indexenv">MW_INCLUDEX11, <A HREF="#@default68">2.1.4</A>
</LI><LI CLASS="li-indexenv">MW_INCLUDEXm, <A HREF="#@default70">2.1.4</A>
</LI><LI CLASS="li-indexenv">MW_LIBJPEG, <A HREF="#@default75">2.1.4</A>
</LI><LI CLASS="li-indexenv">MW_LIBTIFF, <A HREF="#@default72">2.1.4</A>
</LI><LI CLASS="li-indexenv">MW_LIBX11, <A HREF="#@default69">2.1.4</A>
</LI><LI CLASS="li-indexenv">MW_LIBXm, <A HREF="#@default71">2.1.4</A>
</LI><LI CLASS="li-indexenv">MW_MACHINETYPE, <A HREF="#@default66">2.1.4</A>
</LI><LI CLASS="li-indexenv">MW_STDERR, <A HREF="#@default92">2.2.1</A>, <A HREF="#@default187">4.8</A>
</LI><LI CLASS="li-indexenv">MW_STDOUT, <A HREF="#@default91">2.2.1</A>, <A HREF="#@default186">4.8</A>
</LI><LI CLASS="li-indexenv">MY_MEGAWAVE2, <A HREF="#@default65">2.1.4</A>
</LI><LI CLASS="li-indexenv">PRIVATE_MEGAWAVE2, <A HREF="#@default56">2.1.3</A>, <A HREF="#@default63">2.1.4</A>
</LI><LI CLASS="li-indexenv">PUBLIC_MEGAWAVE2, <A HREF="#@default58">2.1.3</A>, <A HREF="#@default62">2.1.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">external type, see <I>file format</I>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Fimage, <A HREF="#@default108">3.1</A>
</LI><LI CLASS="li-indexenv">file format, <A HREF="#@default34">1.7</A>, <A HREF="#@default126">3.1</A>, <A HREF="#@default181">4.8</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
JFIFC, <A HREF="#@default182">4.8</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">file type, see <I>file format</I>
</LI><LI CLASS="li-indexenv">flag, <A HREF="#@default144">3.3</A>
</LI><LI CLASS="li-indexenv">forum, <A HREF="#@default252">8.2</A>
</LI><LI CLASS="li-indexenv">function, <A HREF="#@default115">3.1</A>, <A HREF="#@default156">4.1.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
mw_change_fimage, <A HREF="#@default119">3.1</A>, <A HREF="#@default147">3.3</A>
</LI><LI CLASS="li-indexenv">mw_getdot_fimage, <A HREF="#@default121">3.1</A>
</LI><LI CLASS="li-indexenv">mw_newtab_gray_fimage, <A HREF="#@default138">3.2</A>
</LI><LI CLASS="li-indexenv">mw_plot_fimage, <A HREF="#@default122">3.1</A>
</LI><LI CLASS="li-indexenv">mwerror, <A HREF="#@default117">3.1</A>, <A HREF="#@default145">3.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
FATAL, <A HREF="#@default118">3.1</A>
</LI><LI CLASS="li-indexenv">USAGE, <A HREF="#@default146">3.3</A>
</LI></UL>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">group, <A HREF="#@default27">1.7</A>, <A HREF="#@default158">4.1.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">header<UL CLASS="indexenv"><LI CLASS="li-indexenv">
macro, <A HREF="#@default229">6.1</A>
</LI><LI CLASS="li-indexenv">module, <A HREF="#@default22">1.7</A>, <A HREF="#@default109">3.1</A>, <A HREF="#@default150">4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">hyperlink, <A HREF="#@default213">5.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Install, <A HREF="#@default51">2.1.2</A>, <A HREF="#@default61">2.1.4</A>, <A HREF="#@default84">2.1.5</A>
</LI><LI CLASS="li-indexenv">image, <A HREF="#@default106">3.1</A>
</LI><LI CLASS="li-indexenv">installation, <A HREF="#@default46">2.1</A>, <A HREF="#@default90">2.2</A>
</LI><LI CLASS="li-indexenv">internal type, see <I>structure</I>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">JPEG library, <A HREF="#@default76">2.1.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">kernel, <A HREF="#@default86">2.1.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">LaTeX, <A HREF="#@default40">1.8</A>, <A HREF="#@default81">2.1.4</A>, <A HREF="#@default130">3.1</A>, <A HREF="#@default235">7.1</A>, <A HREF="#@default243">7.3</A>
</LI><LI CLASS="li-indexenv">Linux, <A HREF="#@default14">1.4</A>
</LI><LI CLASS="li-indexenv">labo, <A HREF="#@default113">3.1</A>, <A HREF="#@default157">4.1.4</A>
</LI><LI CLASS="li-indexenv">libjpeg, see <I>JPEG library</I>
</LI><LI CLASS="li-indexenv">libtiff, see <I>TIFF library</I>
</LI><LI CLASS="li-indexenv">license, <A HREF="#@default89">2.1.6</A>, <A HREF="#@default247">8.1</A>, <A HREF="#@default253">8.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">MegaWave, see <I>MegaWave1</I>
</LI><LI CLASS="li-indexenv">MegaWave1, <A HREF="#@default5">1.2</A>
</LI><LI CLASS="li-indexenv">MegaWave2, <A HREF="#@default0">1.1</A>
</LI><LI CLASS="li-indexenv">macro, <A HREF="#@default35">1.8</A>
</LI><LI CLASS="li-indexenv">main function, <A HREF="#@default24">1.7</A>, <A HREF="#@default116">3.1</A>
</LI></UL></TD><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">memory type, see <I>structure</I>
</LI><LI CLASS="li-indexenv">module, <A HREF="#@default1">1.1</A>, <A HREF="#@default19">1.7</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example<UL CLASS="indexenv"><LI CLASS="li-indexenv">
demohead1, <A HREF="#@default173">4.7.1</A>
</LI><LI CLASS="li-indexenv">demohead2, <A HREF="#@default174">4.7.2</A>
</LI><LI CLASS="li-indexenv">demohead3, <A HREF="#@default175">4.7.3</A>
</LI><LI CLASS="li-indexenv">fadd, <A HREF="#@default139">3.3</A>
</LI><LI CLASS="li-indexenv">fadd1, <A HREF="#@default105">3.1</A>
</LI><LI CLASS="li-indexenv">fadd2, <A HREF="#@default131">3.2</A>
</LI><LI CLASS="li-indexenv">fadd3, <A HREF="#@default135">3.2</A>
</LI><LI CLASS="li-indexenv">fadd4, <A HREF="#@default137">3.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">list, <A HREF="#@default226">5.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">mwcommand, <A HREF="#@default110">3.1</A>, <A HREF="#@default151">4.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">name, <A HREF="#@default111">3.1</A>, <A HREF="#@default154">4.1.1</A>
</LI><LI CLASS="li-indexenv">needed statement, <A HREF="#@default152">4.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">object, <A HREF="#@default28">1.7</A>
</LI><LI CLASS="li-indexenv">optimization, <A HREF="#@default132">3.2</A>
</LI><LI CLASS="li-indexenv">option, see <I>usage</I>
</LI><LI CLASS="li-indexenv">optional parameter, <A HREF="#@default141">3.3</A>
</LI><LI CLASS="li-indexenv">optional statement, <A HREF="#@default153">4.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">PostScript, <A HREF="#@default129">3.1</A>
</LI><LI CLASS="li-indexenv">pixel, <A HREF="#@default120">3.1</A>, <A HREF="#@default133">3.2</A>, <A HREF="#@default134">3.2</A>
</LI><LI CLASS="li-indexenv">pointer, <A HREF="#@default136">3.2</A>, <A HREF="#@default142">3.3</A>
</LI><LI CLASS="li-indexenv">preprocessor, <A HREF="#@default2">1.1</A>, <A HREF="#@default15">1.4</A>, <A HREF="#@default23">1.7</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
light, <A HREF="#@default17">1.4</A>
</LI><LI CLASS="li-indexenv">traditional, <A HREF="#@default16">1.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">private MegaWave2, <A HREF="#@default55">2.1.3</A>
</LI><LI CLASS="li-indexenv">private modules, <A HREF="#@default26">1.7</A>, <A HREF="#@default54">2.1.3</A>
</LI><LI CLASS="li-indexenv">private.bib, <A HREF="#@default210">5.1</A>, <A HREF="#@default238">7.1</A>
</LI><LI CLASS="li-indexenv">public MegaWave2, <A HREF="#@default57">2.1.3</A>
</LI><LI CLASS="li-indexenv">public modules, <A HREF="#@default25">1.7</A>, <A HREF="#@default53">2.1.3</A>
</LI><LI CLASS="li-indexenv">public.bib, <A HREF="#@default209">5.1</A>, <A HREF="#@default239">7.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">registration, <A HREF="#@default13">1.4</A>, <A HREF="#@default87">2.1.6</A>, <A HREF="#@default246">8.1</A>
</LI><LI CLASS="li-indexenv">reproducible research, <A HREF="#@default8">1.2</A>
</LI><LI CLASS="li-indexenv">root, <A HREF="#@default48">2.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">soft-publication, <A HREF="#@default7">1.2</A>
</LI><LI CLASS="li-indexenv">structure, <A HREF="#@default31">1.7</A>, <A HREF="#@default143">3.3</A>
</LI><LI CLASS="li-indexenv">system&#X2019;s macro, <A HREF="#@default37">1.8</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
cmw2, <A HREF="#@default38">1.8</A>, <A HREF="#@default45">1.9</A>, <A HREF="#@default124">3.1</A>, <A HREF="#@default190">5.1</A>, <A HREF="#@default200">5.1</A>, <A HREF="#@default231">6.2</A>
</LI><LI CLASS="li-indexenv">cmw2_all, <A HREF="#@default149">3.3</A>, <A HREF="#@default192">5.1</A>
</LI><LI CLASS="li-indexenv">cmw2macro, <A HREF="#@default193">5.1</A>
</LI><LI CLASS="li-indexenv">cxmw2, <A HREF="#@default194">5.1</A>
</LI><LI CLASS="li-indexenv">mwarch, <A HREF="#@default67">2.1.4</A>, <A HREF="#@default197">5.1</A>
</LI><LI CLASS="li-indexenv">mwcleandistrib, <A HREF="#@default198">5.1</A>
</LI><LI CLASS="li-indexenv">mwcmwcheck, <A HREF="#@default199">5.1</A>
</LI><LI CLASS="li-indexenv">mwdep, <A HREF="#@default201">5.1</A>, <A HREF="#@default245">7.3</A>
</LI><LI CLASS="li-indexenv">mwdoc, <A HREF="#@default42">1.8</A>, <A HREF="#@default88">2.1.6</A>, <A HREF="#@default202">5.1</A>
</LI><LI CLASS="li-indexenv">mwdoclatex, <A HREF="#@default39">1.8</A>, <A HREF="#@default224">5.1</A>, <A HREF="#@default242">7.3</A>
</LI><LI CLASS="li-indexenv">mwdocxdvi, <A HREF="#@default225">5.1</A>
</LI><LI CLASS="li-indexenv">mwecho, <A HREF="#@default203">5.1</A>
</LI><LI CLASS="li-indexenv">mwinstall, <A HREF="#@default85">2.1.5</A>, <A HREF="#@default204">5.1</A>
</LI><LI CLASS="li-indexenv">mwmakedoc, <A HREF="#@default196">5.1</A>, <A HREF="#@default244">7.3</A>
</LI><LI CLASS="li-indexenv">mwmodbibtex, <A HREF="#@default205">5.1</A>
</LI><LI CLASS="li-indexenv">mwmodinstall, <A HREF="#@default214">5.1</A>
</LI><LI CLASS="li-indexenv">mwmodlist, <A HREF="#@default215">5.1</A>
</LI><LI CLASS="li-indexenv">mwmodsearch, <A HREF="#@default216">5.1</A>
</LI><LI CLASS="li-indexenv">mwnewuser, <A HREF="#@default104">2.2.2</A>, <A HREF="#@default217">5.1</A>
</LI><LI CLASS="li-indexenv">mwrm, <A HREF="#@default218">5.1</A>
</LI><LI CLASS="li-indexenv">mwrnwordmod, <A HREF="#@default219">5.1</A>
</LI><LI CLASS="li-indexenv">mwsetenv, <A HREF="#@default60">2.1.4</A>, <A HREF="#@default220">5.1</A>
</LI><LI CLASS="li-indexenv">mwsysmaclist, <A HREF="#@default41">1.8</A>, <A HREF="#@default221">5.1</A>
</LI><LI CLASS="li-indexenv">mwvers, <A HREF="#@default222">5.1</A>
</LI><LI CLASS="li-indexenv">mwwhere, <A HREF="#@default223">5.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">system&#X2019;s option, <A HREF="#@default127">3.1</A>, <A HREF="#@default177">4.8</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
-debug, <A HREF="#@default178">4.8</A>
</LI><LI CLASS="li-indexenv">-fsum, <A HREF="#@default179">4.8</A>
</LI><LI CLASS="li-indexenv">-ftype, <A HREF="#@default180">4.8</A>
</LI><LI CLASS="li-indexenv">-help, <A HREF="#@default183">4.8</A>
</LI><LI CLASS="li-indexenv">-proto, <A HREF="#@default184">4.8</A>
</LI><LI CLASS="li-indexenv">-verbose, <A HREF="#@default185">4.8</A>
</LI><LI CLASS="li-indexenv">-vers, <A HREF="#@default188">4.8</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">TIFF library, <A HREF="#@default73">2.1.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">url, <A HREF="#@default212">5.1</A>
</LI><LI CLASS="li-indexenv">usage, <A HREF="#@default160">4.1.7</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
needed argument, <A HREF="#@default163">4.1.7</A>, <A HREF="#@default168">4.3</A>
</LI><LI CLASS="li-indexenv">option, <A HREF="#@default161">4.1.7</A>, <A HREF="#@default167">4.2</A>
</LI><LI CLASS="li-indexenv">optional argument, <A HREF="#@default164">4.1.7</A>, <A HREF="#@default170">4.4</A>
</LI><LI CLASS="li-indexenv">unused argument, <A HREF="#@default166">4.1.7</A>, <A HREF="#@default172">4.6</A>
</LI><LI CLASS="li-indexenv">variable argument, <A HREF="#@default165">4.1.7</A>, <A HREF="#@default171">4.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">user&#X2019;s macro, <A HREF="#@default43">1.8</A>, <A HREF="#@default227">6</A>
</LI><LI CLASS="li-indexenv">user&#X2019;s option, <A HREF="#@default128">3.1</A>, <A HREF="#@default176">4.8</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">version, <A HREF="#@default114">3.1</A>, <A HREF="#@default159">4.1.6</A>, <A HREF="#@default189">4.8</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
1.x, <A HREF="#@default11">1.4</A>
</LI><LI CLASS="li-indexenv">2.x, <A HREF="#@default9">1.4</A>
</LI><LI CLASS="li-indexenv">3.x, <A HREF="#@default10">1.4</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">World Wide Web, <A HREF="#@default211">5.1</A>, <A HREF="#@default250">8.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">XMegaWave2, <A HREF="#@default18">1.5</A>, <A HREF="#@default21">1.7</A>, <A HREF="#@default80">2.1.4</A>, <A HREF="#@default195">5.1</A>
</LI><LI CLASS="li-indexenv">xdvi, <A HREF="#@default82">2.1.4</A>
</LI><LI CLASS="li-indexenv">xv, <A HREF="#@default83">2.1.4</A>
</LI></UL></TD></TR>
</TABLE><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->

</BODY>
</HTML>
